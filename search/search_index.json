{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Au documentation \u00b6 Welcome to the Au library! Au (pronounced \u201cay yoo\u201d) is a C++14-compatible units library, by Aurora . Its key strengths include safety, accessibility, performance, and developer experience. The library source is on GitHub, at aurora-opensource/au . Getting started \u00b6 These pages will be most useful as you begin your Au journey: Alternatives . First off: is Au the right fit for your needs? What else is out there? This page gives a detailed comparison to some of the most prominent other C++ units libraries. Installation . Once you\u2019re ready to try it out, here\u2019s how. You can be up and running in any project within minutes! Tutorials . Start with Au 101: Quantity Makers , and go forward from there. You\u2019ll learn the basic library concepts, and get some hands on experience with the included exercises. Continuing your journey \u00b6 Once you\u2019re up and running with the library, these pages will be handy tools to help you use it more effectively: Troubleshooting . A guide to the most commonly encountered types of error, what they mean, and how to fix them. Take key snippets from your compiler errors, and use in-page search to get help! How-to guides . Step-by-step instructions for accomplishing common tasks you may encounter in using the library. Reference . Detailed reference documentation on Quantity , QuantityPoint , units, magnitudes, and other core library abstractions. We also have a GitHub Issues page for tracking problems and future work. If you have a bug report or feature request, check the existing issues to see if it\u2019s been posted, and file a new one if it hasn\u2019t. While we can\u2019t promise timely resolution , we will do our best to respond quickly so you know you\u2019ve been heard, and where we stand on the issue. Tip Feel free to vote for existing issues by reacting to the main post with the emoji: we\u2019ll take this into account in prioritizing what to work on! Shoring up foundations \u00b6 When you\u2019re looking to understand the library better (as opposed to actively trying to accomplish some task), these docs will help you strengthen your foundations. Discussion . Philosophy and principles, deep dives on design choices, explanations of core concepts, and more.","title":"Au documentation"},{"location":"#au-documentation","text":"Welcome to the Au library! Au (pronounced \u201cay yoo\u201d) is a C++14-compatible units library, by Aurora . Its key strengths include safety, accessibility, performance, and developer experience. The library source is on GitHub, at aurora-opensource/au .","title":"Au documentation"},{"location":"#getting-started","text":"These pages will be most useful as you begin your Au journey: Alternatives . First off: is Au the right fit for your needs? What else is out there? This page gives a detailed comparison to some of the most prominent other C++ units libraries. Installation . Once you\u2019re ready to try it out, here\u2019s how. You can be up and running in any project within minutes! Tutorials . Start with Au 101: Quantity Makers , and go forward from there. You\u2019ll learn the basic library concepts, and get some hands on experience with the included exercises.","title":"Getting started"},{"location":"#continuing-your-journey","text":"Once you\u2019re up and running with the library, these pages will be handy tools to help you use it more effectively: Troubleshooting . A guide to the most commonly encountered types of error, what they mean, and how to fix them. Take key snippets from your compiler errors, and use in-page search to get help! How-to guides . Step-by-step instructions for accomplishing common tasks you may encounter in using the library. Reference . Detailed reference documentation on Quantity , QuantityPoint , units, magnitudes, and other core library abstractions. We also have a GitHub Issues page for tracking problems and future work. If you have a bug report or feature request, check the existing issues to see if it\u2019s been posted, and file a new one if it hasn\u2019t. While we can\u2019t promise timely resolution , we will do our best to respond quickly so you know you\u2019ve been heard, and where we stand on the issue. Tip Feel free to vote for existing issues by reacting to the main post with the emoji: we\u2019ll take this into account in prioritizing what to work on!","title":"Continuing your journey"},{"location":"#shoring-up-foundations","text":"When you\u2019re looking to understand the library better (as opposed to actively trying to accomplish some task), these docs will help you strengthen your foundations. Discussion . Philosophy and principles, deep dives on design choices, explanations of core concepts, and more.","title":"Shoring up foundations"},{"location":"develop/","text":"Development Setup \u00b6 This page explains how to set up the repository for development. This is for two main groups of users: Those who want to contribute to the library, either the code or the docs. Those who want to work through the tutorial exercises . Tip If all you want to do is install the library in your project, you can simply use our installation guide . Core development setup \u00b6 These steps are common to all workflows. Step 0: Decide whether to fork \u00b6 If you\u2019re confident that you want to contribute , you should start out by forking the repository. This gives you your own copy which you can modify, and from which you can create pull requests to share your changes with the main repository. Here are GitHub\u2019s instructions for forking . Everyone else can simply skip this step and work directly from the main repository. If you decide later on to make a pull request, you\u2019ll still need to create a fork, but it\u2019s easy to set it up after the fact. We\u2019ll provide detailed instructions below. Instructions for switching an existing clone to a fork If you\u2019re here, you probably cloned the main repository directly, and then later decided to make a pull request. For that, you\u2019ll need to switch your origin remote to point to your fork instead of the main repository. You can directly use the instructions below, which we adapted from this guide . Create the fork on GitHub. You will need to note the name of your fork, in the format user_name/repo_name . Typically, the user_name part will be replaced with your GitHub username, and the repo_name part will simply be au . Rename origin to upstream . We still want to track the main repository; we just need to give it a different name. Run this command verbatim: git remote rename origin upstream Make your fork the new origin . Your command will start with git remote add origin , and end with a URL for your repository. If your GitHub username were user_name , the full command should look like this: git remote add origin git@github.com:user_name/au.git # ^^^^^^^^^ # Example only: remember to replace user name! Fetch from origin . Run this command verbatim: git fetch origin Track origin from main . Run this command verbatim: git branch -u origin/main main At this point, you should be able to create a pull request in the usual way, simply by pushing a local branch to your fork via the origin remote. Step 1: Clone the repository \u00b6 This step gets the Au source code onto your machine. The precise details depend on whether you decided to fork or not in the previous step. Did you fork, or not? No fork (default) Fork This is for users who just want to work through the tutorials, or play around with the code. git clone https://github.com/aurora-opensource/au.git Follow GitHub\u2019s cloning instructions , using the fork you created as the repository. Whichever approach you took, you should have a folder named au/ in your current directory which contains the Au source code. Step 2: Set up direnv \u00b6 direnv is a tool that makes it easy to use the correct version of every tool we use: bazel , clang-format , buildifier , and other project-specific ones like make-single-file and au-docs-serve . It will add these tools to your $PATH , but only when you\u2019re inside your copy of the repository. What if you skip this step? This step is optional, but highly recommended. If you skip this step, you\u2019ll need to prepend tools/bin/ to every command that comes from Au\u2019s tools directory. For example, Replace bazel with tools/bin/bazel . Replace clang-format with tools/bin/clang-format . And so on. The first step to set up direnv is to install the tool itself, using their installation instructions . The next time you enter your Au folder, you\u2019ll get a warning message like this: direnv: error .envrc is blocked. Run `direnv allow` to approve its content. Simply do what it says and run direnv allow , and you\u2019re all set! Testing your installation You can test that everything\u2019s working by running bazel --version inside your Au folder. You should get a result compatible with the current contents of the .bazelversion file. For example, at the time of writing, we\u2019re on bazel 5.3.0, so this command produces the output: bazel 5.3.0 Specific workflows \u00b6 Now that your basic development setup is complete, here are some types of workflows you can do. Building and testing the code \u00b6 To build and test the entire repository, run bazel test //...:all . Note The first time you run any command such as bazel , there may be some additional overhead from downloading or configuring the tool itself. This is a one-time cost, and each subsequent run should be fast. You can also specify any number of specific targets or target patterns, using bazel\u2019s target syntax . For example, if you wanted to test the core library code (which lives in //au ), and test the generated single-file package (whose target is //release:au_hh_test ), you could write: bazel test //au:all //release:au_hh_test Using different toolchains \u00b6 Au comes pre-packaged with support for several different compiler toolchains. To use a specific toolchain \u2014 say, X \u2014 pass it as a --config=X argument. For example, here\u2019s how you would run all of the tests using gcc 10: bazel test --config = gcc10 //...:all Here are the possible values we support for --config : --config value compiler clang14 Clang 14 (default) clang11 Clang 11 gcc10 gcc 10 What if your preferred compiler isn\u2019t in this list? Our goal is for Au to work with any standards-compliant compiler that fully supports C++14, or any later language standard. We\u2019ve had good results with a variety of compilers already, so we recommend simply trying Au in yours! If you do, and you find a bug, please feel free to file an issue. If the compiler is fully C++14-compatible, we\u2019ll do our best to find a fix, or an acceptable workaround. We may also consider adding the compiler to our officially supported list, as long as we can use it via a hermetic bazel toolchain. Building and viewing documentation \u00b6 It\u2019s easy to set up a local version of the documentation website. Simply run the included command, au-docs-serve . Here\u2019s some example output: INFO: Analyzed target //:update_docs (0 packages loaded, 0 targets configured). INFO: Found 1 target... Target //:update_docs up-to-date: bazel-bin/update_docs INFO: Elapsed time: 0.309s, Critical Path: 0.06s INFO: 1 process: 1 internal. INFO: Build completed successfully, 1 total action INFO: Build completed successfully, 1 total action INFO - Building documentation... INFO - Cleaning site directory INFO - Documentation built in 0.35 seconds INFO - [16:02:34] Watching paths for changes: 'docs', 'mkdocs.yml' INFO - [16:02:34] Serving on http://127.0.0.1:8000/au/ The last line shows that you can view the website at the included (local) URL, http://127.0.0.1:8000/au/ . The command stays running until you interrupt it (typically via Ctrl-C , or the equivalent on your terminal ). Note that as long as it stays running, it will automatically regenerate the website whenever you edit any file, and the browser will automatically reload the page! Viewing documentation on a remote machine Some users connect to a remote machine via ssh to do their development. In this case, au-docs-serve won\u2019t work out of the box. The reason is that it\u2019s running on your remote machine, but your web browser is on your local machine. When you try to open the URL http://127.0.0.1:8000/au/ , which points to the local machine , it can\u2019t find the web server, because it\u2019s running on the remote machine. The solution is to forward the port, 8000 , when you connect to your remote machine. If you do, then local requests on that port will be forwarded along to the remote machine, where the web server is running. Here\u2019s how you do that. Find your usual ssh command. This is whatever you run on your local machine to connect to the remote host. For example, if your username is user and your remote hostname is remote.host , this might look like the following: ssh user@remote.host Add an option for port forwarding. Expanding on the previous example, this would be: ssh -L 8000 :localhost:8000 user@remote.host # ^^^^^^^^^^^^^^^^^^^^^^^ Note: this is added Run au-docs-serve on the remote host. Naturally, you\u2019ll need to be in your Au folder to do this. At this point, as long as that command stays running on your remote host, you should be able to visit the URL in your local browser, and view the documentation website.","title":"Development Setup"},{"location":"develop/#development-setup","text":"This page explains how to set up the repository for development. This is for two main groups of users: Those who want to contribute to the library, either the code or the docs. Those who want to work through the tutorial exercises . Tip If all you want to do is install the library in your project, you can simply use our installation guide .","title":"Development Setup"},{"location":"develop/#core-development-setup","text":"These steps are common to all workflows.","title":"Core development setup"},{"location":"develop/#step-0-decide-whether-to-fork","text":"If you\u2019re confident that you want to contribute , you should start out by forking the repository. This gives you your own copy which you can modify, and from which you can create pull requests to share your changes with the main repository. Here are GitHub\u2019s instructions for forking . Everyone else can simply skip this step and work directly from the main repository. If you decide later on to make a pull request, you\u2019ll still need to create a fork, but it\u2019s easy to set it up after the fact. We\u2019ll provide detailed instructions below. Instructions for switching an existing clone to a fork If you\u2019re here, you probably cloned the main repository directly, and then later decided to make a pull request. For that, you\u2019ll need to switch your origin remote to point to your fork instead of the main repository. You can directly use the instructions below, which we adapted from this guide . Create the fork on GitHub. You will need to note the name of your fork, in the format user_name/repo_name . Typically, the user_name part will be replaced with your GitHub username, and the repo_name part will simply be au . Rename origin to upstream . We still want to track the main repository; we just need to give it a different name. Run this command verbatim: git remote rename origin upstream Make your fork the new origin . Your command will start with git remote add origin , and end with a URL for your repository. If your GitHub username were user_name , the full command should look like this: git remote add origin git@github.com:user_name/au.git # ^^^^^^^^^ # Example only: remember to replace user name! Fetch from origin . Run this command verbatim: git fetch origin Track origin from main . Run this command verbatim: git branch -u origin/main main At this point, you should be able to create a pull request in the usual way, simply by pushing a local branch to your fork via the origin remote.","title":"Step 0: Decide whether to fork"},{"location":"develop/#step-1-clone-the-repository","text":"This step gets the Au source code onto your machine. The precise details depend on whether you decided to fork or not in the previous step. Did you fork, or not? No fork (default) Fork This is for users who just want to work through the tutorials, or play around with the code. git clone https://github.com/aurora-opensource/au.git Follow GitHub\u2019s cloning instructions , using the fork you created as the repository. Whichever approach you took, you should have a folder named au/ in your current directory which contains the Au source code.","title":"Step 1: Clone the repository"},{"location":"develop/#step-2-set-up-direnv","text":"direnv is a tool that makes it easy to use the correct version of every tool we use: bazel , clang-format , buildifier , and other project-specific ones like make-single-file and au-docs-serve . It will add these tools to your $PATH , but only when you\u2019re inside your copy of the repository. What if you skip this step? This step is optional, but highly recommended. If you skip this step, you\u2019ll need to prepend tools/bin/ to every command that comes from Au\u2019s tools directory. For example, Replace bazel with tools/bin/bazel . Replace clang-format with tools/bin/clang-format . And so on. The first step to set up direnv is to install the tool itself, using their installation instructions . The next time you enter your Au folder, you\u2019ll get a warning message like this: direnv: error .envrc is blocked. Run `direnv allow` to approve its content. Simply do what it says and run direnv allow , and you\u2019re all set! Testing your installation You can test that everything\u2019s working by running bazel --version inside your Au folder. You should get a result compatible with the current contents of the .bazelversion file. For example, at the time of writing, we\u2019re on bazel 5.3.0, so this command produces the output: bazel 5.3.0","title":"Step 2: Set up direnv"},{"location":"develop/#specific-workflows","text":"Now that your basic development setup is complete, here are some types of workflows you can do.","title":"Specific workflows"},{"location":"develop/#building-and-testing-the-code","text":"To build and test the entire repository, run bazel test //...:all . Note The first time you run any command such as bazel , there may be some additional overhead from downloading or configuring the tool itself. This is a one-time cost, and each subsequent run should be fast. You can also specify any number of specific targets or target patterns, using bazel\u2019s target syntax . For example, if you wanted to test the core library code (which lives in //au ), and test the generated single-file package (whose target is //release:au_hh_test ), you could write: bazel test //au:all //release:au_hh_test","title":"Building and testing the code"},{"location":"develop/#using-different-toolchains","text":"Au comes pre-packaged with support for several different compiler toolchains. To use a specific toolchain \u2014 say, X \u2014 pass it as a --config=X argument. For example, here\u2019s how you would run all of the tests using gcc 10: bazel test --config = gcc10 //...:all Here are the possible values we support for --config : --config value compiler clang14 Clang 14 (default) clang11 Clang 11 gcc10 gcc 10 What if your preferred compiler isn\u2019t in this list? Our goal is for Au to work with any standards-compliant compiler that fully supports C++14, or any later language standard. We\u2019ve had good results with a variety of compilers already, so we recommend simply trying Au in yours! If you do, and you find a bug, please feel free to file an issue. If the compiler is fully C++14-compatible, we\u2019ll do our best to find a fix, or an acceptable workaround. We may also consider adding the compiler to our officially supported list, as long as we can use it via a hermetic bazel toolchain.","title":"Using different toolchains"},{"location":"develop/#building-and-viewing-documentation","text":"It\u2019s easy to set up a local version of the documentation website. Simply run the included command, au-docs-serve . Here\u2019s some example output: INFO: Analyzed target //:update_docs (0 packages loaded, 0 targets configured). INFO: Found 1 target... Target //:update_docs up-to-date: bazel-bin/update_docs INFO: Elapsed time: 0.309s, Critical Path: 0.06s INFO: 1 process: 1 internal. INFO: Build completed successfully, 1 total action INFO: Build completed successfully, 1 total action INFO - Building documentation... INFO - Cleaning site directory INFO - Documentation built in 0.35 seconds INFO - [16:02:34] Watching paths for changes: 'docs', 'mkdocs.yml' INFO - [16:02:34] Serving on http://127.0.0.1:8000/au/ The last line shows that you can view the website at the included (local) URL, http://127.0.0.1:8000/au/ . The command stays running until you interrupt it (typically via Ctrl-C , or the equivalent on your terminal ). Note that as long as it stays running, it will automatically regenerate the website whenever you edit any file, and the browser will automatically reload the page! Viewing documentation on a remote machine Some users connect to a remote machine via ssh to do their development. In this case, au-docs-serve won\u2019t work out of the box. The reason is that it\u2019s running on your remote machine, but your web browser is on your local machine. When you try to open the URL http://127.0.0.1:8000/au/ , which points to the local machine , it can\u2019t find the web server, because it\u2019s running on the remote machine. The solution is to forward the port, 8000 , when you connect to your remote machine. If you do, then local requests on that port will be forwarded along to the remote machine, where the web server is running. Here\u2019s how you do that. Find your usual ssh command. This is whatever you run on your local machine to connect to the remote host. For example, if your username is user and your remote hostname is remote.host , this might look like the following: ssh user@remote.host Add an option for port forwarding. Expanding on the previous example, this would be: ssh -L 8000 :localhost:8000 user@remote.host # ^^^^^^^^^^^^^^^^^^^^^^^ Note: this is added Run au-docs-serve on the remote host. Naturally, you\u2019ll need to be in your Au folder to do this. At this point, as long as that command stays running on your remote host, you should be able to visit the URL in your local browser, and view the documentation website.","title":"Building and viewing documentation"},{"location":"install/","text":"Installation \u00b6 Au can be installed in multiple ways. First, we\u2019ll help you decide which one is right for you. Then, we\u2019ll provide full instructions for each option. Broadly, you can either do a \u201cfull install\u201d of the library, or you can package it into a single header file. For the latter approach, there are two options: Pre-built versions you can download right away. Custom versions with exactly the units you choose. Choosing a method \u00b6 You should consider several factors before you decide how to install the Au library, such as: Tradeoffs in setup time, unit selection, and flexibility. Whether you\u2019re installing for production, or just trying it out. Your build system. Here\u2019s an overview of the tradeoffs involved. Legend Unsupported Fair Good Best Single File Full Install Pre-built Custom bazel CMake, conan, vcpkg, ... Setup time ~1 min ~10 min ~10 min Not yet supported (use single-file instead for now) Unit selection Base units only Any units desired Any units desired, without needing \"reinstall\" Compile time cost ~10 units Very competitive up to a few dozen units Each file only pays for the units it uses Flexibility Awkward: would need to download io.hh and/or testing.hh separately, and modify their includes manually Include I/O, testing utilities, individual units as desired, on a per-file basis So, which should you use? graph TD Usage[What's your use case?] SetupTime[Got 10 minutes for setup?] BuildSystem[What's your build system?] UsePreBuilt[Use pre-built single file] UseCustom[Use custom single file] UseFullInstall[Use full install] Usage -->|Just playing around with Au| SetupTime SetupTime -->|No! Just let me start!| UsePreBuilt SetupTime -->|Sure| UseCustom Usage -->|Ready to use in my project!| BuildSystem BuildSystem -->|bazel| UseFullInstall BuildSystem -->|other| UseCustom Installation instructions \u00b6 Here are the instructions for each installation method we support. Single file \u00b6 The Au library can be packaged as a single header file, which you can include in your project just like any other header. This works with any build system! To take this approach, obtain the single file by one of the methods described below. Then, put it inside a third_party folder (for example, as third_party/au.hh ). Now you\u2019re up and running with Au! Every single-file package automatically includes the following features: TODO As reference docs become available for each of the following, we should link to them. Basic \u201cunit container\u201d types: Quantity , QuantityPoint Magnitude types and values, including the constant PI , and constants for any integer such as mag<5280>() . All prefixes for SI ( kilo , mega , \u2026) and informational ( kibi , mebi , \u2026) quantities. Math functions, including unit-aware rounding and inverses, trigonometric functions, square roots, and so on. Bidirectional implicit conversion between Quantity types and any equivalent counterparts in the std::chrono library. Here are the two ways to get a single-file packaging of the library. Pre-built single file \u00b6 Tip This approach is mainly for playing with the library. It\u2019s very fast to get up and running, but it\u2019s not the best choice as the \u201cproduction\u201d installation of your library. For a single-file approach, most users will be much better served by the next section, which explains how to customize it to get exactly the units you want. We provide pre-generated single-file versions of the library, automatically generated from the latest commit in the repo: au.hh au_noio.hh (Same as above, but with <iostream> support stripped out) These include very few units (to keep compile times short). However, combinations of these units should get you any other unit you\u2019re likely to want. The units we include are: Every SI base unit ( seconds , meters , kilo(grams) , amperes , kelvins , moles , candelas ) Base units for angles and information ( radians , bits ) A base dimensionless unit ( unos ) Note How do you go about constructing other units from these? By composing them. For example, you can make other coherent SI units like this: constexpr auto newtons = kilo ( gram ) * meters / squared ( second ); Now you can call, say, newtons(10) and get a quantity equivalent to 10 Newtons. You can also scale a unit by multiplying by Magnitude objects. For example: constexpr auto degrees = radians * PI / mag < 180 > (); These will \u201cwork\u201d, in the sense of producing correct results. But these ad hoc unit definitions are far less usable than fully defined units . Both the type names and the unit symbols will be needlessly complicated. Again, we recommend following the directions in the next section to get exactly the units you care about. Custom single file \u00b6 It\u2019s easy to package the library in a custom single file with exactly the units you need. Here\u2019s how: Clone the repo . Go to the aurora-opensource/au repo, and follow the typical instructions. If you\u2019re just a user of Au, not a contributor , this should be: git clone https://github.com/aurora-opensource/au.git Run the script . tools/bin/make-single-file --units meters seconds newtons > ~/au.hh creates a file, ~/au.hh , which packages the entire library in a single file with these three units. To see the full list of available units, search the .hh files in the au/units/ folder. For example, meters will include the contents of au/units/meters.hh . Provide the --noio flag if you prefer to avoid the expense of the <iostream> library. Now you have a file, ~/au.hh , which you can add to your third_party folder. Full library installation \u00b6 bazel \u00b6 Warning These instructions were written while the Au repo was still private. Therefore, we couldn\u2019t fully test that they actually work . However, when adding a backup file:/// URL pointing to a manually downloaded copy, they did work, which is a very promising sign. Choose your Au version . This can be a tag, or a commit hash. Let\u2019s take 0.2.0 as an example. Form the URL to the archive . For 0.2.0 , this would be: https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz NOTE: Your au version ID goes HERE ^^^^^ Compute your SHA256 hash . Follow the URL from the previous step to download the archive. Compute the SHA256 hash: sha256sum au-0.2.0.tar.gz The first token that appears is the hash. Save it for the next step. Add http_archive rule to WORKSPACE . Follow this pattern: http_archive ( name = \"au\" , sha256 = \"bdaec065b35f44af2cb22def5b69ac08ca40c47791ea3ed2eb3ebf3e85b3e0b0\" , strip_prefix = \"au-0.2.0\" , urls = [ \"https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz\" ], ) In particular, here\u2019s how to fill out the fields: sha256 : Use the SHA256 hash you got from step 3. strip_prefix : write \"au-0.2.0\" , except use your ID from step 1 instead of 0.2.0 . urls : This should be a list, whose only entry is the URL you formed in step 2. At this point, the Au library is installed, and you can use it in your project! Here are the headers provided by each Au target. To use, add the \u201cDependency\u201d to your deps attribute, and include the appropriate files. Dependency Headers provided Notes @au//au \"au/au.hh\" \"au/units.*.hh\" Core library functionality. See all available units @au//au:io \"au/io.hh\" operator<< support @au//au:testing \"au/testing.hh\" Utilities for testing Note: testonly = True Other build systems (CMake / conan / vcpkg / \u2026) \u00b6 We would like to support all these build and packaging systems, and perhaps others! But the initial public release is bazel-only, because bazel is what we use at Aurora, and we don\u2019t have experience with any of these alternatives. Thus, we\u2019ll need to lean on the community to support them. Meanwhile, the library itself is still at least partially available on all build environments, via the single-file options explained above.","title":"Installation"},{"location":"install/#installation","text":"Au can be installed in multiple ways. First, we\u2019ll help you decide which one is right for you. Then, we\u2019ll provide full instructions for each option. Broadly, you can either do a \u201cfull install\u201d of the library, or you can package it into a single header file. For the latter approach, there are two options: Pre-built versions you can download right away. Custom versions with exactly the units you choose.","title":"Installation"},{"location":"install/#choosing-a-method","text":"You should consider several factors before you decide how to install the Au library, such as: Tradeoffs in setup time, unit selection, and flexibility. Whether you\u2019re installing for production, or just trying it out. Your build system. Here\u2019s an overview of the tradeoffs involved. Legend Unsupported Fair Good Best Single File Full Install Pre-built Custom bazel CMake, conan, vcpkg, ... Setup time ~1 min ~10 min ~10 min Not yet supported (use single-file instead for now) Unit selection Base units only Any units desired Any units desired, without needing \"reinstall\" Compile time cost ~10 units Very competitive up to a few dozen units Each file only pays for the units it uses Flexibility Awkward: would need to download io.hh and/or testing.hh separately, and modify their includes manually Include I/O, testing utilities, individual units as desired, on a per-file basis So, which should you use? graph TD Usage[What's your use case?] SetupTime[Got 10 minutes for setup?] BuildSystem[What's your build system?] UsePreBuilt[Use pre-built single file] UseCustom[Use custom single file] UseFullInstall[Use full install] Usage -->|Just playing around with Au| SetupTime SetupTime -->|No! Just let me start!| UsePreBuilt SetupTime -->|Sure| UseCustom Usage -->|Ready to use in my project!| BuildSystem BuildSystem -->|bazel| UseFullInstall BuildSystem -->|other| UseCustom","title":"Choosing a method"},{"location":"install/#installation-instructions","text":"Here are the instructions for each installation method we support.","title":"Installation instructions"},{"location":"install/#single-file","text":"The Au library can be packaged as a single header file, which you can include in your project just like any other header. This works with any build system! To take this approach, obtain the single file by one of the methods described below. Then, put it inside a third_party folder (for example, as third_party/au.hh ). Now you\u2019re up and running with Au! Every single-file package automatically includes the following features: TODO As reference docs become available for each of the following, we should link to them. Basic \u201cunit container\u201d types: Quantity , QuantityPoint Magnitude types and values, including the constant PI , and constants for any integer such as mag<5280>() . All prefixes for SI ( kilo , mega , \u2026) and informational ( kibi , mebi , \u2026) quantities. Math functions, including unit-aware rounding and inverses, trigonometric functions, square roots, and so on. Bidirectional implicit conversion between Quantity types and any equivalent counterparts in the std::chrono library. Here are the two ways to get a single-file packaging of the library.","title":"Single file"},{"location":"install/#pre-built-single-file","text":"Tip This approach is mainly for playing with the library. It\u2019s very fast to get up and running, but it\u2019s not the best choice as the \u201cproduction\u201d installation of your library. For a single-file approach, most users will be much better served by the next section, which explains how to customize it to get exactly the units you want. We provide pre-generated single-file versions of the library, automatically generated from the latest commit in the repo: au.hh au_noio.hh (Same as above, but with <iostream> support stripped out) These include very few units (to keep compile times short). However, combinations of these units should get you any other unit you\u2019re likely to want. The units we include are: Every SI base unit ( seconds , meters , kilo(grams) , amperes , kelvins , moles , candelas ) Base units for angles and information ( radians , bits ) A base dimensionless unit ( unos ) Note How do you go about constructing other units from these? By composing them. For example, you can make other coherent SI units like this: constexpr auto newtons = kilo ( gram ) * meters / squared ( second ); Now you can call, say, newtons(10) and get a quantity equivalent to 10 Newtons. You can also scale a unit by multiplying by Magnitude objects. For example: constexpr auto degrees = radians * PI / mag < 180 > (); These will \u201cwork\u201d, in the sense of producing correct results. But these ad hoc unit definitions are far less usable than fully defined units . Both the type names and the unit symbols will be needlessly complicated. Again, we recommend following the directions in the next section to get exactly the units you care about.","title":"Pre-built single file"},{"location":"install/#custom-single-file","text":"It\u2019s easy to package the library in a custom single file with exactly the units you need. Here\u2019s how: Clone the repo . Go to the aurora-opensource/au repo, and follow the typical instructions. If you\u2019re just a user of Au, not a contributor , this should be: git clone https://github.com/aurora-opensource/au.git Run the script . tools/bin/make-single-file --units meters seconds newtons > ~/au.hh creates a file, ~/au.hh , which packages the entire library in a single file with these three units. To see the full list of available units, search the .hh files in the au/units/ folder. For example, meters will include the contents of au/units/meters.hh . Provide the --noio flag if you prefer to avoid the expense of the <iostream> library. Now you have a file, ~/au.hh , which you can add to your third_party folder.","title":"Custom single file"},{"location":"install/#full-library-installation","text":"","title":"Full library installation"},{"location":"install/#bazel","text":"Warning These instructions were written while the Au repo was still private. Therefore, we couldn\u2019t fully test that they actually work . However, when adding a backup file:/// URL pointing to a manually downloaded copy, they did work, which is a very promising sign. Choose your Au version . This can be a tag, or a commit hash. Let\u2019s take 0.2.0 as an example. Form the URL to the archive . For 0.2.0 , this would be: https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz NOTE: Your au version ID goes HERE ^^^^^ Compute your SHA256 hash . Follow the URL from the previous step to download the archive. Compute the SHA256 hash: sha256sum au-0.2.0.tar.gz The first token that appears is the hash. Save it for the next step. Add http_archive rule to WORKSPACE . Follow this pattern: http_archive ( name = \"au\" , sha256 = \"bdaec065b35f44af2cb22def5b69ac08ca40c47791ea3ed2eb3ebf3e85b3e0b0\" , strip_prefix = \"au-0.2.0\" , urls = [ \"https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz\" ], ) In particular, here\u2019s how to fill out the fields: sha256 : Use the SHA256 hash you got from step 3. strip_prefix : write \"au-0.2.0\" , except use your ID from step 1 instead of 0.2.0 . urls : This should be a list, whose only entry is the URL you formed in step 2. At this point, the Au library is installed, and you can use it in your project! Here are the headers provided by each Au target. To use, add the \u201cDependency\u201d to your deps attribute, and include the appropriate files. Dependency Headers provided Notes @au//au \"au/au.hh\" \"au/units.*.hh\" Core library functionality. See all available units @au//au:io \"au/io.hh\" operator<< support @au//au:testing \"au/testing.hh\" Utilities for testing Note: testonly = True","title":"bazel"},{"location":"install/#other-build-systems-cmake-conan-vcpkg","text":"We would like to support all these build and packaging systems, and perhaps others! But the initial public release is bazel-only, because bazel is what we use at Aurora, and we don\u2019t have experience with any of these alternatives. Thus, we\u2019ll need to lean on the community to support them. Meanwhile, the library itself is still at least partially available on all build environments, via the single-file options explained above.","title":"Other build systems (CMake / conan / vcpkg / ...)"},{"location":"troubleshooting/","text":"Troubleshooting Guide \u00b6 This page is a guide to the most commonly encountered types of error, what they mean, and how to fix them. The intended use case is to help you interpret an actual error in your code , at the point where you encounter it. To use this page, copy some relevant snippets from your compiler error, and then search the text of this page using your browser\u2019s Find function. Tip To improve your chances of finding what you\u2019re looking for, we include full compiler errors from both gcc and clang, inline with the text. Naturally, this makes this page very long, so it\u2019s not meant to be read straight through. Stick with your browser\u2019s Find function. Each section below lists one category of compiler error you might encounter when using the library. It explains what it means and how to solve it, and gives specific snippets of erroneous code, along with the compiler errors that each would yield. Private constructor \u00b6 Meaning: This means you passed a raw numeric value to an interface that expected a Quantity. It\u2019s the \u201cclassic\u201d error the units library aims to prevent. Solution: Call the appropriate Quantity maker: instead of passing x , pass meters(x) , (kilo(meters) / hour)(x) , etc. A note on quantity makers vs. constructors Every other major units library lets you construct its Quantity types from raw numeric values; it just makes that constructor explicit. Au goes further, and makes this constructor private. The reason is to preserve unit safety at all callsites. We can\u2019t know whether you made an alias that doesn\u2019t name the unit. For example, if you want everybody to measure lengths in Meters in your codebase, you might provide a common alias like this: using Length = QuantityD < Meters > ; If you did, then end users could write the following: constexpr Length MAX_LENGTH { 5.5 }; // Unsafe! Units unclear. :( A core principle of the Au library is that the only way to enter or exit the library boundaries is to name the unit of measure, explicitly, at the callsite, like this: constexpr Length MAX_LENGTH = meters ( 5.5 ); // Usable! Units unambiguous. :) This enables users who want to use this kind of \u201cdimension-named alias\u201d in their codebase to do so safely. Example Code Broken Fixed void set_timeout ( QuantityD < Seconds > dt ); // A (BROKEN): passing raw number where duration expected. set_timeout ( 0.5 ); // B (BROKEN): calling Quantity constructor directly. constexpr QuantityD < Meters > length { 5.5 }; void set_timeout ( QuantityD < Seconds > dt ); // A (FIXED): name the unit. set_timeout ( seconds ( 0.5 )); // B (FIXED): calling Quantity constructor directly. constexpr QuantityD < Meters > length = meters ( 5.5 ); Compiler error (clang 14) au/error_examples.cc:19:17: error: calling a private constructor of class 'au::Quantity<au::Seconds, double>' set_timeout(0.5); ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ au/error_examples.cc:22:33: error: calling a private constructor of class 'au::Quantity<au::Meters, double>' constexpr QuantityD<Meters> length{5.5}; ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ Compiler error (clang 11) au/error_examples.cc:19:17: error: calling a private constructor of class 'au::Quantity<au::Seconds, double>' set_timeout(0.5); ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ au/error_examples.cc:22:33: error: calling a private constructor of class 'au::Quantity<au::Meters, double>' constexpr QuantityD<Meters> length{5.5}; ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ Compiler error (gcc 10) au/error_examples.cc: In function 'void au::example_private_constructor()': au/error_examples.cc:19:20: error: 'constexpr au::Quantity<UnitT, RepT>::Quantity(au::Quantity<UnitT, RepT>::Rep) [with UnitT = au::Seconds; RepT = double; au::Quantity<UnitT, RepT>::Rep = double]' is private within this context 19 | set_timeout(0.5); | ^ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh:369:15: note: declared private here 369 | constexpr Quantity(Rep value) : value_{value} {} | ^~~~~~~~ au/error_examples.cc:22:43: error: 'constexpr au::Quantity<UnitT, RepT>::Quantity(au::Quantity<UnitT, RepT>::Rep) [with UnitT = au::Meters; RepT = double; au::Quantity<UnitT, RepT>::Rep = double]' is private within this context 22 | constexpr QuantityD<Meters> length{5.5}; | ^ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh:369:15: note: declared private here 369 | constexpr Quantity(Rep value) : value_{value} {} | ^~~~~~~~ Dangerous conversion \u00b6 Meaning: This is a physically meaningful conversion, but we think the risk of a grossly incorrect answer is too high, so we forbid it. There are two main sources for this risk, both having to do with integral storage types. Inexact conversion . Example: inches(24).as(feet) . Overflow . Example: giga(hertz)(1).as(hertz) . Both of these examples would in fact produce the correct answer with the specific values given ( 24 and 1 ). However, many (most!) other values would not. Thus, we disallow the entire conversion operation (at least in this format). Solution: There are different strategies to solve this, depending on your use case. Use floating point . As mentioned above, these risks only apply to integer values. If floating point is what you want anyway, just use it. giga(hertz)(1.0).as(hertz) produces hertz(1'000'000'000.0) . Use \u201cexplicit Rep\u201d form . The \u201cRep\u201d is the storage type for the Quantity. If you pass it as a template parameter, it is \u201cmorally equivalent\u201d to a static_cast , and has the same \u201cforcing\u201d semantics. inches(24).as<int>(feet) produces feet(2) . Warning Stop and think before using the explicit Rep version. If you\u2019re reviewing code that uses it, ask about it. The library is trying to protect you from an error prone operation. The mechanism exists because sometimes you can know that it\u2019s OK, but remember to stop and check first! Example Code Broken Fixed (1. Floating Point) Fixed (2. Explicit Rep) // A (BROKEN): inexact conversion. inches ( 24 ). as ( feet ); // B (BROKEN): overflow risk. giga ( hertz )( 1 ). as ( hertz ); // A (FIXED): 1. use floating point. inches ( 24.0 ). as ( feet ); // B (FIXED): 1. use floating point. giga ( hertz )( 1.0 ). as ( hertz ); // A (FIXED): 2. provide explicit Rep. inches ( 24 ). as < int > ( feet ); // B (FIXED): 2. provide explicit Rep. giga ( hertz )( 1 ). as < int > ( hertz ); Compiler error (clang 14) ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:30:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet>' requested here inches(24).as(feet); ^ In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:33:20: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz>' requested here giga(hertz)(1).as(hertz); ^ Compiler error (clang 11) ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:30:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet>' requested here inches(24).as(feet); ^ In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:33:20: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz>' requested here giga(hertz)(1).as(hertz); ^ Compiler error (gcc 10) ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::as(NewUnit) const [with NewUnit = au::Feet; <template-parameter-2-2> = void; UnitT = au::Inches; RepT = int]': ./au/quantity.hh:183:18: required from 'constexpr auto au::Quantity<UnitT, RepT>::as(au::QuantityMaker<NewUnit>) const [with NewUnit = au::Feet; UnitT = au::Inches; RepT = int]' au/error_examples.cc:30:23: required from here ./au/quantity.hh:147:72: error: static assertion failed: Dangerous conversion: use .as<Rep>(NewUnit) instead 147 | static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~ ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::as(NewUnit) const [with NewUnit = au::Hertz; <template-parameter-2-2> = void; UnitT = au::Giga<au::Hertz>; RepT = int]': ./au/quantity.hh:183:18: required from 'constexpr auto au::Quantity<UnitT, RepT>::as(au::QuantityMaker<NewUnit>) const [with NewUnit = au::Hertz; UnitT = au::Giga<au::Hertz>; RepT = int]' au/error_examples.cc:33:28: required from here ./au/quantity.hh:147:72: error: static assertion failed: Dangerous conversion: use .as<Rep>(NewUnit) instead No type named \u2018type\u2019 in \u2018std::common_type\u2019 \u00b6 Meaning: You probably tried to perform a \u201ccommon-unit operation\u201d (addition, subtraction, comparison) with two incompatible Quantities. Typically, this means they have different dimensions , which makes this an intrinsically meaningless operation. TODO Make a page which explains common-unit operations, and link to it. Solution: Figure out what dimension you expected them to have, and which value had the wrong dimension. Then, figure out how to fix your expression so it has the right dimension. Example Code Broken Fixed // (BROKEN): different dimensions. meters ( 1 ) + seconds ( 1 ); // (FIXED): fix coding mistake. meters ( 1 ) + seconds ( 1 ) * ( meters / second )( 10 ); Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:5: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/chrono:697: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/__chrono/calendar.h:13: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/__chrono/duration.h:14: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/limits:105: external/llvm_14_toolchain_llvm/bin/../include/c++/v1/type_traits:2388:25: error: no type named 'type' in 'std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>>' template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^~~~~ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:532:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>, au::detail::Plus>' requested here return detail::using_common_type(q1, q2, detail::plus); ^ au/error_examples.cc:41:15: note: in instantiation of function template specialization 'au::operator+<au::Meters, au::Seconds, int, int>' requested here meters(1) + seconds(1); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:5: In file included from external/llvm_11_toolchain_llvm/bin/../include/c++/v1/chrono:828: external/llvm_11_toolchain_llvm/bin/../include/c++/v1/type_traits:2462:25: error: no type named 'type' in 'std::__1::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>>' template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^~~~~ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:532:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>, au::detail::Plus>' requested here return detail::using_common_type(q1, q2, detail::plus); ^ au/error_examples.cc:41:15: note: in instantiation of function template specialization 'au::operator+<au::Meters, au::Seconds, int, int>' requested here meters(1) + seconds(1); ^ Compiler error (gcc 10) In file included from external/sysroot_x86_64//include/c++/10.3.0/ratio:39, from external/sysroot_x86_64//include/c++/10.3.0/chrono:39, from ./au/au.hh:5, from au/error_examples.cc:1: external/sysroot_x86_64//include/c++/10.3.0/type_traits: In substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>}]': ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Meters, int>; U = au::Quantity<au::Seconds, int>; Func = au::detail::Plus]' ./au/quantity.hh:532:37: required from 'constexpr auto au::operator+(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Meters; U2 = au::Seconds; R1 = int; R2 = int]' au/error_examples.cc:41:26: required from here external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: error: no type named 'type' in 'struct std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int> >' 2562 | using common_type_t = typename common_type<_Tp...>::type; | ^~~~~~~~~~~~~ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh: In instantiation of 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Meters, int>; U = au::Quantity<au::Seconds, int>; Func = au::detail::Plus]': ./au/quantity.hh:532:37: required from 'constexpr auto au::operator+(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Meters; U2 = au::Seconds; R1 = int; R2 = int]' au/error_examples.cc:41:26: required from here Integer division forbidden \u00b6 Meaning: Although Au generally tries to act just like the underlying raw numeric types, we also try to prevent wrong code that looks correct from compiling. It turns out to be just too easy to use integral Reps without noticing, and thus to get integer division without noticing. This can lead to very large errors. Solution: If you really wanted integer division, call integer_quotient() . Otherwise, use floating point types. Example Code How long does it take to travel 60 m at a speed of 65 MPH? Broken Fixed (1. Floating point) Fixed (2. integer_quotient() ) // (BROKEN): gives (60 / 65) == 0 before conversion! QuantityD < Seconds > t = meters ( 60 ) / ( miles / hour )( 65 ); // (FIXED): 1. Using floating point, we get ~= seconds(2.06486) QuantityD < Seconds > t = meters ( 60.0 ) / ( miles / hour )( 65.0 ); // (FIXED): 2. Integer result == (meter * hours / mile)(0) auto t = integer_quotient ( meters ( 60 ), ( miles / hour )( 65 )); Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:304:9: error: static_assert failed due to requirement '!uses_integer_division' \"Integer division forbidden: use integer_quotient() if you really want it\" static_assert(!uses_integer_division, ^ ~~~~~~~~~~~~~~~~~~~~~~ au/error_examples.cc:49:39: note: in instantiation of function template specialization 'au::Quantity<au::Meters, int>::operator/<au::UnitProduct<au::Miles, au::Pow<au::Hours, -1>>, int>' requested here QuantityD<Seconds> t = meters(60) / (miles / hour)(65); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:304:9: error: static_assert failed due to requirement '!uses_integer_division' \"Integer division forbidden: use integer_quotient() if you really want it\" static_assert(!uses_integer_division, ^ ~~~~~~~~~~~~~~~~~~~~~~ au/error_examples.cc:49:39: note: in instantiation of function template specialization 'au::Quantity<au::Meters, int>::operator/<au::UnitProduct<au::Miles, au::Pow<au::Hours, -1>>, int>' requested here QuantityD<Seconds> t = meters(60) / (miles / hour)(65); ^ Compiler error (gcc 10) ./au/quantity.hh:496:94: error: no type named 'type' in 'struct std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int> >' 496 | std::is_same<typename C::Rep, std::common_type_t<typename T::Rep, typename U::Rep>>::value, | ^~~~~ ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::operator/(au::Quantity<OtherUnit, OtherRep>) const [with OtherUnit = au::UnitProduct<au::Miles, au::Pow<au::Hours, -1> >; OtherRep = int; UnitT = au::Meters; RepT = int]': au/error_examples.cc:49:58: required from here ./au/quantity.hh:304:23: error: static assertion failed: Integer division forbidden: use integer_quotient() if you really want it 304 | static_assert(!uses_integer_division, | ^~~~~~~~~~~~~~~~~~~~~~ Dangerous inversion \u00b6 Meaning: This is analogous to our overflow safety surface. When computing the inverse of an integral quantity in a given target unit, there is some smallest value that will get truncated down to zero (a tremendous error!). If that value is \u201csmall enough to be scary\u201d (currently 1,000), we forbid the conversion. Solution: Consider using floating point; you\u2019ll always get a precise answer. Alternatively, use a smaller target unit. Example Code Broken Fixed (1. Floating point) Fixed (2. Smaller target unit) // (BROKEN): excessive truncation risk. inverse_as ( seconds , hertz ( 5 )); // (FIXED): 1. Floating point result ~= seconds(0.2) inverse_as ( seconds , hertz ( 5.0 )); // (FIXED): 2. Integer result == milli(seconds)(200) inverse_as ( milli ( seconds ), hertz ( 5 )); Note If you\u2019re really sure it\u2019s OK, you can use the explicit-Rep version of inverse_as , which is forcing like a static_cast . This is rarely the right choice, though. Consider: inverse_as < int > ( seconds , hertz ( 5 )); This yields seconds(0) , due to the gross truncation error which the check was designed to prevent in the first place. Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: ./au/math.hh:205:5: error: static_assert failed due to requirement 'make_quantity<au::UnitProduct<>>(int{1}).in(associated_unit(target_units) * au::Hertz{}) >= 1000 || std::is_floating_point<int>::value' \"Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\" static_assert( ^ ./au/math.hh:221:56: note: in instantiation of function template specialization 'au::inverse_in<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here return make_quantity<AssociatedUnitT<TargetUnits>>(inverse_in(target_units, q)); ^ au/error_examples.cc:57:5: note: in instantiation of function template specialization 'au::inverse_as<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here inverse_as(seconds, hertz(5)); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: ./au/math.hh:205:5: error: static_assert failed due to requirement 'make_quantity<au::UnitProduct<>>(int{1}).in(associated_unit(target_units) * au::Hertz{}) >= 1000 || std::is_floating_point<int>::value' \"Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\" static_assert( ^ ./au/math.hh:221:56: note: in instantiation of function template specialization 'au::inverse_in<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here return make_quantity<AssociatedUnitT<TargetUnits>>(inverse_in(target_units, q)); ^ au/error_examples.cc:57:5: note: in instantiation of function template specialization 'au::inverse_as<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here inverse_as(seconds, hertz(5)); ^ Compiler error (gcc 10) In file included from ./au/au.hh:7, from au/error_examples.cc:1: ./au/math.hh: In instantiation of 'constexpr auto au::inverse_in(TargetUnits, au::Quantity<Unit, Rep>) [with TargetUnits = au::QuantityMaker<au::Seconds>; U = au::Hertz; R = int]': ./au/math.hh:221:66: required from 'constexpr auto au::inverse_as(TargetUnits, au::Quantity<Unit, Rep>) [with TargetUnits = au::QuantityMaker<au::Seconds>; U = au::Hertz; R = int]' au/error_examples.cc:57:33: required from here ./au/math.hh:206:93: error: static assertion failed: Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired 206 | make_quantity<UnitProductT<>>(R{1}).in(associated_unit(target_units) * U{}) >= 1000 || | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~ 207 | std::is_floating_point<R>::value, | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Deduced conflicting types \u00b6 Meaning: In some contexts, it\u2019s not enough to have Quantity types that can easily convert to each other. (Common examples include the ternary operator ?: , and initializer lists.) You need types that are identical, or very nearly so. Even fully quantity-equivalent types, such as \\text{Hz} \\text{Hz} and \\text{s}^{-1} \\text{s}^{-1} , often won\u2019t work in these contexts! Solution: You can always cast non-conforming instances to your favored unit, using .as() . For the initializer list case, you can also make an explicit container, which will handle the casting automatically when possible. Example Code Broken Fixed (1. Cast to explicit unit) Fixed (2. Use explicit container) // (BROKEN): Initializer list confused by Hz and s^(-1). for ( const auto & frequency : { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )), }) { // ... } // (FIXED): 1. Cast individual elements to desired unit. for ( const auto & frequency : { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )). as ( hertz ), }) { // ... } // (FIXED): 2. Use container with explicit type. for ( const auto & frequency : std :: vector < QuantityD < Hertz >> { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )), }) { // ... } Compiler error (clang 14) au/error_examples.cc:65:34: error: deduced conflicting types ('Quantity<au::QuantityMaker<au::Hertz>::Unit, [...]>' vs 'Quantity<au::QuantityMaker<au::Pow<au::Seconds, -1>>::Unit, [...]>') for initializer list element type for (const auto &frequency : { ^ Compiler error (clang 11) au/error_examples.cc:65:34: error: deduced conflicting types ('Quantity<au::Hertz, [...]>' vs 'Quantity<au::Pow<au::Seconds, -1>, [...]>') for initializer list element type for (const auto &frequency : { ^ Compiler error (gcc 10) au/error_examples.cc: In function 'void au::example_deduced_conflicting_types()': au/error_examples.cc:68:10: error: unable to deduce 'std::initializer_list<auto>&&' from '{au::hertz.au::QuantityMaker<au::Hertz>::operator()<double>(1.0e+0), au::operator/<int>(1, au::seconds.au::QuantityMaker<au::Seconds>::operator()<double>(2.0e+0))}' 68 | }) { | ^ au/error_examples.cc:68:10: note: deduced conflicting types for parameter 'auto' ('au::Quantity<au::Hertz, double>' and 'au::Quantity<au::Pow<au::Seconds, -1>, double>') Broken strict total ordering \u00b6 Meaning: This means you performed an operation that needs to put unit types into a parameter pack \u2014 say, a common unit, or a unit product \u2014 but the library couldn\u2019t figure out how to order the units inside that pack. If that sounds obscure, it is: ordering units inside packs is a deep library implementation detail, and we try to avoid letting end users encounter this. To reach this error, you need two distinct units that have the same Dimension, Magnitude, and Origin. That\u2019s a necessary but not sufficient condition: for example, even UnitInverseT<Seconds> and Hertz won\u2019t trigger this! More background info on why this error exists In case you want to understand more, here is the gist. Au is heavily based on parameter packs . Some of these packs, such as UnitProduct<...> and CommonUnit<...> , take units as their arguments. Every parameter pack needs an unambiguous canonical ordering for any possible set of input arguments. Therefore, we need to create a strict total ordering for the (infinitely many!) unit types that could appear in these packs. This ordering needs to be known at compile time . The ordering itself doesn\u2019t matter so much, but if we don\u2019t strictly adhere to some ordering, it\u2019s undefined behaviour. Our strategy is to construct a \u201cgauntlet\u201d of properties which we can measure for any unit (e.g., Dimension, Magnitude, \u2026), and define some arbitrary ordering for each property. We then compare the units on each property in turn. The first one where they differ \u201cwins\u201d. If we get through all the properties, and they\u2019re still tied, then we have two distinct unit types which compare as equal. This would be undefined behaviour! Rather than silently ignoring this, we manifest this as a compiler error. That is what \u201cbroken strict total ordering\u201d means. Solution: If you have two distinct units, and the library can\u2019t figure out how to order them, you can force a particular ordering. Choose one of the units and give it a high \u201cunit avoidance\u201d score (see example below). This will break the tie. Again, this is pretty unusual. For most normal ways of forming units, the library should automatically be able to define an ordering for them. If you do hit this error, it may be worth pausing to double-check that you\u2019re using the library correctly. Tip If you hit this error, you might be annoyed by its obscurity. Instead, try feeling relieved! After all, the alternative is not \u201ccorrectly working program\u201d, but \u201csilent undefined behaviour\u201d. A compiler error with a searchable error message is infinitely preferable to the latter. Example Code Note that this example is somewhat convoluted, but again, that\u2019s to be expected because this error is pretty hard to hit in practice. Broken Fixed struct Quarterfeet : decltype ( Feet {} / mag < 4 > ()) {}; constexpr auto quarterfeet = QuantityMaker < Quarterfeet > {}; struct Trinches : decltype ( Inches {} * mag < 3 > ()) {}; constexpr auto trinches = QuantityMaker < Trinches > {}; // (BROKEN): Can't tell how to order Quarterfeet and Trinches when forming common type if ( quarterfeet ( 10 ) == trinches ( 10 )) { // ... } struct Quarterfeet : decltype ( Feet {} / mag < 4 > ()) {}; constexpr auto quarterfeet = QuantityMaker < Quarterfeet > {}; struct Trinches : decltype ( Inches {} * mag < 3 > ()) {}; constexpr auto trinches = QuantityMaker < Trinches > {}; namespace au { namespace detail { template <> struct UnitAvoidance <:: Trinches > : std :: integral_constant < int , 100 > {}; }} // (FIXED): Trinches has high \"unit avoidance\", so it goes after Quarterfeet if ( quarterfeet ( 10 ) == trinches ( 10 )) { // ... } Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: In file included from ./au/quantity.hh:7: In file included from ./au/conversion_policy.hh:7: In file included from ./au/magnitude.hh:7: ./au/packs.hh:276:5: error: static_assert failed due to requirement 'std::is_same<au::Quarterfeet, au::Trinches>::value' \"Broken strict total ordering: distinct input types compare equal\" static_assert(std::is_same<A, B>::value, ^ ~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>' requested here std::conditional_t< ^ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/unit_of_measure.hh:868:40: note: (skipping 8 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all) struct InOrderFor<UnitProduct, A, B> : LexicographicTotalOrdering<A, ^ ./au/quantity.hh:631:7: note: in instantiation of template class 'au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here : au::CommonQuantity<au::Quantity<U1, R1>, au::Quantity<U2, R2>> {}; ^ external/llvm_14_toolchain_llvm/bin/../include/c++/v1/type_traits:2388:25: note: in instantiation of template class 'std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:506:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, au::detail::Equal>' requested here return detail::using_common_type(q1, q2, detail::equal); ^ au/error_examples.cc:84:25: note: in instantiation of function template specialization 'au::operator==<au::Quarterfeet, au::Trinches, int, int>' requested here if (quarterfeet(10) == trinches(10)) { ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: In file included from ./au/quantity.hh:7: In file included from ./au/conversion_policy.hh:7: In file included from ./au/magnitude.hh:7: ./au/packs.hh:276:5: error: static_assert failed due to requirement 'std::is_same<au::Quarterfeet, au::Trinches>::value' \"Broken strict total ordering: distinct input types compare equal\" static_assert(std::is_same<A, B>::value, ^ ~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>' requested here std::conditional_t< ^ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByMag, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByDim, OrderByMag, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/unit_of_measure.hh:868:40: note: (skipping 8 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all) struct InOrderFor<UnitProduct, A, B> : LexicographicTotalOrdering<A, ^ ./au/quantity.hh:631:7: note: in instantiation of template class 'au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' requested here : au::CommonQuantity<au::Quantity<U1, R1>, au::Quantity<U2, R2>> {}; ^ external/llvm_11_toolchain_llvm/bin/../include/c++/v1/type_traits:2462:25: note: in instantiation of template class 'std::__1::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:506:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, au::detail::Equal>' requested here return detail::using_common_type(q1, q2, detail::equal); ^ au/error_examples.cc:84:25: note: in instantiation of function template specialization 'au::operator==<au::Quarterfeet, au::Trinches, int, int>' requested here if (quarterfeet(10) == trinches(10)) { ^ Compiler error (gcc 10) In file included from ./au/magnitude.hh:7, from ./au/conversion_policy.hh:7, from ./au/quantity.hh:7, from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/packs.hh: In instantiation of 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>': ./au/packs.hh:287:8: recursively required from 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/packs.hh:287:8: required from 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByUnitAvoidance, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/unit_of_measure.hh:868:8: required from 'struct au::InOrderFor<au::UnitProduct, au::Quarterfeet, au::Trinches>' ./au/unit_of_measure.hh:502:8: required from 'struct au::InOrderFor<au::CommonUnit, au::Quarterfeet, au::Trinches>' ./au/packs.hh:372:8: required from 'struct au::FlatDedupedTypeList<au::CommonUnit, au::CommonUnit<au::Quarterfeet>, au::CommonUnit<au::Trinches> >' ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/packs.hh:276:39: error: static assertion failed: Broken strict total ordering: distinct input types compare equal 276 | static_assert(std::is_same<A, B>::value, | ^~~~~ ./au/packs.hh: In instantiation of 'struct au::LexicographicTotalOrdering<au::Trinches, au::Quarterfeet>': ./au/packs.hh:287:8: required from 'struct au::LexicographicTotalOrdering<au::Trinches, au::Quarterfeet, au::detail::OrderByUnitAvoidance, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/unit_of_measure.hh:868:8: [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ] ./au/unit_of_measure.hh:452:8: required from 'struct au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/stdx/type_traits.hh:26:61: required from 'struct au::stdx::conjunction<au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>, au::detail::HasSameMagnitude<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches> >' ./au/unit_of_measure.hh:467:8: required from 'struct au::AreUnitsQuantityEquivalent<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/unit_of_measure.hh:529:8: required from 'struct au::detail::FirstMatchingUnit<au::AreUnitsQuantityEquivalent, au::CommonUnit<au::Trinches, au::Quarterfeet>, au::CommonUnit<au::Trinches, au::Quarterfeet> >' ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/packs.hh:276:39: error: static assertion failed: Broken strict total ordering: distinct input types compare equal In file included from ./au/conversion_policy.hh:10, from ./au/quantity.hh:7, from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/unit_of_measure.hh: In instantiation of 'struct au::CommonUnit<au::Trinches, au::Quarterfeet>': ./au/packs.hh:192:7: required by substitution of 'template<class U> using DimMemberT = typename U::Dim [with U = au::CommonUnit<au::Trinches, au::Quarterfeet>]' ./au/packs.hh:194:8: required from 'struct au::detail::DimImpl<au::CommonUnit<au::Trinches, au::Quarterfeet> >' ./au/unit_of_measure.hh:452:8: required from 'struct au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/stdx/type_traits.hh:26:61: required from 'struct au::stdx::conjunction<au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>, au::detail::HasSameMagnitude<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches> >' ./au/unit_of_measure.hh:467:8: [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ] ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/unit_of_measure.hh:492:70: error: static assertion failed: Elements must be listed in ascending order 492 | static_assert(AreElementsInOrder<CommonUnit, CommonUnit<Us...>>::value, | ^~~~~","title":"Troubleshooting Guide"},{"location":"troubleshooting/#troubleshooting-guide","text":"This page is a guide to the most commonly encountered types of error, what they mean, and how to fix them. The intended use case is to help you interpret an actual error in your code , at the point where you encounter it. To use this page, copy some relevant snippets from your compiler error, and then search the text of this page using your browser\u2019s Find function. Tip To improve your chances of finding what you\u2019re looking for, we include full compiler errors from both gcc and clang, inline with the text. Naturally, this makes this page very long, so it\u2019s not meant to be read straight through. Stick with your browser\u2019s Find function. Each section below lists one category of compiler error you might encounter when using the library. It explains what it means and how to solve it, and gives specific snippets of erroneous code, along with the compiler errors that each would yield.","title":"Troubleshooting Guide"},{"location":"troubleshooting/#private-constructor","text":"Meaning: This means you passed a raw numeric value to an interface that expected a Quantity. It\u2019s the \u201cclassic\u201d error the units library aims to prevent. Solution: Call the appropriate Quantity maker: instead of passing x , pass meters(x) , (kilo(meters) / hour)(x) , etc. A note on quantity makers vs. constructors Every other major units library lets you construct its Quantity types from raw numeric values; it just makes that constructor explicit. Au goes further, and makes this constructor private. The reason is to preserve unit safety at all callsites. We can\u2019t know whether you made an alias that doesn\u2019t name the unit. For example, if you want everybody to measure lengths in Meters in your codebase, you might provide a common alias like this: using Length = QuantityD < Meters > ; If you did, then end users could write the following: constexpr Length MAX_LENGTH { 5.5 }; // Unsafe! Units unclear. :( A core principle of the Au library is that the only way to enter or exit the library boundaries is to name the unit of measure, explicitly, at the callsite, like this: constexpr Length MAX_LENGTH = meters ( 5.5 ); // Usable! Units unambiguous. :) This enables users who want to use this kind of \u201cdimension-named alias\u201d in their codebase to do so safely. Example Code Broken Fixed void set_timeout ( QuantityD < Seconds > dt ); // A (BROKEN): passing raw number where duration expected. set_timeout ( 0.5 ); // B (BROKEN): calling Quantity constructor directly. constexpr QuantityD < Meters > length { 5.5 }; void set_timeout ( QuantityD < Seconds > dt ); // A (FIXED): name the unit. set_timeout ( seconds ( 0.5 )); // B (FIXED): calling Quantity constructor directly. constexpr QuantityD < Meters > length = meters ( 5.5 ); Compiler error (clang 14) au/error_examples.cc:19:17: error: calling a private constructor of class 'au::Quantity<au::Seconds, double>' set_timeout(0.5); ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ au/error_examples.cc:22:33: error: calling a private constructor of class 'au::Quantity<au::Meters, double>' constexpr QuantityD<Meters> length{5.5}; ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ Compiler error (clang 11) au/error_examples.cc:19:17: error: calling a private constructor of class 'au::Quantity<au::Seconds, double>' set_timeout(0.5); ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ au/error_examples.cc:22:33: error: calling a private constructor of class 'au::Quantity<au::Meters, double>' constexpr QuantityD<Meters> length{5.5}; ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ Compiler error (gcc 10) au/error_examples.cc: In function 'void au::example_private_constructor()': au/error_examples.cc:19:20: error: 'constexpr au::Quantity<UnitT, RepT>::Quantity(au::Quantity<UnitT, RepT>::Rep) [with UnitT = au::Seconds; RepT = double; au::Quantity<UnitT, RepT>::Rep = double]' is private within this context 19 | set_timeout(0.5); | ^ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh:369:15: note: declared private here 369 | constexpr Quantity(Rep value) : value_{value} {} | ^~~~~~~~ au/error_examples.cc:22:43: error: 'constexpr au::Quantity<UnitT, RepT>::Quantity(au::Quantity<UnitT, RepT>::Rep) [with UnitT = au::Meters; RepT = double; au::Quantity<UnitT, RepT>::Rep = double]' is private within this context 22 | constexpr QuantityD<Meters> length{5.5}; | ^ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh:369:15: note: declared private here 369 | constexpr Quantity(Rep value) : value_{value} {} | ^~~~~~~~","title":"Private constructor"},{"location":"troubleshooting/#dangerous-conversion","text":"Meaning: This is a physically meaningful conversion, but we think the risk of a grossly incorrect answer is too high, so we forbid it. There are two main sources for this risk, both having to do with integral storage types. Inexact conversion . Example: inches(24).as(feet) . Overflow . Example: giga(hertz)(1).as(hertz) . Both of these examples would in fact produce the correct answer with the specific values given ( 24 and 1 ). However, many (most!) other values would not. Thus, we disallow the entire conversion operation (at least in this format). Solution: There are different strategies to solve this, depending on your use case. Use floating point . As mentioned above, these risks only apply to integer values. If floating point is what you want anyway, just use it. giga(hertz)(1.0).as(hertz) produces hertz(1'000'000'000.0) . Use \u201cexplicit Rep\u201d form . The \u201cRep\u201d is the storage type for the Quantity. If you pass it as a template parameter, it is \u201cmorally equivalent\u201d to a static_cast , and has the same \u201cforcing\u201d semantics. inches(24).as<int>(feet) produces feet(2) . Warning Stop and think before using the explicit Rep version. If you\u2019re reviewing code that uses it, ask about it. The library is trying to protect you from an error prone operation. The mechanism exists because sometimes you can know that it\u2019s OK, but remember to stop and check first! Example Code Broken Fixed (1. Floating Point) Fixed (2. Explicit Rep) // A (BROKEN): inexact conversion. inches ( 24 ). as ( feet ); // B (BROKEN): overflow risk. giga ( hertz )( 1 ). as ( hertz ); // A (FIXED): 1. use floating point. inches ( 24.0 ). as ( feet ); // B (FIXED): 1. use floating point. giga ( hertz )( 1.0 ). as ( hertz ); // A (FIXED): 2. provide explicit Rep. inches ( 24 ). as < int > ( feet ); // B (FIXED): 2. provide explicit Rep. giga ( hertz )( 1 ). as < int > ( hertz ); Compiler error (clang 14) ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:30:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet>' requested here inches(24).as(feet); ^ In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:33:20: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz>' requested here giga(hertz)(1).as(hertz); ^ Compiler error (clang 11) ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:30:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet>' requested here inches(24).as(feet); ^ In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:33:20: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz>' requested here giga(hertz)(1).as(hertz); ^ Compiler error (gcc 10) ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::as(NewUnit) const [with NewUnit = au::Feet; <template-parameter-2-2> = void; UnitT = au::Inches; RepT = int]': ./au/quantity.hh:183:18: required from 'constexpr auto au::Quantity<UnitT, RepT>::as(au::QuantityMaker<NewUnit>) const [with NewUnit = au::Feet; UnitT = au::Inches; RepT = int]' au/error_examples.cc:30:23: required from here ./au/quantity.hh:147:72: error: static assertion failed: Dangerous conversion: use .as<Rep>(NewUnit) instead 147 | static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~ ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::as(NewUnit) const [with NewUnit = au::Hertz; <template-parameter-2-2> = void; UnitT = au::Giga<au::Hertz>; RepT = int]': ./au/quantity.hh:183:18: required from 'constexpr auto au::Quantity<UnitT, RepT>::as(au::QuantityMaker<NewUnit>) const [with NewUnit = au::Hertz; UnitT = au::Giga<au::Hertz>; RepT = int]' au/error_examples.cc:33:28: required from here ./au/quantity.hh:147:72: error: static assertion failed: Dangerous conversion: use .as<Rep>(NewUnit) instead","title":"Dangerous conversion"},{"location":"troubleshooting/#no-type-named-type-in-stdcommon_type","text":"Meaning: You probably tried to perform a \u201ccommon-unit operation\u201d (addition, subtraction, comparison) with two incompatible Quantities. Typically, this means they have different dimensions , which makes this an intrinsically meaningless operation. TODO Make a page which explains common-unit operations, and link to it. Solution: Figure out what dimension you expected them to have, and which value had the wrong dimension. Then, figure out how to fix your expression so it has the right dimension. Example Code Broken Fixed // (BROKEN): different dimensions. meters ( 1 ) + seconds ( 1 ); // (FIXED): fix coding mistake. meters ( 1 ) + seconds ( 1 ) * ( meters / second )( 10 ); Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:5: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/chrono:697: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/__chrono/calendar.h:13: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/__chrono/duration.h:14: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/limits:105: external/llvm_14_toolchain_llvm/bin/../include/c++/v1/type_traits:2388:25: error: no type named 'type' in 'std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>>' template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^~~~~ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:532:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>, au::detail::Plus>' requested here return detail::using_common_type(q1, q2, detail::plus); ^ au/error_examples.cc:41:15: note: in instantiation of function template specialization 'au::operator+<au::Meters, au::Seconds, int, int>' requested here meters(1) + seconds(1); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:5: In file included from external/llvm_11_toolchain_llvm/bin/../include/c++/v1/chrono:828: external/llvm_11_toolchain_llvm/bin/../include/c++/v1/type_traits:2462:25: error: no type named 'type' in 'std::__1::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>>' template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^~~~~ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:532:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>, au::detail::Plus>' requested here return detail::using_common_type(q1, q2, detail::plus); ^ au/error_examples.cc:41:15: note: in instantiation of function template specialization 'au::operator+<au::Meters, au::Seconds, int, int>' requested here meters(1) + seconds(1); ^ Compiler error (gcc 10) In file included from external/sysroot_x86_64//include/c++/10.3.0/ratio:39, from external/sysroot_x86_64//include/c++/10.3.0/chrono:39, from ./au/au.hh:5, from au/error_examples.cc:1: external/sysroot_x86_64//include/c++/10.3.0/type_traits: In substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>}]': ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Meters, int>; U = au::Quantity<au::Seconds, int>; Func = au::detail::Plus]' ./au/quantity.hh:532:37: required from 'constexpr auto au::operator+(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Meters; U2 = au::Seconds; R1 = int; R2 = int]' au/error_examples.cc:41:26: required from here external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: error: no type named 'type' in 'struct std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int> >' 2562 | using common_type_t = typename common_type<_Tp...>::type; | ^~~~~~~~~~~~~ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh: In instantiation of 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Meters, int>; U = au::Quantity<au::Seconds, int>; Func = au::detail::Plus]': ./au/quantity.hh:532:37: required from 'constexpr auto au::operator+(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Meters; U2 = au::Seconds; R1 = int; R2 = int]' au/error_examples.cc:41:26: required from here","title":"No type named 'type' in 'std::common_type'"},{"location":"troubleshooting/#integer-division-forbidden","text":"Meaning: Although Au generally tries to act just like the underlying raw numeric types, we also try to prevent wrong code that looks correct from compiling. It turns out to be just too easy to use integral Reps without noticing, and thus to get integer division without noticing. This can lead to very large errors. Solution: If you really wanted integer division, call integer_quotient() . Otherwise, use floating point types. Example Code How long does it take to travel 60 m at a speed of 65 MPH? Broken Fixed (1. Floating point) Fixed (2. integer_quotient() ) // (BROKEN): gives (60 / 65) == 0 before conversion! QuantityD < Seconds > t = meters ( 60 ) / ( miles / hour )( 65 ); // (FIXED): 1. Using floating point, we get ~= seconds(2.06486) QuantityD < Seconds > t = meters ( 60.0 ) / ( miles / hour )( 65.0 ); // (FIXED): 2. Integer result == (meter * hours / mile)(0) auto t = integer_quotient ( meters ( 60 ), ( miles / hour )( 65 )); Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:304:9: error: static_assert failed due to requirement '!uses_integer_division' \"Integer division forbidden: use integer_quotient() if you really want it\" static_assert(!uses_integer_division, ^ ~~~~~~~~~~~~~~~~~~~~~~ au/error_examples.cc:49:39: note: in instantiation of function template specialization 'au::Quantity<au::Meters, int>::operator/<au::UnitProduct<au::Miles, au::Pow<au::Hours, -1>>, int>' requested here QuantityD<Seconds> t = meters(60) / (miles / hour)(65); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:304:9: error: static_assert failed due to requirement '!uses_integer_division' \"Integer division forbidden: use integer_quotient() if you really want it\" static_assert(!uses_integer_division, ^ ~~~~~~~~~~~~~~~~~~~~~~ au/error_examples.cc:49:39: note: in instantiation of function template specialization 'au::Quantity<au::Meters, int>::operator/<au::UnitProduct<au::Miles, au::Pow<au::Hours, -1>>, int>' requested here QuantityD<Seconds> t = meters(60) / (miles / hour)(65); ^ Compiler error (gcc 10) ./au/quantity.hh:496:94: error: no type named 'type' in 'struct std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int> >' 496 | std::is_same<typename C::Rep, std::common_type_t<typename T::Rep, typename U::Rep>>::value, | ^~~~~ ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::operator/(au::Quantity<OtherUnit, OtherRep>) const [with OtherUnit = au::UnitProduct<au::Miles, au::Pow<au::Hours, -1> >; OtherRep = int; UnitT = au::Meters; RepT = int]': au/error_examples.cc:49:58: required from here ./au/quantity.hh:304:23: error: static assertion failed: Integer division forbidden: use integer_quotient() if you really want it 304 | static_assert(!uses_integer_division, | ^~~~~~~~~~~~~~~~~~~~~~","title":"Integer division forbidden"},{"location":"troubleshooting/#dangerous-inversion","text":"Meaning: This is analogous to our overflow safety surface. When computing the inverse of an integral quantity in a given target unit, there is some smallest value that will get truncated down to zero (a tremendous error!). If that value is \u201csmall enough to be scary\u201d (currently 1,000), we forbid the conversion. Solution: Consider using floating point; you\u2019ll always get a precise answer. Alternatively, use a smaller target unit. Example Code Broken Fixed (1. Floating point) Fixed (2. Smaller target unit) // (BROKEN): excessive truncation risk. inverse_as ( seconds , hertz ( 5 )); // (FIXED): 1. Floating point result ~= seconds(0.2) inverse_as ( seconds , hertz ( 5.0 )); // (FIXED): 2. Integer result == milli(seconds)(200) inverse_as ( milli ( seconds ), hertz ( 5 )); Note If you\u2019re really sure it\u2019s OK, you can use the explicit-Rep version of inverse_as , which is forcing like a static_cast . This is rarely the right choice, though. Consider: inverse_as < int > ( seconds , hertz ( 5 )); This yields seconds(0) , due to the gross truncation error which the check was designed to prevent in the first place. Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: ./au/math.hh:205:5: error: static_assert failed due to requirement 'make_quantity<au::UnitProduct<>>(int{1}).in(associated_unit(target_units) * au::Hertz{}) >= 1000 || std::is_floating_point<int>::value' \"Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\" static_assert( ^ ./au/math.hh:221:56: note: in instantiation of function template specialization 'au::inverse_in<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here return make_quantity<AssociatedUnitT<TargetUnits>>(inverse_in(target_units, q)); ^ au/error_examples.cc:57:5: note: in instantiation of function template specialization 'au::inverse_as<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here inverse_as(seconds, hertz(5)); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: ./au/math.hh:205:5: error: static_assert failed due to requirement 'make_quantity<au::UnitProduct<>>(int{1}).in(associated_unit(target_units) * au::Hertz{}) >= 1000 || std::is_floating_point<int>::value' \"Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\" static_assert( ^ ./au/math.hh:221:56: note: in instantiation of function template specialization 'au::inverse_in<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here return make_quantity<AssociatedUnitT<TargetUnits>>(inverse_in(target_units, q)); ^ au/error_examples.cc:57:5: note: in instantiation of function template specialization 'au::inverse_as<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here inverse_as(seconds, hertz(5)); ^ Compiler error (gcc 10) In file included from ./au/au.hh:7, from au/error_examples.cc:1: ./au/math.hh: In instantiation of 'constexpr auto au::inverse_in(TargetUnits, au::Quantity<Unit, Rep>) [with TargetUnits = au::QuantityMaker<au::Seconds>; U = au::Hertz; R = int]': ./au/math.hh:221:66: required from 'constexpr auto au::inverse_as(TargetUnits, au::Quantity<Unit, Rep>) [with TargetUnits = au::QuantityMaker<au::Seconds>; U = au::Hertz; R = int]' au/error_examples.cc:57:33: required from here ./au/math.hh:206:93: error: static assertion failed: Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired 206 | make_quantity<UnitProductT<>>(R{1}).in(associated_unit(target_units) * U{}) >= 1000 || | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~ 207 | std::is_floating_point<R>::value, | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","title":"Dangerous inversion"},{"location":"troubleshooting/#deduced-conflicting-types","text":"Meaning: In some contexts, it\u2019s not enough to have Quantity types that can easily convert to each other. (Common examples include the ternary operator ?: , and initializer lists.) You need types that are identical, or very nearly so. Even fully quantity-equivalent types, such as \\text{Hz} \\text{Hz} and \\text{s}^{-1} \\text{s}^{-1} , often won\u2019t work in these contexts! Solution: You can always cast non-conforming instances to your favored unit, using .as() . For the initializer list case, you can also make an explicit container, which will handle the casting automatically when possible. Example Code Broken Fixed (1. Cast to explicit unit) Fixed (2. Use explicit container) // (BROKEN): Initializer list confused by Hz and s^(-1). for ( const auto & frequency : { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )), }) { // ... } // (FIXED): 1. Cast individual elements to desired unit. for ( const auto & frequency : { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )). as ( hertz ), }) { // ... } // (FIXED): 2. Use container with explicit type. for ( const auto & frequency : std :: vector < QuantityD < Hertz >> { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )), }) { // ... } Compiler error (clang 14) au/error_examples.cc:65:34: error: deduced conflicting types ('Quantity<au::QuantityMaker<au::Hertz>::Unit, [...]>' vs 'Quantity<au::QuantityMaker<au::Pow<au::Seconds, -1>>::Unit, [...]>') for initializer list element type for (const auto &frequency : { ^ Compiler error (clang 11) au/error_examples.cc:65:34: error: deduced conflicting types ('Quantity<au::Hertz, [...]>' vs 'Quantity<au::Pow<au::Seconds, -1>, [...]>') for initializer list element type for (const auto &frequency : { ^ Compiler error (gcc 10) au/error_examples.cc: In function 'void au::example_deduced_conflicting_types()': au/error_examples.cc:68:10: error: unable to deduce 'std::initializer_list<auto>&&' from '{au::hertz.au::QuantityMaker<au::Hertz>::operator()<double>(1.0e+0), au::operator/<int>(1, au::seconds.au::QuantityMaker<au::Seconds>::operator()<double>(2.0e+0))}' 68 | }) { | ^ au/error_examples.cc:68:10: note: deduced conflicting types for parameter 'auto' ('au::Quantity<au::Hertz, double>' and 'au::Quantity<au::Pow<au::Seconds, -1>, double>')","title":"Deduced conflicting types"},{"location":"troubleshooting/#broken-strict-total-ordering","text":"Meaning: This means you performed an operation that needs to put unit types into a parameter pack \u2014 say, a common unit, or a unit product \u2014 but the library couldn\u2019t figure out how to order the units inside that pack. If that sounds obscure, it is: ordering units inside packs is a deep library implementation detail, and we try to avoid letting end users encounter this. To reach this error, you need two distinct units that have the same Dimension, Magnitude, and Origin. That\u2019s a necessary but not sufficient condition: for example, even UnitInverseT<Seconds> and Hertz won\u2019t trigger this! More background info on why this error exists In case you want to understand more, here is the gist. Au is heavily based on parameter packs . Some of these packs, such as UnitProduct<...> and CommonUnit<...> , take units as their arguments. Every parameter pack needs an unambiguous canonical ordering for any possible set of input arguments. Therefore, we need to create a strict total ordering for the (infinitely many!) unit types that could appear in these packs. This ordering needs to be known at compile time . The ordering itself doesn\u2019t matter so much, but if we don\u2019t strictly adhere to some ordering, it\u2019s undefined behaviour. Our strategy is to construct a \u201cgauntlet\u201d of properties which we can measure for any unit (e.g., Dimension, Magnitude, \u2026), and define some arbitrary ordering for each property. We then compare the units on each property in turn. The first one where they differ \u201cwins\u201d. If we get through all the properties, and they\u2019re still tied, then we have two distinct unit types which compare as equal. This would be undefined behaviour! Rather than silently ignoring this, we manifest this as a compiler error. That is what \u201cbroken strict total ordering\u201d means. Solution: If you have two distinct units, and the library can\u2019t figure out how to order them, you can force a particular ordering. Choose one of the units and give it a high \u201cunit avoidance\u201d score (see example below). This will break the tie. Again, this is pretty unusual. For most normal ways of forming units, the library should automatically be able to define an ordering for them. If you do hit this error, it may be worth pausing to double-check that you\u2019re using the library correctly. Tip If you hit this error, you might be annoyed by its obscurity. Instead, try feeling relieved! After all, the alternative is not \u201ccorrectly working program\u201d, but \u201csilent undefined behaviour\u201d. A compiler error with a searchable error message is infinitely preferable to the latter. Example Code Note that this example is somewhat convoluted, but again, that\u2019s to be expected because this error is pretty hard to hit in practice. Broken Fixed struct Quarterfeet : decltype ( Feet {} / mag < 4 > ()) {}; constexpr auto quarterfeet = QuantityMaker < Quarterfeet > {}; struct Trinches : decltype ( Inches {} * mag < 3 > ()) {}; constexpr auto trinches = QuantityMaker < Trinches > {}; // (BROKEN): Can't tell how to order Quarterfeet and Trinches when forming common type if ( quarterfeet ( 10 ) == trinches ( 10 )) { // ... } struct Quarterfeet : decltype ( Feet {} / mag < 4 > ()) {}; constexpr auto quarterfeet = QuantityMaker < Quarterfeet > {}; struct Trinches : decltype ( Inches {} * mag < 3 > ()) {}; constexpr auto trinches = QuantityMaker < Trinches > {}; namespace au { namespace detail { template <> struct UnitAvoidance <:: Trinches > : std :: integral_constant < int , 100 > {}; }} // (FIXED): Trinches has high \"unit avoidance\", so it goes after Quarterfeet if ( quarterfeet ( 10 ) == trinches ( 10 )) { // ... } Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: In file included from ./au/quantity.hh:7: In file included from ./au/conversion_policy.hh:7: In file included from ./au/magnitude.hh:7: ./au/packs.hh:276:5: error: static_assert failed due to requirement 'std::is_same<au::Quarterfeet, au::Trinches>::value' \"Broken strict total ordering: distinct input types compare equal\" static_assert(std::is_same<A, B>::value, ^ ~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>' requested here std::conditional_t< ^ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/unit_of_measure.hh:868:40: note: (skipping 8 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all) struct InOrderFor<UnitProduct, A, B> : LexicographicTotalOrdering<A, ^ ./au/quantity.hh:631:7: note: in instantiation of template class 'au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here : au::CommonQuantity<au::Quantity<U1, R1>, au::Quantity<U2, R2>> {}; ^ external/llvm_14_toolchain_llvm/bin/../include/c++/v1/type_traits:2388:25: note: in instantiation of template class 'std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:506:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, au::detail::Equal>' requested here return detail::using_common_type(q1, q2, detail::equal); ^ au/error_examples.cc:84:25: note: in instantiation of function template specialization 'au::operator==<au::Quarterfeet, au::Trinches, int, int>' requested here if (quarterfeet(10) == trinches(10)) { ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: In file included from ./au/quantity.hh:7: In file included from ./au/conversion_policy.hh:7: In file included from ./au/magnitude.hh:7: ./au/packs.hh:276:5: error: static_assert failed due to requirement 'std::is_same<au::Quarterfeet, au::Trinches>::value' \"Broken strict total ordering: distinct input types compare equal\" static_assert(std::is_same<A, B>::value, ^ ~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>' requested here std::conditional_t< ^ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByMag, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByDim, OrderByMag, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/unit_of_measure.hh:868:40: note: (skipping 8 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all) struct InOrderFor<UnitProduct, A, B> : LexicographicTotalOrdering<A, ^ ./au/quantity.hh:631:7: note: in instantiation of template class 'au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' requested here : au::CommonQuantity<au::Quantity<U1, R1>, au::Quantity<U2, R2>> {}; ^ external/llvm_11_toolchain_llvm/bin/../include/c++/v1/type_traits:2462:25: note: in instantiation of template class 'std::__1::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:506:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, au::detail::Equal>' requested here return detail::using_common_type(q1, q2, detail::equal); ^ au/error_examples.cc:84:25: note: in instantiation of function template specialization 'au::operator==<au::Quarterfeet, au::Trinches, int, int>' requested here if (quarterfeet(10) == trinches(10)) { ^ Compiler error (gcc 10) In file included from ./au/magnitude.hh:7, from ./au/conversion_policy.hh:7, from ./au/quantity.hh:7, from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/packs.hh: In instantiation of 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>': ./au/packs.hh:287:8: recursively required from 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/packs.hh:287:8: required from 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByUnitAvoidance, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/unit_of_measure.hh:868:8: required from 'struct au::InOrderFor<au::UnitProduct, au::Quarterfeet, au::Trinches>' ./au/unit_of_measure.hh:502:8: required from 'struct au::InOrderFor<au::CommonUnit, au::Quarterfeet, au::Trinches>' ./au/packs.hh:372:8: required from 'struct au::FlatDedupedTypeList<au::CommonUnit, au::CommonUnit<au::Quarterfeet>, au::CommonUnit<au::Trinches> >' ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/packs.hh:276:39: error: static assertion failed: Broken strict total ordering: distinct input types compare equal 276 | static_assert(std::is_same<A, B>::value, | ^~~~~ ./au/packs.hh: In instantiation of 'struct au::LexicographicTotalOrdering<au::Trinches, au::Quarterfeet>': ./au/packs.hh:287:8: required from 'struct au::LexicographicTotalOrdering<au::Trinches, au::Quarterfeet, au::detail::OrderByUnitAvoidance, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/unit_of_measure.hh:868:8: [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ] ./au/unit_of_measure.hh:452:8: required from 'struct au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/stdx/type_traits.hh:26:61: required from 'struct au::stdx::conjunction<au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>, au::detail::HasSameMagnitude<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches> >' ./au/unit_of_measure.hh:467:8: required from 'struct au::AreUnitsQuantityEquivalent<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/unit_of_measure.hh:529:8: required from 'struct au::detail::FirstMatchingUnit<au::AreUnitsQuantityEquivalent, au::CommonUnit<au::Trinches, au::Quarterfeet>, au::CommonUnit<au::Trinches, au::Quarterfeet> >' ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/packs.hh:276:39: error: static assertion failed: Broken strict total ordering: distinct input types compare equal In file included from ./au/conversion_policy.hh:10, from ./au/quantity.hh:7, from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/unit_of_measure.hh: In instantiation of 'struct au::CommonUnit<au::Trinches, au::Quarterfeet>': ./au/packs.hh:192:7: required by substitution of 'template<class U> using DimMemberT = typename U::Dim [with U = au::CommonUnit<au::Trinches, au::Quarterfeet>]' ./au/packs.hh:194:8: required from 'struct au::detail::DimImpl<au::CommonUnit<au::Trinches, au::Quarterfeet> >' ./au/unit_of_measure.hh:452:8: required from 'struct au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/stdx/type_traits.hh:26:61: required from 'struct au::stdx::conjunction<au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>, au::detail::HasSameMagnitude<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches> >' ./au/unit_of_measure.hh:467:8: [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ] ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/unit_of_measure.hh:492:70: error: static assertion failed: Elements must be listed in ascending order 492 | static_assert(AreElementsInOrder<CommonUnit, CommonUnit<Us...>>::value, | ^~~~~","title":"Broken strict total ordering"},{"location":"alternatives/","text":"Comparison of Alternatives \u00b6 There are plenty of other open source C++ units libraries, many quite well established. However, the tradeoffs required to use these libraries can be so significant that many people can\u2019t or won\u2019t use them. For example: the compiler errors may be inscrutable or overwhelming; the compilation process may become unacceptably slow; or, the required C++ standard may simply be too new for a user. Au is an accessible, production-tested alternative. We provide a number of rare or outright novel features, with a small compile time footprint \u2014 and we\u2019re compatible with every C++ version back to the mature and widely available C++14 standard. Key features include: Fully unit-safe APIs, on both entry and exit. The \u201csafety surface\u201d: conversions that adapt to the overflow risk based on both conversion magnitude, and storage type. Highly composable \u201cquantity maker\u201d APIs make it easy to both compose new units, and apply unit prefixes, on the fly. Human-readable and concise compiler errors, via strong typenames for units. The Zero type: novel, fluent handling of construction, comparison, and sign handling for quantities. Ease of migration (both to and from Au): with minimal setup, we support bidirectional implicit conversions with equivalent types from any other units library. Support for single-header-file delivery, but with easy customization of units and features to include. Proven track record supporting embedded applications as first class citizens, via such features as our safe handling of integer Rep, treating all Reps on equal footing, and our easy ability to exclude expensive <iostream> support. Intelligent, unit-aware functions for rounding and computing inverses. Minimal friction by using a single, short namespace: everything\u2019s in au:: . Detailed comparison matrices \u00b6 Here\u2019s a more detailed comparison to the most prominent alternatives. We\u2019ll use the following legend 1 : td.na::before { content: \"(Not assessed)\"; } th.highlight { background-color: #ccc; } span.criterion { font-weight: bold; } .md-typeset details.criterion summary { padding-left: 0.5rem; } li.check, li.x { list-style: none; margin-left: 0; text-indent: -2ch; } li.check:before { content: \"\\2713 \"; } li.x:before { content: \"\\2717 \"; } details.criterion > summary::before { display: none; } Legend Lacks feature / poor support Fair / basic support Good / solid support Best support (of libraries considered here) Obtaining the library \u00b6 These are the first criteria to consider. They will tell you whether you can even use the library at all, and if so, how hard it will be to obtain. Boost nholthaus mp-units Au C++ Version Compatibility The minimum C++ standard required to use the library. C++98 or C++03 (unclear which, but best in either case) C++14 C++20 C++14 Ease of Acquisition Ease of including this library in projects using a wide variety of build environments Part of boost Single, self-contained header First class conan support; available on vcpkg Supports single-header delivery, with features: Easy to customize units and I/O support Version-stamped for full reproducibility Note These ratings are written with all users and projects in mind. Keep in mind that what matters for you is your project. For example: mp-units gets low accessibility ratings because of its steep C++20 minimum requirement, and its dependence on a package manager to make the installation easy. However, if your project is already compatible with C++20, and already uses conan, then these \u201clow\u201d ratings would be completely irrelevant for you. Generic developer experience \u00b6 Next: how will this library change the generic developer experience? Leaving aside any library features, conventions, or implementation strategies, there are two main impacts to developer experience. Your program will take longer to compile , because the compiler is doing more work to produce essentially the same program. You will get more compiler errors that developers will need to understand and fix. These costs can bring significant benefits, but we still want them to be as small as possible. Boost nholthaus mp-units Au Compilation Speed The extra time the library adds to compiling a translation unit, compared to no units library. Poor: typically adds several seconds per translation unit Fair: enough that end users tend to notice Good: not \"subjectively noticeable\" Very slow, but can be greatly improved by removing I/O support and most units Possibly \"best\", but will need to assess all libraries on the same code Compiler Error Readability The ability to understand errors when the library catches a mistake it was designed to catch. Poor: Excessively long, nested types Fair: Short, but dimension names lacking Good: Brief typenames with user-facing unit names Infamously challenging Positional dimensions Pioneered strong typedefs for units No dimension in type name leads to shorter types Detailed troubleshooting guide Library features \u00b6 At this point, you\u2019ve assessed: whether you can use each library at all; how hard it will be to add to your project; and, what costs you\u2019ll pay in developer experience if you do. Now we\u2019re ready to compare the libraries \u201cas units libraries\u201d \u2014 that is, in terms of their core features. Boost nholthaus mp-units Au Conversion Safety Guarding against unit conversions that are likely to produce large errors. (For example: we can convert an integer number of feet to inches, but not vice versa.) Integer Reps unsafe Policy consistent with std::chrono library Automatically adapts to level of overflow risk Unit Safety The ability to judge the unit-correctness of every individual line of code by inspection, in isolation. Fair: can achieve indirectly, by casting to known type before retrieving value. Good: provide unit-safe interfaces. Only contains unit-safe interfaces Low Friction How easy it is to develop with the library. Criteria include: Headers: few, or easily guessable Simple namespace structure Reasonable, safe implicit conversions Single file is very easy User-friendly API typenames ( meter_t , ...) Namespaces add verbosity, and friction (for example, math:: namespace prevents ADL ) Namespaces: just one, and it's short Includes: either single-header, or easily-guessable header per unit Composability The ability to fluently combine the abstractions for units and prefixes to form new units on the fly. Prefix only No Quantity References compose; prefixes don't QuantityMaker and PrefixApplier APIs Mixed-Rep Support The ease of freely mixing different storage types (\"Reps\") in the same program. Possible, but user-facing types use a global \"preferred\" Rep. Generic Dimensions The ability to write (template) functions that operate on any dimensionally consistent inputs. (For example, a function that takes any length and time quantities, and returns the appropriate speed quantity.) Generic templates, constrained with traits Generic templates, constrained with traits Concepts excel here Currently clunky. Could be better by adding concepts in extra C++20-only file, without compromising C++14 support. Extensibility How easy it is to add new units, dimensions, or systems. Can add new units and dimensions One-line macro defines new units Can't add dimensions Can even handle, e.g., systems of \"natural\" units Can add new units and dimensions Ease of Migration Support for two migration use cases: From \"no units\" to this library Between this library and another units library (either direction) No interop with other units libraries No interop with other units libraries quantity_like_traits \"Equivalent types\" feature gives more API compatibility Point Types Support for \"point-like\" quantities, also known as \"affine space types\" . absolute wrapper for unit Optional \"offset\" for units, but can't distinguish quantity from point . Magnitudes The features of the representation for different units' sizes. Key features include: Irrational numbers (such as \\(\\pi\\)) Powers (robust against overflow) Roots (exact representations) Close: lacks only irrationals, basis, and instance arithmetic. Ahead of its time! Uses ratio plus \"pi powers\": good angle handling, but vulnerable to overflow Full support for Magnitudes Formerly, Au alone was best, but we shared Magnitudes with mp-units Embedded Friendliness Support common embedded use cases. Key examples include: Flexibility in the Rep (usually a variety of integral types, and perhaps float , but rarely double ). The easy ability to exclude <iostreams> . Assumed to be good, based on mixed-Rep support Can trim by excluding <iostream> , but integer-Rep support is poor. Assumed to be good, based on mixed-Rep support Best choice of all: No \"preferred\" Rep. Safe integer operations. User-defined literals (UDLs) Concise expressions such as `3_m` for \"3 meters\", or some comparable alternative. Flexibility in the Rep (usually a variety of integral types, and perhaps float , but rarely double ). The easy ability to exclude <iostreams> . UDLs UDLs and Quantity References Planned to add: #43 Rep Variety The range of different storage types (\"Reps\") permitted. Poor: only 1 or 2 types Fair: all built-in numeric types Good: also support custom numeric types Supports custom numeric types Effectively floating-point only (integer types unsafe ) Well defined Representation concept Rep can only be is_arithmetic for now, but plan to upgrade Zero Quantity support for constructing from, and comparing with, 0 : the only number which is meaningful for every unit. (Includes facilities for working with quantity signs.) Guidance: use default constructor to construct, but no special facility for comparison Supports copysign() , but no special construction or comparison Has q::zero() member, but no special construction or comparison Can use ZERO to construct or compare any quantity Angles First-class support for angular quantities, including degrees and radians. Curiously imprecise pi value Non-linear scales (such as dB) Support for logarithmic \"units\", such as decibels or nepers Plan to support someday; see #41 . \"Kind\" Types Support for distinguishing different \"kinds\" of the same dimension, such as a length from a width. No plans to support. Explicit Systems of Measurement Support for different systems, each with their own (possibly incompatible) collection of dimensions. Single, implicit global system Single, implicit global system. (Intentional design tradeoff: reduces learning curve, and makes compiler errors shorter.) Units as types Types that represent abstract units (clearly distinct from quantities of that unit). Types exist, but conflated with quantity names Can form instances and do arithmetic Macro Usage Avoidance of macros, especially in user-facing code. Present in user-facing APIs Present in user-facing APIs Confined to outer compatibility layer No macros Users may have expected a \u201ctraffic light\u201d style, green/yellow/red color scheme. However, these traditional color schemes have poor accessibility for colorblind readers. The present color scheme was designed to be colorblind-friendly. \u21a9","title":"Comparison of Alternatives"},{"location":"alternatives/#comparison-of-alternatives","text":"There are plenty of other open source C++ units libraries, many quite well established. However, the tradeoffs required to use these libraries can be so significant that many people can\u2019t or won\u2019t use them. For example: the compiler errors may be inscrutable or overwhelming; the compilation process may become unacceptably slow; or, the required C++ standard may simply be too new for a user. Au is an accessible, production-tested alternative. We provide a number of rare or outright novel features, with a small compile time footprint \u2014 and we\u2019re compatible with every C++ version back to the mature and widely available C++14 standard. Key features include: Fully unit-safe APIs, on both entry and exit. The \u201csafety surface\u201d: conversions that adapt to the overflow risk based on both conversion magnitude, and storage type. Highly composable \u201cquantity maker\u201d APIs make it easy to both compose new units, and apply unit prefixes, on the fly. Human-readable and concise compiler errors, via strong typenames for units. The Zero type: novel, fluent handling of construction, comparison, and sign handling for quantities. Ease of migration (both to and from Au): with minimal setup, we support bidirectional implicit conversions with equivalent types from any other units library. Support for single-header-file delivery, but with easy customization of units and features to include. Proven track record supporting embedded applications as first class citizens, via such features as our safe handling of integer Rep, treating all Reps on equal footing, and our easy ability to exclude expensive <iostream> support. Intelligent, unit-aware functions for rounding and computing inverses. Minimal friction by using a single, short namespace: everything\u2019s in au:: .","title":"Comparison of Alternatives"},{"location":"alternatives/#detailed-comparison-matrices","text":"Here\u2019s a more detailed comparison to the most prominent alternatives. We\u2019ll use the following legend 1 : td.na::before { content: \"(Not assessed)\"; } th.highlight { background-color: #ccc; } span.criterion { font-weight: bold; } .md-typeset details.criterion summary { padding-left: 0.5rem; } li.check, li.x { list-style: none; margin-left: 0; text-indent: -2ch; } li.check:before { content: \"\\2713 \"; } li.x:before { content: \"\\2717 \"; } details.criterion > summary::before { display: none; } Legend Lacks feature / poor support Fair / basic support Good / solid support Best support (of libraries considered here)","title":"Detailed comparison matrices"},{"location":"alternatives/#obtaining-the-library","text":"These are the first criteria to consider. They will tell you whether you can even use the library at all, and if so, how hard it will be to obtain. Boost nholthaus mp-units Au C++ Version Compatibility The minimum C++ standard required to use the library. C++98 or C++03 (unclear which, but best in either case) C++14 C++20 C++14 Ease of Acquisition Ease of including this library in projects using a wide variety of build environments Part of boost Single, self-contained header First class conan support; available on vcpkg Supports single-header delivery, with features: Easy to customize units and I/O support Version-stamped for full reproducibility Note These ratings are written with all users and projects in mind. Keep in mind that what matters for you is your project. For example: mp-units gets low accessibility ratings because of its steep C++20 minimum requirement, and its dependence on a package manager to make the installation easy. However, if your project is already compatible with C++20, and already uses conan, then these \u201clow\u201d ratings would be completely irrelevant for you.","title":"Obtaining the library"},{"location":"alternatives/#generic-developer-experience","text":"Next: how will this library change the generic developer experience? Leaving aside any library features, conventions, or implementation strategies, there are two main impacts to developer experience. Your program will take longer to compile , because the compiler is doing more work to produce essentially the same program. You will get more compiler errors that developers will need to understand and fix. These costs can bring significant benefits, but we still want them to be as small as possible. Boost nholthaus mp-units Au Compilation Speed The extra time the library adds to compiling a translation unit, compared to no units library. Poor: typically adds several seconds per translation unit Fair: enough that end users tend to notice Good: not \"subjectively noticeable\" Very slow, but can be greatly improved by removing I/O support and most units Possibly \"best\", but will need to assess all libraries on the same code Compiler Error Readability The ability to understand errors when the library catches a mistake it was designed to catch. Poor: Excessively long, nested types Fair: Short, but dimension names lacking Good: Brief typenames with user-facing unit names Infamously challenging Positional dimensions Pioneered strong typedefs for units No dimension in type name leads to shorter types Detailed troubleshooting guide","title":"Generic developer experience"},{"location":"alternatives/#library-features","text":"At this point, you\u2019ve assessed: whether you can use each library at all; how hard it will be to add to your project; and, what costs you\u2019ll pay in developer experience if you do. Now we\u2019re ready to compare the libraries \u201cas units libraries\u201d \u2014 that is, in terms of their core features. Boost nholthaus mp-units Au Conversion Safety Guarding against unit conversions that are likely to produce large errors. (For example: we can convert an integer number of feet to inches, but not vice versa.) Integer Reps unsafe Policy consistent with std::chrono library Automatically adapts to level of overflow risk Unit Safety The ability to judge the unit-correctness of every individual line of code by inspection, in isolation. Fair: can achieve indirectly, by casting to known type before retrieving value. Good: provide unit-safe interfaces. Only contains unit-safe interfaces Low Friction How easy it is to develop with the library. Criteria include: Headers: few, or easily guessable Simple namespace structure Reasonable, safe implicit conversions Single file is very easy User-friendly API typenames ( meter_t , ...) Namespaces add verbosity, and friction (for example, math:: namespace prevents ADL ) Namespaces: just one, and it's short Includes: either single-header, or easily-guessable header per unit Composability The ability to fluently combine the abstractions for units and prefixes to form new units on the fly. Prefix only No Quantity References compose; prefixes don't QuantityMaker and PrefixApplier APIs Mixed-Rep Support The ease of freely mixing different storage types (\"Reps\") in the same program. Possible, but user-facing types use a global \"preferred\" Rep. Generic Dimensions The ability to write (template) functions that operate on any dimensionally consistent inputs. (For example, a function that takes any length and time quantities, and returns the appropriate speed quantity.) Generic templates, constrained with traits Generic templates, constrained with traits Concepts excel here Currently clunky. Could be better by adding concepts in extra C++20-only file, without compromising C++14 support. Extensibility How easy it is to add new units, dimensions, or systems. Can add new units and dimensions One-line macro defines new units Can't add dimensions Can even handle, e.g., systems of \"natural\" units Can add new units and dimensions Ease of Migration Support for two migration use cases: From \"no units\" to this library Between this library and another units library (either direction) No interop with other units libraries No interop with other units libraries quantity_like_traits \"Equivalent types\" feature gives more API compatibility Point Types Support for \"point-like\" quantities, also known as \"affine space types\" . absolute wrapper for unit Optional \"offset\" for units, but can't distinguish quantity from point . Magnitudes The features of the representation for different units' sizes. Key features include: Irrational numbers (such as \\(\\pi\\)) Powers (robust against overflow) Roots (exact representations) Close: lacks only irrationals, basis, and instance arithmetic. Ahead of its time! Uses ratio plus \"pi powers\": good angle handling, but vulnerable to overflow Full support for Magnitudes Formerly, Au alone was best, but we shared Magnitudes with mp-units Embedded Friendliness Support common embedded use cases. Key examples include: Flexibility in the Rep (usually a variety of integral types, and perhaps float , but rarely double ). The easy ability to exclude <iostreams> . Assumed to be good, based on mixed-Rep support Can trim by excluding <iostream> , but integer-Rep support is poor. Assumed to be good, based on mixed-Rep support Best choice of all: No \"preferred\" Rep. Safe integer operations. User-defined literals (UDLs) Concise expressions such as `3_m` for \"3 meters\", or some comparable alternative. Flexibility in the Rep (usually a variety of integral types, and perhaps float , but rarely double ). The easy ability to exclude <iostreams> . UDLs UDLs and Quantity References Planned to add: #43 Rep Variety The range of different storage types (\"Reps\") permitted. Poor: only 1 or 2 types Fair: all built-in numeric types Good: also support custom numeric types Supports custom numeric types Effectively floating-point only (integer types unsafe ) Well defined Representation concept Rep can only be is_arithmetic for now, but plan to upgrade Zero Quantity support for constructing from, and comparing with, 0 : the only number which is meaningful for every unit. (Includes facilities for working with quantity signs.) Guidance: use default constructor to construct, but no special facility for comparison Supports copysign() , but no special construction or comparison Has q::zero() member, but no special construction or comparison Can use ZERO to construct or compare any quantity Angles First-class support for angular quantities, including degrees and radians. Curiously imprecise pi value Non-linear scales (such as dB) Support for logarithmic \"units\", such as decibels or nepers Plan to support someday; see #41 . \"Kind\" Types Support for distinguishing different \"kinds\" of the same dimension, such as a length from a width. No plans to support. Explicit Systems of Measurement Support for different systems, each with their own (possibly incompatible) collection of dimensions. Single, implicit global system Single, implicit global system. (Intentional design tradeoff: reduces learning curve, and makes compiler errors shorter.) Units as types Types that represent abstract units (clearly distinct from quantities of that unit). Types exist, but conflated with quantity names Can form instances and do arithmetic Macro Usage Avoidance of macros, especially in user-facing code. Present in user-facing APIs Present in user-facing APIs Confined to outer compatibility layer No macros Users may have expected a \u201ctraffic light\u201d style, green/yellow/red color scheme. However, these traditional color schemes have poor accessibility for colorblind readers. The present color scheme was designed to be colorblind-friendly. \u21a9","title":"Library features"},{"location":"discussion/","text":"Discussion Docs \u00b6 This section is for docs that illuminate Au\u2019s underpinnings. The kinds of docs that go here include philosophy and principles, deep dives on design choices, explanations of core concepts, and more. In terms of the four categories of documentation \u2014 which we try to follow \u2014 this is also known as \u201c explanation \u201d. It\u2019s most useful when you\u2019re studying , rather than working, and it focuses on theoretical rather than practical knowledge. Here\u2019s a guide to the main categories. Implementation details . Concepts and design discussions that help you understand how we made Au.","title":"Discussion Docs"},{"location":"discussion/#discussion-docs","text":"This section is for docs that illuminate Au\u2019s underpinnings. The kinds of docs that go here include philosophy and principles, deep dives on design choices, explanations of core concepts, and more. In terms of the four categories of documentation \u2014 which we try to follow \u2014 this is also known as \u201c explanation \u201d. It\u2019s most useful when you\u2019re studying , rather than working, and it focuses on theoretical rather than practical knowledge. Here\u2019s a guide to the main categories. Implementation details . Concepts and design discussions that help you understand how we made Au.","title":"Discussion Docs"},{"location":"discussion/implementation/","text":"Implementation Details \u00b6 This section provides in-depth discussion about core implementation details of Au. If you want to understand how the library works, this is a good place to go. Here\u2019s a rough guide. Vector Space Representations . We\u2019re not talking about position vectors or velocity vectors! There\u2019s a different kind of vector at the heart of every units library. This is the core foundational concept on which we built Au\u2019s implementation.","title":"Implementation Details"},{"location":"discussion/implementation/#implementation-details","text":"This section provides in-depth discussion about core implementation details of Au. If you want to understand how the library works, this is a good place to go. Here\u2019s a rough guide. Vector Space Representations . We\u2019re not talking about position vectors or velocity vectors! There\u2019s a different kind of vector at the heart of every units library. This is the core foundational concept on which we built Au\u2019s implementation.","title":"Implementation Details"},{"location":"discussion/implementation/vector_space/","text":"Vector Space Representations \u00b6 To understand why vector space representations are so important for units libraries, we\u2019ll dig into the most fundamental example. After that, we\u2019ll look at some other instances of vector space representations in our library. Consider Dimensions . How can we teach the library to recognize that, say, the product of the Dimensions Speed and Time is the Dimension Length ? If these three Dimensions are all primitive, irreducible objects, this is very challenging. However, if Speed is just an alias for (Length / Time) , then it\u2019s easy to see that (Length / Time) * Time reduces to Length . This is what we do: we single out certain Dimensions and call them \u201cBase Dimensions\u201d. Any valid choice must fulfill these conditions: Independence: no product of rational powers of Base Dimensions is dimensionless , unless all exponents are 0. Completeness: every Dimension of interest can be represented as some product of rational powers of Base Dimensions. The reader may recognize these properties of Base Dimensions as analogous to the defining properties of Basis Vectors in a vector space, but with these differences: instead of adding vectors, we multiply Base Dimensions instead of multiplying vectors by a scalar, we raise them to a power In fact, we can bridge this gap if we consider the exponents of the dimensions to be the scalars of the vector space. In a sense, the \u201clogarithms\u201d of the dimensions form a vector space; in this case, over the rationals. This is the \u201cvector space representation\u201d for Dimensions. Fleshing out the analogy \u00b6 How do the defining properties of vector spaces manifest themselves here? Let the space of all Dimensions be \\mathscr{D} \\mathscr{D} . For any dimensions D, D_1, D_2, D_3 \\in \\mathscr{D} D, D_1, D_2, D_3 \\in \\mathscr{D} , and any rational numbers a, b \\in \\mathbb{Q} a, b \\in \\mathbb{Q} , we have: Associativity: D_1 \\cdot (D_2 \\cdot D_3) = (D_1 \\cdot D_2) \\cdot D_3 D_1 \\cdot (D_2 \\cdot D_3) = (D_1 \\cdot D_2) \\cdot D_3 Commutativity: D_1 \\cdot D_2 = D_2 \\cdot D_1 D_1 \\cdot D_2 = D_2 \\cdot D_1 Identity (Vector): \\exists \\pmb1 \\in \\mathscr{D}: \\,\\, \\pmb1 \\cdot D = D \\cdot \\pmb1 = D, \\,\\, \\forall D \\exists \\pmb1 \\in \\mathscr{D}: \\,\\, \\pmb1 \\cdot D = D \\cdot \\pmb1 = D, \\,\\, \\forall D Inverse: \\forall D \\in \\mathscr{D}, \\exists D^{-1} \\in \\mathscr{D}: \\,\\, D \\cdot D^{-1} = D^{-1} \\cdot D = 1 \\forall D \\in \\mathscr{D}, \\exists D^{-1} \\in \\mathscr{D}: \\,\\, D \\cdot D^{-1} = D^{-1} \\cdot D = 1 Scalar/Field Multiplication Compatibility: (D^a)^b = D^{(ab)} (D^a)^b = D^{(ab)} (Recall that \u201cscalar multiplication\u201d in \u201cordinary\u201d vector spaces corresponds to exponentiation in our vector space.) Identity (Scalar): \\exists 1 \\in \\mathbb{Q}: \\,\\, D^1 = D \\exists 1 \\in \\mathbb{Q}: \\,\\, D^1 = D Distributivity (Vectors): (D_1 \\cdot D_2)^a = D_1^a \\cdot D_2^a (D_1 \\cdot D_2)^a = D_1^a \\cdot D_2^a Distributivity (Scalars): D^{(a + b)} = D^a \\cdot D^b D^{(a + b)} = D^a \\cdot D^b C++ Implementation Strategies \u00b6 The abstract concepts above form the core of basically every C++ units library. When it comes to implementation , there are a variety of choices. Naive approach: positional arguments \u00b6 The simplest implementation of a vector space is to use positional template parameters to represent the coefficients (exponents) of each basis vector (base dimension). For example: // Basic approach (not used in this library) template < typename LengthExp , typename TimeExp > struct Dimension ; using Length = Dimension < std :: ratio < 1 > , std :: ratio < 0 >> ; using Time = Dimension < std :: ratio < 0 > , std :: ratio < 1 >> ; using Speed = DimQuotientT < Length , Time > ; This approach is easy to implement, but its simplicity comes at a cost. Compiler errors are inscrutable. (What exactly does Dimension<std::ratio<1, 1>, std::ratio<-1, 1>> represent?) If we need to add a new basis vector, it will affect an immense number of callsites. Some applications need infinitely many basis vectors! This approach is a complete non-starter. Advanced approach: variadic templates \u00b6 We can solve all of these problems by making Dimension a variadic template. // Advanced approach (the one we use, although simplified here) template < typename ... BaseDimPowers > struct Dimension ; using Length = Dimension < base_dim :: Length > ; using Time = Dimension < base_dim :: Time > ; using Speed = DimQuotientT < Length , Time > ; // As before. Compiler errors are now easy (or at least possible) to read: when we see something like Dimension<base_dim::Length, Pow<base_dim::Time, -1>> , we can recognize it as \u201cSpeed\u201d. And adding new basis vectors\u2014even arbitrarily many new ones\u2014doesn\u2019t affect any existing callsites. The downside is that the added complexity incurs new risk. Now we have to care about the order of the template parameters; otherwise, we could have different types representing the same conceptual Dimension . Fortunately, that\u2019s exactly why we built the //au:packs target : to handle these subtleties robustly. Other vector space representations \u00b6 Above, we focused on Dimensions as an example use case for the vector space representation. Though by far the most common in units libraries, it\u2019s not the only one that adds value. Here are some others worth recognizing. Magnitude \u00b6 The ratio between two Units of the same Dimension is a positive real number: a \u201cMagnitude\u201d. We use a vector space representation for Magnitudes, because then it will naturally support all the same operations which Dimensions support. But then, what are the basis vectors? What numbers can we use that are \u201cindependent\u201d, in the sense that every Magnitude gets a unique representation? Prime numbers are a great start! Given any collection of primes, \\{p_1, \\ldots, p_N\\} \\{p_1, \\ldots, p_N\\} , and corresponding rational exponents \\{a_1, \\ldots, a_N\\} \\{a_1, \\ldots, a_N\\} , the product p_1^{a_1} \\cdot (\\ldots) \\cdot p_N^{a_N} p_1^{a_1} \\cdot (\\ldots) \\cdot p_N^{a_N} is unique : no other collection \\{a_1, \\ldots, a_N\\} \\{a_1, \\ldots, a_N\\} can produce the same number 1 . This already lets us represent anything we could get with std::ratio . And, unlike a (num, denom) representation, we\u2019re always automatically in lowest terms: any common factors cancel out automatically when we represent it via its prime factorization! In fact, we have surpassed std::ratio \u2018s functionality, too. We can handle very large numbers with negligible risk of overflow: yotta ( 10^{24} 10^{24} ) doesn\u2019t even fit in std::intmax_t , but pow<24>(mag<10>()) 2 handles it with ease. We can even handle radicals: something unthinkable for std::ratio , like \\sqrt{2} \\sqrt{2} , is as easy as root<2>(mag<2>()) 3 . Finally, we can incorporate other irrational numbers, too. No units library is complete without robust support for \\pi \\pi , but std::ratio isn\u2019t up to the task. For vector space magnitude representations, though, its difficulty becomes a strength. We know there is no collection of exponents \\{a_i\\} \\{a_i\\} such that \\pi = \\prod\\limits_{i=1}^N p_i^{a_i} \\pi = \\prod\\limits_{i=1}^N p_i^{a_i} , for any collection of primes \\{p_i\\} \\{p_i\\} . This means that \\pi \\pi is independent , and we can add it as a new basis vector. Then the ratio of, say, Degrees to Radians (i.e., \\pi / 180 \\pi / 180 ) could be expressed as PI / mag<180>() 4 . Units \u00b6 If we form a Unit by combining other units\u2014say, Miles{} / Hours{} \u2014it\u2019s useful to retain the identities of the units that went into it. There are several reasons to prefer this to, say, converting everything to a coherent combination of preferred \u201cbase units\u201d, and some Magnitude for scaling. It will be easy to generate a compound label , by combining the primitive labels for Miles and Hours . Compiler errors will mention only familiar, recognizable Units. It promotes cancellation where appropriate: Miles{} / Hours{} times Hours{} will give simply Miles{} . Our treatment of Units differs from other vector space instances, because we prefer not to use the container type (in this case, UnitProduct<...> ) unless we have to: after all, Meters is more user-friendly than UnitProduct<Meters> , let alone something awful like UnitProduct<RatioPow<Meters, 1, 0>> ! We support this use case with the following strategy: wrap-if-necessary on the way in (via AsPackT ) unwrap-if-possible on the way out (via UnpackIfSoloT ) This was the only machinery we needed to add: apart from that, we were able to leverage our pre-existing packs support to provide a fluent experience for compound units. Technically, this is only true for a finite collection of primes, though the collection can be arbitrarily large. If we took an infinite collection of primes, it wouldn\u2019t just give some numbers multiple representations \u2014 it would give every number uncountably infinitely many distinct representations! In practice, this distinction is largely academic, because our library currently only targets computers with finite amounts of memory. \u21a9 pow<24>(mag<10>()) expands to Magnitude<Pow<Prime<2>, 24>, Pow<Prime<5>, 24>> . \u21a9 root<2>(mag<2>()) expands to Magnitude<RatioPow<Prime<2>, 1, 2>> . \u21a9 PI / mag<180>() expands to Magnitude<Pow<Prime<2>, -2>, Pow<Prime<3>, -2>, Pi, Pow<Prime<5>, -1>> . \u21a9","title":"Vector Space Representations"},{"location":"discussion/implementation/vector_space/#vector-space-representations","text":"To understand why vector space representations are so important for units libraries, we\u2019ll dig into the most fundamental example. After that, we\u2019ll look at some other instances of vector space representations in our library. Consider Dimensions . How can we teach the library to recognize that, say, the product of the Dimensions Speed and Time is the Dimension Length ? If these three Dimensions are all primitive, irreducible objects, this is very challenging. However, if Speed is just an alias for (Length / Time) , then it\u2019s easy to see that (Length / Time) * Time reduces to Length . This is what we do: we single out certain Dimensions and call them \u201cBase Dimensions\u201d. Any valid choice must fulfill these conditions: Independence: no product of rational powers of Base Dimensions is dimensionless , unless all exponents are 0. Completeness: every Dimension of interest can be represented as some product of rational powers of Base Dimensions. The reader may recognize these properties of Base Dimensions as analogous to the defining properties of Basis Vectors in a vector space, but with these differences: instead of adding vectors, we multiply Base Dimensions instead of multiplying vectors by a scalar, we raise them to a power In fact, we can bridge this gap if we consider the exponents of the dimensions to be the scalars of the vector space. In a sense, the \u201clogarithms\u201d of the dimensions form a vector space; in this case, over the rationals. This is the \u201cvector space representation\u201d for Dimensions.","title":"Vector Space Representations"},{"location":"discussion/implementation/vector_space/#fleshing-out-the-analogy","text":"How do the defining properties of vector spaces manifest themselves here? Let the space of all Dimensions be \\mathscr{D} \\mathscr{D} . For any dimensions D, D_1, D_2, D_3 \\in \\mathscr{D} D, D_1, D_2, D_3 \\in \\mathscr{D} , and any rational numbers a, b \\in \\mathbb{Q} a, b \\in \\mathbb{Q} , we have: Associativity: D_1 \\cdot (D_2 \\cdot D_3) = (D_1 \\cdot D_2) \\cdot D_3 D_1 \\cdot (D_2 \\cdot D_3) = (D_1 \\cdot D_2) \\cdot D_3 Commutativity: D_1 \\cdot D_2 = D_2 \\cdot D_1 D_1 \\cdot D_2 = D_2 \\cdot D_1 Identity (Vector): \\exists \\pmb1 \\in \\mathscr{D}: \\,\\, \\pmb1 \\cdot D = D \\cdot \\pmb1 = D, \\,\\, \\forall D \\exists \\pmb1 \\in \\mathscr{D}: \\,\\, \\pmb1 \\cdot D = D \\cdot \\pmb1 = D, \\,\\, \\forall D Inverse: \\forall D \\in \\mathscr{D}, \\exists D^{-1} \\in \\mathscr{D}: \\,\\, D \\cdot D^{-1} = D^{-1} \\cdot D = 1 \\forall D \\in \\mathscr{D}, \\exists D^{-1} \\in \\mathscr{D}: \\,\\, D \\cdot D^{-1} = D^{-1} \\cdot D = 1 Scalar/Field Multiplication Compatibility: (D^a)^b = D^{(ab)} (D^a)^b = D^{(ab)} (Recall that \u201cscalar multiplication\u201d in \u201cordinary\u201d vector spaces corresponds to exponentiation in our vector space.) Identity (Scalar): \\exists 1 \\in \\mathbb{Q}: \\,\\, D^1 = D \\exists 1 \\in \\mathbb{Q}: \\,\\, D^1 = D Distributivity (Vectors): (D_1 \\cdot D_2)^a = D_1^a \\cdot D_2^a (D_1 \\cdot D_2)^a = D_1^a \\cdot D_2^a Distributivity (Scalars): D^{(a + b)} = D^a \\cdot D^b D^{(a + b)} = D^a \\cdot D^b","title":"Fleshing out the analogy"},{"location":"discussion/implementation/vector_space/#c-implementation-strategies","text":"The abstract concepts above form the core of basically every C++ units library. When it comes to implementation , there are a variety of choices.","title":"C++ Implementation Strategies"},{"location":"discussion/implementation/vector_space/#naive-approach-positional-arguments","text":"The simplest implementation of a vector space is to use positional template parameters to represent the coefficients (exponents) of each basis vector (base dimension). For example: // Basic approach (not used in this library) template < typename LengthExp , typename TimeExp > struct Dimension ; using Length = Dimension < std :: ratio < 1 > , std :: ratio < 0 >> ; using Time = Dimension < std :: ratio < 0 > , std :: ratio < 1 >> ; using Speed = DimQuotientT < Length , Time > ; This approach is easy to implement, but its simplicity comes at a cost. Compiler errors are inscrutable. (What exactly does Dimension<std::ratio<1, 1>, std::ratio<-1, 1>> represent?) If we need to add a new basis vector, it will affect an immense number of callsites. Some applications need infinitely many basis vectors! This approach is a complete non-starter.","title":"Naive approach: positional arguments"},{"location":"discussion/implementation/vector_space/#advanced-approach-variadic-templates","text":"We can solve all of these problems by making Dimension a variadic template. // Advanced approach (the one we use, although simplified here) template < typename ... BaseDimPowers > struct Dimension ; using Length = Dimension < base_dim :: Length > ; using Time = Dimension < base_dim :: Time > ; using Speed = DimQuotientT < Length , Time > ; // As before. Compiler errors are now easy (or at least possible) to read: when we see something like Dimension<base_dim::Length, Pow<base_dim::Time, -1>> , we can recognize it as \u201cSpeed\u201d. And adding new basis vectors\u2014even arbitrarily many new ones\u2014doesn\u2019t affect any existing callsites. The downside is that the added complexity incurs new risk. Now we have to care about the order of the template parameters; otherwise, we could have different types representing the same conceptual Dimension . Fortunately, that\u2019s exactly why we built the //au:packs target : to handle these subtleties robustly.","title":"Advanced approach: variadic templates"},{"location":"discussion/implementation/vector_space/#other-vector-space-representations","text":"Above, we focused on Dimensions as an example use case for the vector space representation. Though by far the most common in units libraries, it\u2019s not the only one that adds value. Here are some others worth recognizing.","title":"Other vector space representations"},{"location":"discussion/implementation/vector_space/#magnitude","text":"The ratio between two Units of the same Dimension is a positive real number: a \u201cMagnitude\u201d. We use a vector space representation for Magnitudes, because then it will naturally support all the same operations which Dimensions support. But then, what are the basis vectors? What numbers can we use that are \u201cindependent\u201d, in the sense that every Magnitude gets a unique representation? Prime numbers are a great start! Given any collection of primes, \\{p_1, \\ldots, p_N\\} \\{p_1, \\ldots, p_N\\} , and corresponding rational exponents \\{a_1, \\ldots, a_N\\} \\{a_1, \\ldots, a_N\\} , the product p_1^{a_1} \\cdot (\\ldots) \\cdot p_N^{a_N} p_1^{a_1} \\cdot (\\ldots) \\cdot p_N^{a_N} is unique : no other collection \\{a_1, \\ldots, a_N\\} \\{a_1, \\ldots, a_N\\} can produce the same number 1 . This already lets us represent anything we could get with std::ratio . And, unlike a (num, denom) representation, we\u2019re always automatically in lowest terms: any common factors cancel out automatically when we represent it via its prime factorization! In fact, we have surpassed std::ratio \u2018s functionality, too. We can handle very large numbers with negligible risk of overflow: yotta ( 10^{24} 10^{24} ) doesn\u2019t even fit in std::intmax_t , but pow<24>(mag<10>()) 2 handles it with ease. We can even handle radicals: something unthinkable for std::ratio , like \\sqrt{2} \\sqrt{2} , is as easy as root<2>(mag<2>()) 3 . Finally, we can incorporate other irrational numbers, too. No units library is complete without robust support for \\pi \\pi , but std::ratio isn\u2019t up to the task. For vector space magnitude representations, though, its difficulty becomes a strength. We know there is no collection of exponents \\{a_i\\} \\{a_i\\} such that \\pi = \\prod\\limits_{i=1}^N p_i^{a_i} \\pi = \\prod\\limits_{i=1}^N p_i^{a_i} , for any collection of primes \\{p_i\\} \\{p_i\\} . This means that \\pi \\pi is independent , and we can add it as a new basis vector. Then the ratio of, say, Degrees to Radians (i.e., \\pi / 180 \\pi / 180 ) could be expressed as PI / mag<180>() 4 .","title":"Magnitude"},{"location":"discussion/implementation/vector_space/#units","text":"If we form a Unit by combining other units\u2014say, Miles{} / Hours{} \u2014it\u2019s useful to retain the identities of the units that went into it. There are several reasons to prefer this to, say, converting everything to a coherent combination of preferred \u201cbase units\u201d, and some Magnitude for scaling. It will be easy to generate a compound label , by combining the primitive labels for Miles and Hours . Compiler errors will mention only familiar, recognizable Units. It promotes cancellation where appropriate: Miles{} / Hours{} times Hours{} will give simply Miles{} . Our treatment of Units differs from other vector space instances, because we prefer not to use the container type (in this case, UnitProduct<...> ) unless we have to: after all, Meters is more user-friendly than UnitProduct<Meters> , let alone something awful like UnitProduct<RatioPow<Meters, 1, 0>> ! We support this use case with the following strategy: wrap-if-necessary on the way in (via AsPackT ) unwrap-if-possible on the way out (via UnpackIfSoloT ) This was the only machinery we needed to add: apart from that, we were able to leverage our pre-existing packs support to provide a fluent experience for compound units. Technically, this is only true for a finite collection of primes, though the collection can be arbitrarily large. If we took an infinite collection of primes, it wouldn\u2019t just give some numbers multiple representations \u2014 it would give every number uncountably infinitely many distinct representations! In practice, this distinction is largely academic, because our library currently only targets computers with finite amounts of memory. \u21a9 pow<24>(mag<10>()) expands to Magnitude<Pow<Prime<2>, 24>, Pow<Prime<5>, 24>> . \u21a9 root<2>(mag<2>()) expands to Magnitude<RatioPow<Prime<2>, 1, 2>> . \u21a9 PI / mag<180>() expands to Magnitude<Pow<Prime<2>, -2>, Pow<Prime<3>, -2>, Pi, Pow<Prime<5>, -1>> . \u21a9","title":"Units"},{"location":"howto/","text":"How-to guides \u00b6 This section provides detailed instructions for various common tasks that come up in the course of using the library. See the navigational menu for a list of the guides.","title":"How-to guides"},{"location":"howto/#how-to-guides","text":"This section provides detailed instructions for various common tasks that come up in the course of using the library. See the navigational menu for a list of the guides.","title":"How-to guides"},{"location":"howto/new-units/","text":"Defining new units \u00b6 This page explains how to define new units that aren\u2019t included in the library. Tip If it\u2019s a common unit\u2014one which should be in the library, but isn\u2019t \u2014go ahead and file an issue ! We should be able to turn it around pretty quickly (either adding it to the library, or explaining why we won\u2019t). Definition features \u00b6 Many libraries provide \u201cconvenience\u201d macros for creating new units, but ours tries to avoid macros completely. 1 Instead, you define new units by just writing regular C++ code. There are several pieces you can add, each of which provides some particular feature. Here is a complete sample definition of a new Unit, with these features annotated and explained. C++14 C++17 or later // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr const char label [] = \"ftm\" ; // [2a] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] // In .cc file: constexpr const char Fathoms :: label []; // [2b] // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr inline const char label [] = \"ftm\" ; // [2] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] Note If you\u2019ve seen the unit definitions included in our library, you may notice they look a little different from the above. That\u2019s because the library has different goals and constraints than end user projects have. For example, the library needs to be both C++14-compatible and header-only. This forces us to define our labels in a more complicated way. By contrast, your project is unlikely to have both these constraints. Prefer the simpler approach outlined in this page, instead of treating our library\u2019s source code definitions as examples to follow. Here are the features. Strong type definition . Required. Make a struct with the name you want, and inherit from decltype(u) , where u is some unit expression which gives it the right Dimension and Magnitude. (We\u2019ll explain unit expressions in the next section.) Label . A sizeof() -compatible label which is useful for printing the Unit. Note that if your project needs C++14 compatibility, then besides the label itself ( [2a] ), you\u2019ll need to provide a definition ( [2b] ) in the .cc file. By contrast, if you use C++17 or later, you can just use an inline variable, and you won\u2019t need a .cc file. If omitted: Everything will still work ; your Quantity will just be labeled as [UNLABELED UNIT] in printing contexts. Singular name . An object whose name is the singular name for your unit. Useful in certain contexts: for example, the traditional unit for torque is \u201c newton meters\u201d, not \u201c newtons meters\u201d. If omitted: you\u2019ll sacrifice some readability flow: the grammar becomes strange. You\u2019ll end up with constructs like speed.in(miles / hours) , rather than speed.in(miles / hour) . 2 Quantity maker . Required. This gives you a snake_case version of your unit which acts like a function. If you call this \u201cfunction\u201d and pass it any numeric type, it creates a Quantity of your unit , whose Rep is that type. Of course, a quantity maker is much more than a function: it composes nicely with prefixes, and with other quantity makers. Quantity point maker . Just like the quantity maker, but conventionally with a _pt suffix to indicate that it makes QuantityPoint instead. You can call this like a function on arbitrary numeric types. You can also compose it with prefixes, or scale it with Magnitudes. If omitted: this is usually fine to omit: most Units are only used with Quantity , not QuantityPoint . Note Not shown here: adding an origin member. We skipped this because it is very rare. It only has any effect at all for Units you plan to use with QuantityPoint , which is not the usual case. Even among those units, only a small subset have a non-default origin. The main examples are Celsius and Fahrenheit , and the library will provide those out of the box. Unit expressions \u00b6 Above, we said to inherit your unit\u2019s strong type from the decltype of a \u201cunit expression\u201d. Recall the line from above: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // Unit Expression ^^^^^^^^^^^^^^^^^^^^ This section explains what kinds of things can go inside of the decltype(...) . Conceptually, units are defined by combining other units . In general, given any set of units, you can multiply them, divide them, raise them to powers, or scale them by real numbers (\u201cmagnitudes\u201d): the result of any of these operations defines a new unit. In C++ code, the easiest way to do this is by working with instances of the unit types. ( Meters is the type ; Meters{} is an instance of the type.) This lets us multiply them naturally by writing * , rather than using cumbersome template traits such as UnitProductT<...> . Here are some examples: Newtons: Kilo<Grams>{} * Meters{} / squared(Seconds{}) Miles: Feet{} * mag<5280>() Degrees: Radians{} * PI / mag<180>() Aliases vs. strong types: best practices \u00b6 A shorter method of defining units is as aliases for a compound unit. For example: using MilesPerHour = decltype ( Miles {} / Hours {}); constexpr auto miles_per_hour = miles / hour ; We can use the alias, MilesPerHour , anywhere we\u2019d use a unit type. And we can call the QuantityMaker, miles_per_hour , just as we would call miles . 3 We even get an automatically generated unit label: mi / h . Despite this convenience, aliases aren\u2019t always the best choice. Here\u2019s the best practices guidance to follow. Use strong types for named units. Example: Newtons ; Fathoms Rationale: Strong types show up in compiler errors, making them easier to read. Counterpoint: as seen below, this will reduce the ability to cancel out units. For example, Meters{} * Hertz{} will not be the same as Meters{} / Seconds{} ; instead, it will be a different-but-equivalent Unit. Given the way we handle quantity-equivalent Units, this will usually not be a problem, and we believe the value of seeing shorter, more familiar names in the compiler errors outweighs this cost. Use aliases for compound units with no special name. Example: NewtonMeters ; MilesPerHour . Both of these are better implemented as aliases rather than strong types . Rationale: Keeping these as aliases increases support for cancellation: it enables the library to notice that MetersPerSecond{} * Seconds{} is identical to Meters{} , not merely quantity-equivalent. This doesn\u2019t usually matter, but it can reduce exposure to compiler errors in the (rare) situations where exact-type-equality matters (e.g., initializer lists). Macros have long been considered contrary to C++ best practices. If we\u2019re going to use one, especially in user-facing code, it needs to meet a very high bar. Unit definition macros don\u2019t meet this bar. They mostly exist to save typing. But code is read far more often than written, and macros actually make the definitions harder to read and understand (because they use positional arguments, so the meaning of the parameters is unclear at the callsite). \u21a9 Note that this requires us to build out multiplication and division between two QuantityMaker instances, rather than just a QuantityMaker and a SingularNameFor . We haven\u2019t done this yet, but it\u2019s inevitable that we will, to support composing units whose singular name is identical to the plural name (e.g., hertz ). \u21a9 Note that we don\u2019t \u201cneed\u201d to define this. We could write (miles / hour)(65) , and get exactly the same result as miles_per_hour(65) . However, some users may prefer the latter syntax. \u21a9","title":"Defining new units"},{"location":"howto/new-units/#defining-new-units","text":"This page explains how to define new units that aren\u2019t included in the library. Tip If it\u2019s a common unit\u2014one which should be in the library, but isn\u2019t \u2014go ahead and file an issue ! We should be able to turn it around pretty quickly (either adding it to the library, or explaining why we won\u2019t).","title":"Defining new units"},{"location":"howto/new-units/#definition-features","text":"Many libraries provide \u201cconvenience\u201d macros for creating new units, but ours tries to avoid macros completely. 1 Instead, you define new units by just writing regular C++ code. There are several pieces you can add, each of which provides some particular feature. Here is a complete sample definition of a new Unit, with these features annotated and explained. C++14 C++17 or later // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr const char label [] = \"ftm\" ; // [2a] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] // In .cc file: constexpr const char Fathoms :: label []; // [2b] // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr inline const char label [] = \"ftm\" ; // [2] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] Note If you\u2019ve seen the unit definitions included in our library, you may notice they look a little different from the above. That\u2019s because the library has different goals and constraints than end user projects have. For example, the library needs to be both C++14-compatible and header-only. This forces us to define our labels in a more complicated way. By contrast, your project is unlikely to have both these constraints. Prefer the simpler approach outlined in this page, instead of treating our library\u2019s source code definitions as examples to follow. Here are the features. Strong type definition . Required. Make a struct with the name you want, and inherit from decltype(u) , where u is some unit expression which gives it the right Dimension and Magnitude. (We\u2019ll explain unit expressions in the next section.) Label . A sizeof() -compatible label which is useful for printing the Unit. Note that if your project needs C++14 compatibility, then besides the label itself ( [2a] ), you\u2019ll need to provide a definition ( [2b] ) in the .cc file. By contrast, if you use C++17 or later, you can just use an inline variable, and you won\u2019t need a .cc file. If omitted: Everything will still work ; your Quantity will just be labeled as [UNLABELED UNIT] in printing contexts. Singular name . An object whose name is the singular name for your unit. Useful in certain contexts: for example, the traditional unit for torque is \u201c newton meters\u201d, not \u201c newtons meters\u201d. If omitted: you\u2019ll sacrifice some readability flow: the grammar becomes strange. You\u2019ll end up with constructs like speed.in(miles / hours) , rather than speed.in(miles / hour) . 2 Quantity maker . Required. This gives you a snake_case version of your unit which acts like a function. If you call this \u201cfunction\u201d and pass it any numeric type, it creates a Quantity of your unit , whose Rep is that type. Of course, a quantity maker is much more than a function: it composes nicely with prefixes, and with other quantity makers. Quantity point maker . Just like the quantity maker, but conventionally with a _pt suffix to indicate that it makes QuantityPoint instead. You can call this like a function on arbitrary numeric types. You can also compose it with prefixes, or scale it with Magnitudes. If omitted: this is usually fine to omit: most Units are only used with Quantity , not QuantityPoint . Note Not shown here: adding an origin member. We skipped this because it is very rare. It only has any effect at all for Units you plan to use with QuantityPoint , which is not the usual case. Even among those units, only a small subset have a non-default origin. The main examples are Celsius and Fahrenheit , and the library will provide those out of the box.","title":"Definition features"},{"location":"howto/new-units/#unit-expressions","text":"Above, we said to inherit your unit\u2019s strong type from the decltype of a \u201cunit expression\u201d. Recall the line from above: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // Unit Expression ^^^^^^^^^^^^^^^^^^^^ This section explains what kinds of things can go inside of the decltype(...) . Conceptually, units are defined by combining other units . In general, given any set of units, you can multiply them, divide them, raise them to powers, or scale them by real numbers (\u201cmagnitudes\u201d): the result of any of these operations defines a new unit. In C++ code, the easiest way to do this is by working with instances of the unit types. ( Meters is the type ; Meters{} is an instance of the type.) This lets us multiply them naturally by writing * , rather than using cumbersome template traits such as UnitProductT<...> . Here are some examples: Newtons: Kilo<Grams>{} * Meters{} / squared(Seconds{}) Miles: Feet{} * mag<5280>() Degrees: Radians{} * PI / mag<180>()","title":"Unit expressions"},{"location":"howto/new-units/#aliases-vs-strong-types-best-practices","text":"A shorter method of defining units is as aliases for a compound unit. For example: using MilesPerHour = decltype ( Miles {} / Hours {}); constexpr auto miles_per_hour = miles / hour ; We can use the alias, MilesPerHour , anywhere we\u2019d use a unit type. And we can call the QuantityMaker, miles_per_hour , just as we would call miles . 3 We even get an automatically generated unit label: mi / h . Despite this convenience, aliases aren\u2019t always the best choice. Here\u2019s the best practices guidance to follow. Use strong types for named units. Example: Newtons ; Fathoms Rationale: Strong types show up in compiler errors, making them easier to read. Counterpoint: as seen below, this will reduce the ability to cancel out units. For example, Meters{} * Hertz{} will not be the same as Meters{} / Seconds{} ; instead, it will be a different-but-equivalent Unit. Given the way we handle quantity-equivalent Units, this will usually not be a problem, and we believe the value of seeing shorter, more familiar names in the compiler errors outweighs this cost. Use aliases for compound units with no special name. Example: NewtonMeters ; MilesPerHour . Both of these are better implemented as aliases rather than strong types . Rationale: Keeping these as aliases increases support for cancellation: it enables the library to notice that MetersPerSecond{} * Seconds{} is identical to Meters{} , not merely quantity-equivalent. This doesn\u2019t usually matter, but it can reduce exposure to compiler errors in the (rare) situations where exact-type-equality matters (e.g., initializer lists). Macros have long been considered contrary to C++ best practices. If we\u2019re going to use one, especially in user-facing code, it needs to meet a very high bar. Unit definition macros don\u2019t meet this bar. They mostly exist to save typing. But code is read far more often than written, and macros actually make the definitions harder to read and understand (because they use positional arguments, so the meaning of the parameters is unclear at the callsite). \u21a9 Note that this requires us to build out multiplication and division between two QuantityMaker instances, rather than just a QuantityMaker and a SingularNameFor . We haven\u2019t done this yet, but it\u2019s inevitable that we will, to support composing units whose singular name is identical to the plural name (e.g., hertz ). \u21a9 Note that we don\u2019t \u201cneed\u201d to define this. We could write (miles / hour)(65) , and get exactly the same result as miles_per_hour(65) . However, some users may prefer the latter syntax. \u21a9","title":"Aliases vs. strong types: best practices"},{"location":"reference/","text":"Reference Docs \u00b6 This section contains detailed reference documentation on Quantity , QuantityPoint , units, dimensions, magnitudes, and other core library abstractions. The main folder is reserved for things that end users will routinely interact with. Implementation details will be documented in a detail sub-folder.","title":"Reference Docs"},{"location":"reference/#reference-docs","text":"This section contains detailed reference documentation on Quantity , QuantityPoint , units, dimensions, magnitudes, and other core library abstractions. The main folder is reserved for things that end users will routinely interact with. Implementation details will be documented in a detail sub-folder.","title":"Reference Docs"},{"location":"reference/magnitude/","text":"Magnitude \u00b6 Magnitude is a family of monovalue types representing positive real numbers. These values can be multiplied, divided, and raised to (rational) powers, and this arithmetic always takes place at compile time. Values can also be converted to more standard numeric types, such as double and int , as long as the receiving type can represent the magnitude\u2019s value faithfully. The core motivation is to represent ratios of different units that have the same dimension. As a corollary, any unit can be scaled by a Magnitude to make a new unit of the same dimension. Forming magnitudes \u00b6 There are 3 valid ways for end users to form a Magnitude instance. Using the mag<N>() helper to form the canonical representation of the integer N . Writing Magnitude<MyConstant>{} , where MyConstant is a valid irrational magnitude base . (See the custom bases section below for more details.) Forming products, quotients, powers, and roots of other valid Magnitude instances. End users can also use pre-formed Magnitude instances from the library, such as PI and ONE . The following is a valid, but dis-preferred way to form a Magnitude . Magnitude<> . Explanation: This represents the number 1, but it\u2019s less readable than writing mag<1>() . The following are not valid ways to form a Magnitude . Magnitude<Pi, MyConstant> . Explanation: Do not supply a manual sequence of template parameters. Magnitude has strict ordering requirements on its template parameters. The approved methods listed above are guaranteed to satisfy these requirements. Magnitude<Prime<3>> . Explanation: Do not supply integer bases manually. Integers are represented by their prime factorization, which is performed automatically. Instead, form integers, rationals, and their powers only by starting with valid Magnitude instances, and performing arithmetic operations as in option 3 above. Below, we give more details on several concepts mentioned above. mag<N>() \u00b6 mag<N>() gives an instance of the unique, canonical Magnitude type that represents the positive integer N . More detail on integral Magnitude representations Integers are stored as their prime factorization. For example, 18 would be stored as the type Magnitude<Prime<2>, Pow<Prime<3>, 2>> , because 18 = 2 \\cdot 3^2 18 = 2 \\cdot 3^2 . mag<N>() automatically performs the prime factorization of N , and constructs a well-formed Magnitude . Custom bases \u00b6 Magnitude can handle some irrational numbers. This even includes some transcendental numbers, such as \\pi \\pi . Because Magnitude is closed under products and rational powers, this means that we also automatically support related values such as \\pi^2 \\pi^2 , \\frac{1}{\\sqrt{2\\pi}} \\frac{1}{\\sqrt{2\\pi}} , and so on. What irrational numbers can Magnitude not handle? A common example is any that are formed by addition. For example, (1 + \\sqrt{2}) (1 + \\sqrt{2}) cannot be represented by Magnitude . Recall that Magnitude is designed to support products and rational powers, since these are the most important operations in quantity calculus. It is tempting to want a better representation \u2014 one which supports full symbolic algebra. Perhaps such a representation could be designed. However, we haven\u2019t seen any real world use cases for it. The current Magnitude implementation already handles the most critical use cases, such as handling \\pi \\pi , which most units libraries have traditionally struggled to support. Because of its importance for angular variables, \\pi \\pi is supported natively in the library \u2014 you don\u2019t need to define it yourself. The constant PI is a Magnitude instance . It\u2019s based on the (natively included) irrational magnitude base, Pi . (Concretely: PI is defined as Magnitude<Pi>{} , in accordance with option 2 above.) If you need to represent an irrational number which can\u2019t be formed via any product of powers of the existing Magnitude types \u2014 namely, integers and \\pi \\pi \u2014 then you can define a new irrational magnitude base. This is a struct with the following member: static constexpr long double value() : the best approximation of your constant\u2019s value in the long double storage type. Important information for defining your own constant If you return a literal, you must add L on the end. Otherwise it will be interpreted as double , and will lose precision. Here are the results of one example which was run on an arbitrary development machine. No suffix L suffix Literal 3.141592653589793238 3.141592653589793238L Actual Value 3.141592653589793115 3.141592653589793238 The un-suffixed version has lost several digits of precision. (The precise amount will depend on the computer architecture being used.) Each time you add a new irrational magnitude base, you must make sure that it\u2019s independent: that is, that it can\u2019t be formed as any product of rational powers of existing Magnitude types. Extracting values \u00b6 As a monovalue type , Magnitude can only hold one value. There are no computations we can perform at runtime; everything happens at compile time. What we can do is to extract that represented value, and store it in a more conventional numeric type, such as int or double . To extract the value of a Magnitude instance m into a given numeric type T , call get_value<T>(m) . Here are some important aspects of this utility. The computation takes place completely at compile time. The computation takes place in the widest type of the same kind. (That is, when T is floating point we use long double , and when T is integral we use std::intmax_t or std::uintmax_t according to the signedness of T .) If T cannot hold the value represented by m , we produce a compile time error. Example: float and \\pi^3 \\pi^3 Suppose you are running on an architecture which has hardware support for float , but uses slow software emulation for double and long double . With Magnitude and get_value , you can get the best of both worlds: The computation gets performed at compile time in long double , giving extra precision. The result gets cast to float and stored as a program constant. Thus, get_value<float>(pow<3>(PI)) will be much more accurate than storing \\pi \\pi in a float , and cubing it \u2014 yet, there will be no loss in performance. Operations \u00b6 These are the operations which Magnitude supports. Because it is a monovalue type , the value can take the form of either a type or an instance . In what follows, we\u2019ll use this convention: Capital identifiers ( M , M1 , M2 , \u2026) refer to types . Lowercase identifiers ( m , m1 , m2 , \u2026) refer to instances . Equality comparison \u00b6 Result: A bool indicating whether two Magnitude values represent the same number. Syntax: For types M1 and M2 : std::is_same<M1, M2>::value For instances m1 and m2 : m1 == m2 (equality comparison) m1 != m2 (inequality comparison) Multiplication \u00b6 Result: The product of two Magnitude values. Syntax: For types M1 and M2 : MagProductT<M1, M2> For instances m1 and m2 : m1 * m2 Division \u00b6 Result: The quotient of two Magnitude values. Syntax: For types M1 and M2 : MagQuotientT<M1, M2> For instances m1 and m2 : m1 / m2 Powers \u00b6 Result: A Magnitude raised to an integral power. Syntax: For a type M , and an integral power N : MagPowerT<M, N> For an instance m , and an integral power N : pow<N>(m) Roots \u00b6 Result: An integral root of a Magnitude . Syntax: For a type M , and an integral root N : MagPowerT<M, 1, N> (because the N^\\text{th} N^\\text{th} root is equivalent to the \\left(\\frac{1}{N}\\right)^\\text{th} \\left(\\frac{1}{N}\\right)^\\text{th} power) For an instance m , and an integral root N : root<N>(m) Traits \u00b6 These traits provide information, at compile time, about the number represented by a Magnitude . Integer test \u00b6 Result: A bool indicating whether a Magnitude represents an integer ( true if it does; false otherwise). Syntax: For a type M : IsInteger<M>::value For an instance m : is_integer(m) Rational test \u00b6 Result: A bool indicating whether a Magnitude represents a rational number ( true if it does; false otherwise). Syntax: For a type M : IsRational<M>::value For an instance m : is_rational(m) Numerator (integer part) \u00b6 Result: The integer part of the numerator we would have if a Magnitude were written as a fraction. This result is another Magnitude . For example, the \u201cnumerator\u201d of \\frac{3\\sqrt{3}}{5\\pi} \\frac{3\\sqrt{3}}{5\\pi} would be 3 3 , because it is the integer part of 3\\sqrt{3} 3\\sqrt{3} . Syntax: For a type M : NumeratorT<M> For an instance m : numerator(m) Warning This name and/or convention may be subject to change; see #83 . Denominator (integer part) \u00b6 Result: The integer part of the denominator we would have if a Magnitude were written as a fraction. This result is another Magnitude . For example, the \u201cdenominator\u201d of \\frac{3\\sqrt{3}}{5\\pi} \\frac{3\\sqrt{3}}{5\\pi} would be 5 5 , because it is the integer part of 5\\pi 5\\pi . Syntax: For a type M : DenominatorT<M> For an instance m : denominator(m) Warning This name and/or convention may be subject to change; see #83 .","title":"Magnitude"},{"location":"reference/magnitude/#magnitude","text":"Magnitude is a family of monovalue types representing positive real numbers. These values can be multiplied, divided, and raised to (rational) powers, and this arithmetic always takes place at compile time. Values can also be converted to more standard numeric types, such as double and int , as long as the receiving type can represent the magnitude\u2019s value faithfully. The core motivation is to represent ratios of different units that have the same dimension. As a corollary, any unit can be scaled by a Magnitude to make a new unit of the same dimension.","title":"Magnitude"},{"location":"reference/magnitude/#forming-magnitudes","text":"There are 3 valid ways for end users to form a Magnitude instance. Using the mag<N>() helper to form the canonical representation of the integer N . Writing Magnitude<MyConstant>{} , where MyConstant is a valid irrational magnitude base . (See the custom bases section below for more details.) Forming products, quotients, powers, and roots of other valid Magnitude instances. End users can also use pre-formed Magnitude instances from the library, such as PI and ONE . The following is a valid, but dis-preferred way to form a Magnitude . Magnitude<> . Explanation: This represents the number 1, but it\u2019s less readable than writing mag<1>() . The following are not valid ways to form a Magnitude . Magnitude<Pi, MyConstant> . Explanation: Do not supply a manual sequence of template parameters. Magnitude has strict ordering requirements on its template parameters. The approved methods listed above are guaranteed to satisfy these requirements. Magnitude<Prime<3>> . Explanation: Do not supply integer bases manually. Integers are represented by their prime factorization, which is performed automatically. Instead, form integers, rationals, and their powers only by starting with valid Magnitude instances, and performing arithmetic operations as in option 3 above. Below, we give more details on several concepts mentioned above.","title":"Forming magnitudes"},{"location":"reference/magnitude/#magn","text":"mag<N>() gives an instance of the unique, canonical Magnitude type that represents the positive integer N . More detail on integral Magnitude representations Integers are stored as their prime factorization. For example, 18 would be stored as the type Magnitude<Prime<2>, Pow<Prime<3>, 2>> , because 18 = 2 \\cdot 3^2 18 = 2 \\cdot 3^2 . mag<N>() automatically performs the prime factorization of N , and constructs a well-formed Magnitude .","title":"mag&lt;N&gt;()"},{"location":"reference/magnitude/#custom-bases","text":"Magnitude can handle some irrational numbers. This even includes some transcendental numbers, such as \\pi \\pi . Because Magnitude is closed under products and rational powers, this means that we also automatically support related values such as \\pi^2 \\pi^2 , \\frac{1}{\\sqrt{2\\pi}} \\frac{1}{\\sqrt{2\\pi}} , and so on. What irrational numbers can Magnitude not handle? A common example is any that are formed by addition. For example, (1 + \\sqrt{2}) (1 + \\sqrt{2}) cannot be represented by Magnitude . Recall that Magnitude is designed to support products and rational powers, since these are the most important operations in quantity calculus. It is tempting to want a better representation \u2014 one which supports full symbolic algebra. Perhaps such a representation could be designed. However, we haven\u2019t seen any real world use cases for it. The current Magnitude implementation already handles the most critical use cases, such as handling \\pi \\pi , which most units libraries have traditionally struggled to support. Because of its importance for angular variables, \\pi \\pi is supported natively in the library \u2014 you don\u2019t need to define it yourself. The constant PI is a Magnitude instance . It\u2019s based on the (natively included) irrational magnitude base, Pi . (Concretely: PI is defined as Magnitude<Pi>{} , in accordance with option 2 above.) If you need to represent an irrational number which can\u2019t be formed via any product of powers of the existing Magnitude types \u2014 namely, integers and \\pi \\pi \u2014 then you can define a new irrational magnitude base. This is a struct with the following member: static constexpr long double value() : the best approximation of your constant\u2019s value in the long double storage type. Important information for defining your own constant If you return a literal, you must add L on the end. Otherwise it will be interpreted as double , and will lose precision. Here are the results of one example which was run on an arbitrary development machine. No suffix L suffix Literal 3.141592653589793238 3.141592653589793238L Actual Value 3.141592653589793115 3.141592653589793238 The un-suffixed version has lost several digits of precision. (The precise amount will depend on the computer architecture being used.) Each time you add a new irrational magnitude base, you must make sure that it\u2019s independent: that is, that it can\u2019t be formed as any product of rational powers of existing Magnitude types.","title":"Custom bases"},{"location":"reference/magnitude/#extracting-values","text":"As a monovalue type , Magnitude can only hold one value. There are no computations we can perform at runtime; everything happens at compile time. What we can do is to extract that represented value, and store it in a more conventional numeric type, such as int or double . To extract the value of a Magnitude instance m into a given numeric type T , call get_value<T>(m) . Here are some important aspects of this utility. The computation takes place completely at compile time. The computation takes place in the widest type of the same kind. (That is, when T is floating point we use long double , and when T is integral we use std::intmax_t or std::uintmax_t according to the signedness of T .) If T cannot hold the value represented by m , we produce a compile time error. Example: float and \\pi^3 \\pi^3 Suppose you are running on an architecture which has hardware support for float , but uses slow software emulation for double and long double . With Magnitude and get_value , you can get the best of both worlds: The computation gets performed at compile time in long double , giving extra precision. The result gets cast to float and stored as a program constant. Thus, get_value<float>(pow<3>(PI)) will be much more accurate than storing \\pi \\pi in a float , and cubing it \u2014 yet, there will be no loss in performance.","title":"Extracting values"},{"location":"reference/magnitude/#operations","text":"These are the operations which Magnitude supports. Because it is a monovalue type , the value can take the form of either a type or an instance . In what follows, we\u2019ll use this convention: Capital identifiers ( M , M1 , M2 , \u2026) refer to types . Lowercase identifiers ( m , m1 , m2 , \u2026) refer to instances .","title":"Operations"},{"location":"reference/magnitude/#equality-comparison","text":"Result: A bool indicating whether two Magnitude values represent the same number. Syntax: For types M1 and M2 : std::is_same<M1, M2>::value For instances m1 and m2 : m1 == m2 (equality comparison) m1 != m2 (inequality comparison)","title":"Equality comparison"},{"location":"reference/magnitude/#multiplication","text":"Result: The product of two Magnitude values. Syntax: For types M1 and M2 : MagProductT<M1, M2> For instances m1 and m2 : m1 * m2","title":"Multiplication"},{"location":"reference/magnitude/#division","text":"Result: The quotient of two Magnitude values. Syntax: For types M1 and M2 : MagQuotientT<M1, M2> For instances m1 and m2 : m1 / m2","title":"Division"},{"location":"reference/magnitude/#powers","text":"Result: A Magnitude raised to an integral power. Syntax: For a type M , and an integral power N : MagPowerT<M, N> For an instance m , and an integral power N : pow<N>(m)","title":"Powers"},{"location":"reference/magnitude/#roots","text":"Result: An integral root of a Magnitude . Syntax: For a type M , and an integral root N : MagPowerT<M, 1, N> (because the N^\\text{th} N^\\text{th} root is equivalent to the \\left(\\frac{1}{N}\\right)^\\text{th} \\left(\\frac{1}{N}\\right)^\\text{th} power) For an instance m , and an integral root N : root<N>(m)","title":"Roots"},{"location":"reference/magnitude/#traits","text":"These traits provide information, at compile time, about the number represented by a Magnitude .","title":"Traits"},{"location":"reference/magnitude/#integer-test","text":"Result: A bool indicating whether a Magnitude represents an integer ( true if it does; false otherwise). Syntax: For a type M : IsInteger<M>::value For an instance m : is_integer(m)","title":"Integer test"},{"location":"reference/magnitude/#rational-test","text":"Result: A bool indicating whether a Magnitude represents a rational number ( true if it does; false otherwise). Syntax: For a type M : IsRational<M>::value For an instance m : is_rational(m)","title":"Rational test"},{"location":"reference/magnitude/#numerator-integer-part","text":"Result: The integer part of the numerator we would have if a Magnitude were written as a fraction. This result is another Magnitude . For example, the \u201cnumerator\u201d of \\frac{3\\sqrt{3}}{5\\pi} \\frac{3\\sqrt{3}}{5\\pi} would be 3 3 , because it is the integer part of 3\\sqrt{3} 3\\sqrt{3} . Syntax: For a type M : NumeratorT<M> For an instance m : numerator(m) Warning This name and/or convention may be subject to change; see #83 .","title":"Numerator (integer part)"},{"location":"reference/magnitude/#denominator-integer-part","text":"Result: The integer part of the denominator we would have if a Magnitude were written as a fraction. This result is another Magnitude . For example, the \u201cdenominator\u201d of \\frac{3\\sqrt{3}}{5\\pi} \\frac{3\\sqrt{3}}{5\\pi} would be 5 5 , because it is the integer part of 5\\pi 5\\pi . Syntax: For a type M : DenominatorT<M> For an instance m : denominator(m) Warning This name and/or convention may be subject to change; see #83 .","title":"Denominator (integer part)"},{"location":"reference/prefix/","text":"Prefix \u00b6 A \u201cprefix\u201d scales a unit by some magnitude , and prepends a prefix symbol to the unit\u2019s label. TODO: this page is a stub We will provide a full-fledged reference for prefixes later. For now, here are the basics: We support every SI prefix and binary prefix . To apply a prefix to a unit type , spell the prefix using CamelCase (just like any other type in Au), and pass the unit type as a template parameter . Example: Meters is a unit type; so is Centi<Meters> . You can form a QuantityD<Centi<Meters>> . To apply a prefix to a quantity maker , spell the prefix using snake_case (just like the quantity maker itself), and pass the quantity maker as a function parameter . Example: meters is a quantity maker; so is centi(meters) . If you call centi(meters)(2.54) , it will create a quantity of centimeters.","title":"Prefix"},{"location":"reference/prefix/#prefix","text":"A \u201cprefix\u201d scales a unit by some magnitude , and prepends a prefix symbol to the unit\u2019s label. TODO: this page is a stub We will provide a full-fledged reference for prefixes later. For now, here are the basics: We support every SI prefix and binary prefix . To apply a prefix to a unit type , spell the prefix using CamelCase (just like any other type in Au), and pass the unit type as a template parameter . Example: Meters is a unit type; so is Centi<Meters> . You can form a QuantityD<Centi<Meters>> . To apply a prefix to a quantity maker , spell the prefix using snake_case (just like the quantity maker itself), and pass the quantity maker as a function parameter . Example: meters is a quantity maker; so is centi(meters) . If you call centi(meters)(2.54) , it will create a quantity of centimeters.","title":"Prefix"},{"location":"reference/unit/","text":"Unit \u00b6 A unit is a type which represents a unit of measure. Examples include Meters , Radians , Hours , and so on. Users can work with units as either types or instances , and can freely convert between these representations. That is to say: units are monovalue types . Identifying unit types \u00b6 A unit is not forced to be a specialization of some central type template, such as a hypothetical Unit<...> . Rather, it\u2019s more open ended: a unit can be any type which fulfills certain defining properties. To be a unit, a type U : Must contain a public type alias, U::Dim , which refers to a valid dimension type . Must contain a public type alias, U::Mag , which refers to a valid magnitude type . Must be a monovalue type . May contain a static constexpr member named label , which is a C-style const char[] ( not a const char* ). 1 May contain a static constexpr member function origin() , which returns a quantity whose dimension type is U::Dim . A custom origin() is very rarely needed. Both labels and origins will be discussed further below. Making unit types \u00b6 Although every unit type needs Dim and Mag members, users won\u2019t need to add them directly. Rather, the best way to make a unit type is by combining existing unit types via supported operations . This approach has two key advantages relative to defining your unit as a fully manual struct . If your input types are all valid units, your output type will be too. It makes the definition more readable and physically meaningful. To give your unit type the best ergonomics, follow our how-to guide for defining new units . Unit labels \u00b6 Every unit has a label. Its label is a constexpr const char[] of the appropriate size. For a unit type U , or instance u , we can access the label as follows: unit_label<U>() unit_label(u) This function returns a reference to the array, which again is a compile time constant. Note especially that the type is an array ( [] ). A pointer ( * ) is not acceptable. This is so that we can support sizeof(unit_label(u)) . Using C-style char arrays for our labels makes Au more friendly for embedded users, because it gives them full access to the labels without forcing them to depend on <string> or <iostream> . [UNLABELED_UNIT] \u00b6 If a unit does not have an explicit label, we will try to generate one automatically. If we\u2019re unable to do so, we fall back to the \u201cdefault label\u201d, which is \"[UNLABELED_UNIT]\" . This is a label just like any other: we do not attempt to \u201cpropagate the un-labeled-ness\u201d. As a concrete example, if Foos is an unlabeled unit, then the label for Nano<Foos>{} / Seconds{} would be \"n[UNLABELED_UNIT] / s\" . This is to preserve as much structure as possible for end users, so they have the best chance of recognizing the offending unit, and perhaps upgrading it. Note A key design goal is for every combination of meaningfully labeled units, by every supported operation, to produce a meaningfully labeled unit. Right now, the only missing operation is scaling a unit by a magnitude. We are tracking this in #85 . Unit origins \u00b6 The \u201corigin\u201d of a unit is only useful for QuantityPoint , our affine space type . Even then, the origin by itself is not meaningful. Only the difference between the origins of two units is meaningful. You would use this to implement an \u201coffset\u201d unit, such as Celsius or Fahrenheit . However, note that both of these are already implemented in the library. The origin defaults to ZERO if not supplied. Types for combined units \u00b6 A core tenet of Au\u2019s design philosophy is to avoid giving any units special status. Every named unit enters into a unit computation on equal footing. We will keep track of the accumulated powers of each named unit, cancelling as appropriate. The final form will follow these rules. Every power of a named unit will be represented according to the representation table . That is, it will be omitted if its power is zero, and will otherwise appear as one of Pow , RatioPow , or the bare unit itself. If only one named unit remains with nonzero power, then that named unit power (as represented in the previous rule) is the complete type. If multiple named units remain with nonzero power, then their representations (according to rule 1) are combined as the elements of a variadic UnitProduct<...> pack. Warning The ordering of the bases is deterministic, but is implementation defined, and can change at any time. It is a programming error to write code that assumes any specific ordering of the units in a pack. A few examples We have omitted the au:: namespace in the following examples for greater clarity. Unit expression Resulting unit type squared(Meters{}) Pow<Meters, 2> Meters{} / Seconds{} UnitProduct<Meters, Pow<Seconds, -1>> Seconds{} * Meters{} / Seconds{} Meters Operations \u00b6 These are the operations which each unit type supports. Because a unit must be a monovalue type , it can take the form of either a type or an instance . In what follows, we\u2019ll use this convention: Capital identifiers ( U , U1 , U2 , \u2026) refer to types . Lowercase identifiers ( u , u1 , u2 , \u2026) refer to instances . Multiplication \u00b6 Result: The product of two units. Syntax: For types U1 and U2 : UnitProductT<U1, U2> For instances u1 and u2 : u1 * u2 Division \u00b6 Result: The quotient of two units. Syntax: For types U1 and U2 : UnitQuotientT<U1, U2> For instances u1 and u2 : u1 / u2 Powers \u00b6 Result: A unit raised to an integral power. Syntax: For a type U , and an integral power N : UnitPowerT<U, N> For an instance u , and an integral power N : pow<N>(u) Roots \u00b6 Result: An integral root of a unit. Syntax: For a type U , and an integral root N : UnitPowerT<U, 1, N> (because the N^\\text{th} N^\\text{th} root is equivalent to the \\left(\\frac{1}{N}\\right)^\\text{th} \\left(\\frac{1}{N}\\right)^\\text{th} power) For an instance u , and an integral root N : root<N>(u) Helpers for powers and roots \u00b6 Note We plan to make these available for Magnitude and Dimension as well. See #84 to track progress. Each of the following helpers are available to operate on a unit instance, u : Helper Result inverse(u) pow<-1>(u) squared(u) pow<2>(u) cubed(u) pow<3>(u) sqrt(u) root<2>(u) cbrt(u) root<3>(u) Scaling by Magnitude \u00b6 Result: A new unit which has been scaled by the given magnitude. More specifically, for a unit instance u and magnitude instance m , this operation: Preserves the dimension of u . Scales the magnitude of u by a factor of m . Deletes the label of u . Preserves the origin of u . Syntax: u * m Traits \u00b6 Sections describing bool traits will be indicated with a trailing question mark, \"?\" . Is unit? \u00b6 Result: Indicates whether the argument is a valid unit. Warning We don\u2019t currently have a trait that can detect whether or not a type is a monovalue type . Thus, the current implementation only checks whether the dimension and magnitude are valid. Until we get such a trait, authors of unit types are responsible for satisfying the monovalue type requirement. Syntax: For type U : IsUnit<U>::value For instance u : is_unit(u) Has same dimension? \u00b6 Result: Indicates whether two units have the same dimension. Syntax: For types U1 and U2 : HasSameDimension<U1, U2>::value For instances u1 and u2 : has_same_dimension(u1, u2) Are units quantity-equivalent? \u00b6 Result: Indicates whether two units are quantity-equivalent. This means that they have the same dimension and same magnitude. Quantities of quantity-equivalent units may be trivially converted to each other with no conversion factor. For example, Meters{} * Hertz{} is not the same unit as Meters{} / Seconds{} , but they are quantity-equivalent . Syntax: For types U1 and U2 : AreUnitsQuantityEquivalent<U1, U2>::value For instances u1 and u2 : are_units_quantity_equivalent(u1, u2) Are units point-equivalent? \u00b6 Result: Indicates whether two units are point-equivalent. This means that they have the same dimension, same magnitude, and same origin. QuantityPoint instances of point-equivalent units may be trivially converted to each other with no conversion factor and no additive offset. For example, while Celsius and Kelvins are quantity-equivalent, they are not point-equivalent . Syntax: For types U1 and U2 : AreUnitsPointEquivalent<U1, U2>::value For instances u1 and u2 : are_units_point_equivalent(u1, u2) Is dimensionless? \u00b6 Result: Indicates whether the argument is a dimensionless unit. Syntax: For type U : IsDimensionless<U>::value For instance u : is_dimensionless(u) Is unitless unit? \u00b6 Result: Indicates whether the argument is a \u201cunitless unit\u201d: that is, a dimensionless unit whose magnitude is 1. Syntax: For type U : IsUnitlessUnit<U>::value For instance u : is_unitless_unit(u) Unit ratio \u00b6 Result: The magnitude representing the ratio of the input units\u2019 magnitudes. For units with non-trivial dimension, there is no such thing as \u201cthe\u201d magnitude of a unit: it is not physically meaningful or observable. However, the ratio of units\u2019 magnitudes is well defined, and that is what this trait produces. For example, the unit ratio of Feet and Inches is mag<12>() , because a foot is 12 times as big as an inch. Syntax: For types U1 and U2 : UnitRatioT<U1, U2>::value For instances u1 and u2 : unit_ratio(u1, u2) Origin displacement \u00b6 Result: The displacement from the first unit\u2019s origin to the second unit\u2019s origin. Recall that there is no such thing as \u201cthe\u201d origin of a unit: it is not physically meaningful or observable. However, the displacement from one unit\u2019s origin to another is well defined, and that is what this trait produces. For example, the origin displacement from Kelvins to Celsius is equivalent to 273.15 \\,\\text{K} 273.15 \\,\\text{K} . Syntax: For types U1 and U2 : OriginDisplacement<U1, U2>::value() For instances u1 and u2 : origin_displacement(u1, u2) Associated unit \u00b6 TODO: this is a stub. Common unit \u00b6 TODO: this is a stub. Common point unit \u00b6 TODO: this is a stub. Unit types defined by the library may also use au::detail::StringConstant<N> for some integer length N . Since this is in the detail namespace, we wanted to de-emphasize it in this document. \u21a9","title":"Unit"},{"location":"reference/unit/#unit","text":"A unit is a type which represents a unit of measure. Examples include Meters , Radians , Hours , and so on. Users can work with units as either types or instances , and can freely convert between these representations. That is to say: units are monovalue types .","title":"Unit"},{"location":"reference/unit/#identifying-unit-types","text":"A unit is not forced to be a specialization of some central type template, such as a hypothetical Unit<...> . Rather, it\u2019s more open ended: a unit can be any type which fulfills certain defining properties. To be a unit, a type U : Must contain a public type alias, U::Dim , which refers to a valid dimension type . Must contain a public type alias, U::Mag , which refers to a valid magnitude type . Must be a monovalue type . May contain a static constexpr member named label , which is a C-style const char[] ( not a const char* ). 1 May contain a static constexpr member function origin() , which returns a quantity whose dimension type is U::Dim . A custom origin() is very rarely needed. Both labels and origins will be discussed further below.","title":"Identifying unit types"},{"location":"reference/unit/#making-unit-types","text":"Although every unit type needs Dim and Mag members, users won\u2019t need to add them directly. Rather, the best way to make a unit type is by combining existing unit types via supported operations . This approach has two key advantages relative to defining your unit as a fully manual struct . If your input types are all valid units, your output type will be too. It makes the definition more readable and physically meaningful. To give your unit type the best ergonomics, follow our how-to guide for defining new units .","title":"Making unit types"},{"location":"reference/unit/#labels","text":"Every unit has a label. Its label is a constexpr const char[] of the appropriate size. For a unit type U , or instance u , we can access the label as follows: unit_label<U>() unit_label(u) This function returns a reference to the array, which again is a compile time constant. Note especially that the type is an array ( [] ). A pointer ( * ) is not acceptable. This is so that we can support sizeof(unit_label(u)) . Using C-style char arrays for our labels makes Au more friendly for embedded users, because it gives them full access to the labels without forcing them to depend on <string> or <iostream> .","title":"Unit labels"},{"location":"reference/unit/#unlabeled_unit","text":"If a unit does not have an explicit label, we will try to generate one automatically. If we\u2019re unable to do so, we fall back to the \u201cdefault label\u201d, which is \"[UNLABELED_UNIT]\" . This is a label just like any other: we do not attempt to \u201cpropagate the un-labeled-ness\u201d. As a concrete example, if Foos is an unlabeled unit, then the label for Nano<Foos>{} / Seconds{} would be \"n[UNLABELED_UNIT] / s\" . This is to preserve as much structure as possible for end users, so they have the best chance of recognizing the offending unit, and perhaps upgrading it. Note A key design goal is for every combination of meaningfully labeled units, by every supported operation, to produce a meaningfully labeled unit. Right now, the only missing operation is scaling a unit by a magnitude. We are tracking this in #85 .","title":"[UNLABELED_UNIT]"},{"location":"reference/unit/#origins","text":"The \u201corigin\u201d of a unit is only useful for QuantityPoint , our affine space type . Even then, the origin by itself is not meaningful. Only the difference between the origins of two units is meaningful. You would use this to implement an \u201coffset\u201d unit, such as Celsius or Fahrenheit . However, note that both of these are already implemented in the library. The origin defaults to ZERO if not supplied.","title":"Unit origins"},{"location":"reference/unit/#types-for-combined-units","text":"A core tenet of Au\u2019s design philosophy is to avoid giving any units special status. Every named unit enters into a unit computation on equal footing. We will keep track of the accumulated powers of each named unit, cancelling as appropriate. The final form will follow these rules. Every power of a named unit will be represented according to the representation table . That is, it will be omitted if its power is zero, and will otherwise appear as one of Pow , RatioPow , or the bare unit itself. If only one named unit remains with nonzero power, then that named unit power (as represented in the previous rule) is the complete type. If multiple named units remain with nonzero power, then their representations (according to rule 1) are combined as the elements of a variadic UnitProduct<...> pack. Warning The ordering of the bases is deterministic, but is implementation defined, and can change at any time. It is a programming error to write code that assumes any specific ordering of the units in a pack. A few examples We have omitted the au:: namespace in the following examples for greater clarity. Unit expression Resulting unit type squared(Meters{}) Pow<Meters, 2> Meters{} / Seconds{} UnitProduct<Meters, Pow<Seconds, -1>> Seconds{} * Meters{} / Seconds{} Meters","title":"Types for combined units"},{"location":"reference/unit/#operations","text":"These are the operations which each unit type supports. Because a unit must be a monovalue type , it can take the form of either a type or an instance . In what follows, we\u2019ll use this convention: Capital identifiers ( U , U1 , U2 , \u2026) refer to types . Lowercase identifiers ( u , u1 , u2 , \u2026) refer to instances .","title":"Operations"},{"location":"reference/unit/#multiplication","text":"Result: The product of two units. Syntax: For types U1 and U2 : UnitProductT<U1, U2> For instances u1 and u2 : u1 * u2","title":"Multiplication"},{"location":"reference/unit/#division","text":"Result: The quotient of two units. Syntax: For types U1 and U2 : UnitQuotientT<U1, U2> For instances u1 and u2 : u1 / u2","title":"Division"},{"location":"reference/unit/#powers","text":"Result: A unit raised to an integral power. Syntax: For a type U , and an integral power N : UnitPowerT<U, N> For an instance u , and an integral power N : pow<N>(u)","title":"Powers"},{"location":"reference/unit/#roots","text":"Result: An integral root of a unit. Syntax: For a type U , and an integral root N : UnitPowerT<U, 1, N> (because the N^\\text{th} N^\\text{th} root is equivalent to the \\left(\\frac{1}{N}\\right)^\\text{th} \\left(\\frac{1}{N}\\right)^\\text{th} power) For an instance u , and an integral root N : root<N>(u)","title":"Roots"},{"location":"reference/unit/#helpers-for-powers-and-roots","text":"Note We plan to make these available for Magnitude and Dimension as well. See #84 to track progress. Each of the following helpers are available to operate on a unit instance, u : Helper Result inverse(u) pow<-1>(u) squared(u) pow<2>(u) cubed(u) pow<3>(u) sqrt(u) root<2>(u) cbrt(u) root<3>(u)","title":"Helpers for powers and roots"},{"location":"reference/unit/#scaling-by-magnitude","text":"Result: A new unit which has been scaled by the given magnitude. More specifically, for a unit instance u and magnitude instance m , this operation: Preserves the dimension of u . Scales the magnitude of u by a factor of m . Deletes the label of u . Preserves the origin of u . Syntax: u * m","title":"Scaling by Magnitude"},{"location":"reference/unit/#traits","text":"Sections describing bool traits will be indicated with a trailing question mark, \"?\" .","title":"Traits"},{"location":"reference/unit/#is-unit","text":"Result: Indicates whether the argument is a valid unit. Warning We don\u2019t currently have a trait that can detect whether or not a type is a monovalue type . Thus, the current implementation only checks whether the dimension and magnitude are valid. Until we get such a trait, authors of unit types are responsible for satisfying the monovalue type requirement. Syntax: For type U : IsUnit<U>::value For instance u : is_unit(u)","title":"Is unit?"},{"location":"reference/unit/#has-same-dimension","text":"Result: Indicates whether two units have the same dimension. Syntax: For types U1 and U2 : HasSameDimension<U1, U2>::value For instances u1 and u2 : has_same_dimension(u1, u2)","title":"Has same dimension?"},{"location":"reference/unit/#are-units-quantity-equivalent","text":"Result: Indicates whether two units are quantity-equivalent. This means that they have the same dimension and same magnitude. Quantities of quantity-equivalent units may be trivially converted to each other with no conversion factor. For example, Meters{} * Hertz{} is not the same unit as Meters{} / Seconds{} , but they are quantity-equivalent . Syntax: For types U1 and U2 : AreUnitsQuantityEquivalent<U1, U2>::value For instances u1 and u2 : are_units_quantity_equivalent(u1, u2)","title":"Are units quantity-equivalent?"},{"location":"reference/unit/#are-units-point-equivalent","text":"Result: Indicates whether two units are point-equivalent. This means that they have the same dimension, same magnitude, and same origin. QuantityPoint instances of point-equivalent units may be trivially converted to each other with no conversion factor and no additive offset. For example, while Celsius and Kelvins are quantity-equivalent, they are not point-equivalent . Syntax: For types U1 and U2 : AreUnitsPointEquivalent<U1, U2>::value For instances u1 and u2 : are_units_point_equivalent(u1, u2)","title":"Are units point-equivalent?"},{"location":"reference/unit/#is-dimensionless","text":"Result: Indicates whether the argument is a dimensionless unit. Syntax: For type U : IsDimensionless<U>::value For instance u : is_dimensionless(u)","title":"Is dimensionless?"},{"location":"reference/unit/#is-unitless-unit","text":"Result: Indicates whether the argument is a \u201cunitless unit\u201d: that is, a dimensionless unit whose magnitude is 1. Syntax: For type U : IsUnitlessUnit<U>::value For instance u : is_unitless_unit(u)","title":"Is unitless unit?"},{"location":"reference/unit/#unit-ratio","text":"Result: The magnitude representing the ratio of the input units\u2019 magnitudes. For units with non-trivial dimension, there is no such thing as \u201cthe\u201d magnitude of a unit: it is not physically meaningful or observable. However, the ratio of units\u2019 magnitudes is well defined, and that is what this trait produces. For example, the unit ratio of Feet and Inches is mag<12>() , because a foot is 12 times as big as an inch. Syntax: For types U1 and U2 : UnitRatioT<U1, U2>::value For instances u1 and u2 : unit_ratio(u1, u2)","title":"Unit ratio"},{"location":"reference/unit/#origin-displacement","text":"Result: The displacement from the first unit\u2019s origin to the second unit\u2019s origin. Recall that there is no such thing as \u201cthe\u201d origin of a unit: it is not physically meaningful or observable. However, the displacement from one unit\u2019s origin to another is well defined, and that is what this trait produces. For example, the origin displacement from Kelvins to Celsius is equivalent to 273.15 \\,\\text{K} 273.15 \\,\\text{K} . Syntax: For types U1 and U2 : OriginDisplacement<U1, U2>::value() For instances u1 and u2 : origin_displacement(u1, u2)","title":"Origin displacement"},{"location":"reference/unit/#associated-unit","text":"TODO: this is a stub.","title":"Associated unit"},{"location":"reference/unit/#common-unit","text":"TODO: this is a stub.","title":"Common unit"},{"location":"reference/unit/#common-point-unit","text":"TODO: this is a stub. Unit types defined by the library may also use au::detail::StringConstant<N> for some integer length N . Since this is in the detail namespace, we wanted to de-emphasize it in this document. \u21a9","title":"Common point unit"},{"location":"reference/detail/","text":"Implementation Details \u00b6 This section is for reference docs which most end users won\u2019t often encounter directly. We collect these docs in this subfolder to keep the main folder less cluttered. Here\u2019s a guide to the content: Dimensions . This is how we keep track of which units are mutually compatible, in the sense that they can be compared and converted with each other. Monovalue Types . This isn\u2019t a specific type in the library; rather, it\u2019s a \u201cconcept\u201d (loosely defined) 1 which many core library types model. Parameter Packs . The most critical foundation for the library is parameter packs , because this is how we implement the vector spaces which underpin dimensions , magnitudes , and compound units. We\u2019re using \u201cconcept\u201d in a loose, conceptual sense, rather than in the sense of the language element which was added in C++20. \u21a9","title":"Implementation Details"},{"location":"reference/detail/#implementation-details","text":"This section is for reference docs which most end users won\u2019t often encounter directly. We collect these docs in this subfolder to keep the main folder less cluttered. Here\u2019s a guide to the content: Dimensions . This is how we keep track of which units are mutually compatible, in the sense that they can be compared and converted with each other. Monovalue Types . This isn\u2019t a specific type in the library; rather, it\u2019s a \u201cconcept\u201d (loosely defined) 1 which many core library types model. Parameter Packs . The most critical foundation for the library is parameter packs , because this is how we implement the vector spaces which underpin dimensions , magnitudes , and compound units. We\u2019re using \u201cconcept\u201d in a loose, conceptual sense, rather than in the sense of the language element which was added in C++20. \u21a9","title":"Implementation Details"},{"location":"reference/detail/dimension/","text":"Dimension \u00b6 Dimension is a family of monovalue types representing equivalence classes of units. Each class defines a collection of units which can be meaningfully added, subtracted, and compared with each other. Familiar examples of Dimension include length, time, temperature, speed, and so on. Dimensions form a vector space . We choose certain \u201cbase dimensions\u201d as the basis vectors for this space. As with other vector spaces in our library, Dimension values can be multiplied, divided, and raised to (rational) powers, and this arithmetic always takes place at compile time. Dimension is an implementation detail. Most end users will never name dimensions in their code, and never see them in their compiler errors. Instead, users will work with units , which each carry their own dimension information. The main situation where an end user would use Dimension directly is to define the first unit for a novel base dimension. Included base dimensions \u00b6 Au includes the following base dimensions: Length Mass Time Current Temperature Angle Information AmountOfSubstance LuminousIntensity These comprise each of the seven base dimensions in the SI, with the addition of Angle and Information .","title":"Dimension"},{"location":"reference/detail/dimension/#dimension","text":"Dimension is a family of monovalue types representing equivalence classes of units. Each class defines a collection of units which can be meaningfully added, subtracted, and compared with each other. Familiar examples of Dimension include length, time, temperature, speed, and so on. Dimensions form a vector space . We choose certain \u201cbase dimensions\u201d as the basis vectors for this space. As with other vector spaces in our library, Dimension values can be multiplied, divided, and raised to (rational) powers, and this arithmetic always takes place at compile time. Dimension is an implementation detail. Most end users will never name dimensions in their code, and never see them in their compiler errors. Instead, users will work with units , which each carry their own dimension information. The main situation where an end user would use Dimension directly is to define the first unit for a novel base dimension.","title":"Dimension"},{"location":"reference/detail/dimension/#included-base-dimensions","text":"Au includes the following base dimensions: Length Mass Time Current Temperature Angle Information AmountOfSubstance LuminousIntensity These comprise each of the seven base dimensions in the SI, with the addition of Angle and Information .","title":"Included base dimensions"},{"location":"reference/detail/monovalue_types/","text":"Monovalue Types \u00b6 A \u201cmonovalue type\u201d is a type which can only hold a single value. This means that knowing the type is equivalent to knowing the value, and vice versa. We can convert back and forth between representing it as a type, and as a value, depending on our needs. We named this concept because it occurs again and again in Au, and the name makes it easier to refer to. The \u201cmonovalue\u201d name is based on std::monostate , which has these properties. However, \u201cmonostate\u201d could have been confused with the monostate pattern , which exposes actual, changeable, global state to its users. \u201cMonovalue\u201d also emphasizes value semantics , which is a core property of these types. Identifying monovalue types \u00b6 A type T is a monovalue type when it fulfills these conditions. T can be instantiated. Every instance of T behaves identically to every other instance, in every way, and this behavior does not depend on any program state. Instances of T support some set of operations with other types. These properties mean we can freely convert a monovalue object between its \u201ctype\u201d and \u201cvalue\u201d representations. This is a core feature of monovalue types. The second property also distinguishes monovalue types from the monostate pattern mentioned above. The third property means there has to be something you can do with the instances. Examples of monovalue types \u00b6 Here are some canonical examples in Au. Type Instance Example Operations Zero ZERO Comparing to any Quantity Magnitude<> ONE Equality comparison with other Magnitudes get_value<T>(ONE) Magnitude<Pi> PI Equality comparison with other Magnitudes get_value<T>(PI) Radians (and other units) Radians{} (no special pre-formed instance) Arithmetic with other units, such as Radians{} / Meters{} Switching between types and values \u00b6 To get the value of a monovalue type T , instantiate the type using T{} . To get the type of a monovalue type value t , pass it to decltype(t) . However, if t is const (including constexpr ), you\u2019ll need to use std::decay_t<decltype(t)> . More details on when to use std::decay_t It\u2019s common to provide constexpr instances of monovalue types, like the following. static constexpr auto ZERO = Zero {}; In this case, decltype(ZERO) would be const Zero , not simply Zero . If we tried comparing this to Zero in a type trait, it could fail. Using std::decay_t is a concise way to avoid this problem. However, it only arises for const or constexpr instances \u2014 and only when comparing types for exact equality \u2014 so most users won\u2019t need to worry about this most of the time. This diagram summarizes how to go back and forth using {} and decltype() . flowchart LR subgraph \"#quot;Realm of Types#quot;\" Type end subgraph \"#quot;Realm of Instances#quot;\" value end Type -->|\"auto value =<br>Type{}\"| value -->|\"using Type =<br>decltype(value)\"| Type","title":"Monovalue Types"},{"location":"reference/detail/monovalue_types/#monovalue-types","text":"A \u201cmonovalue type\u201d is a type which can only hold a single value. This means that knowing the type is equivalent to knowing the value, and vice versa. We can convert back and forth between representing it as a type, and as a value, depending on our needs. We named this concept because it occurs again and again in Au, and the name makes it easier to refer to. The \u201cmonovalue\u201d name is based on std::monostate , which has these properties. However, \u201cmonostate\u201d could have been confused with the monostate pattern , which exposes actual, changeable, global state to its users. \u201cMonovalue\u201d also emphasizes value semantics , which is a core property of these types.","title":"Monovalue Types"},{"location":"reference/detail/monovalue_types/#identifying-monovalue-types","text":"A type T is a monovalue type when it fulfills these conditions. T can be instantiated. Every instance of T behaves identically to every other instance, in every way, and this behavior does not depend on any program state. Instances of T support some set of operations with other types. These properties mean we can freely convert a monovalue object between its \u201ctype\u201d and \u201cvalue\u201d representations. This is a core feature of monovalue types. The second property also distinguishes monovalue types from the monostate pattern mentioned above. The third property means there has to be something you can do with the instances.","title":"Identifying monovalue types"},{"location":"reference/detail/monovalue_types/#examples-of-monovalue-types","text":"Here are some canonical examples in Au. Type Instance Example Operations Zero ZERO Comparing to any Quantity Magnitude<> ONE Equality comparison with other Magnitudes get_value<T>(ONE) Magnitude<Pi> PI Equality comparison with other Magnitudes get_value<T>(PI) Radians (and other units) Radians{} (no special pre-formed instance) Arithmetic with other units, such as Radians{} / Meters{}","title":"Examples of monovalue types"},{"location":"reference/detail/monovalue_types/#switching-between-types-and-values","text":"To get the value of a monovalue type T , instantiate the type using T{} . To get the type of a monovalue type value t , pass it to decltype(t) . However, if t is const (including constexpr ), you\u2019ll need to use std::decay_t<decltype(t)> . More details on when to use std::decay_t It\u2019s common to provide constexpr instances of monovalue types, like the following. static constexpr auto ZERO = Zero {}; In this case, decltype(ZERO) would be const Zero , not simply Zero . If we tried comparing this to Zero in a type trait, it could fail. Using std::decay_t is a concise way to avoid this problem. However, it only arises for const or constexpr instances \u2014 and only when comparing types for exact equality \u2014 so most users won\u2019t need to worry about this most of the time. This diagram summarizes how to go back and forth using {} and decltype() . flowchart LR subgraph \"#quot;Realm of Types#quot;\" Type end subgraph \"#quot;Realm of Instances#quot;\" value end Type -->|\"auto value =<br>Type{}\"| value -->|\"using Type =<br>decltype(value)\"| Type","title":"Switching between types and values"},{"location":"reference/detail/packs/","text":"Parameter packs \u00b6 Products of base powers are the foundation for the Au library. We use them for: The Dimension of a Unit. The Magnitude of a Unit. Making compound Units (products of powers of units, e.g., \\text{m} \\cdot \\text{s}^{-2} \\text{m} \\cdot \\text{s}^{-2} ). We represent them as variadic parameter packs. Each pack element represents a \u201cbase power\u201d: this is some \u201cbase\u201d, raised to some rational exponent. For a base power BP , BaseT<BP> retrieves its base, and ExpT<BP> retrieves its exponent (as a std::ratio ). Note This approach, with products of base powers, is known as the vector space representation for Dimensions, Magnitudes, and so on. The //au:packs target, which this page describes, is our tool for implementing these vector spaces robustly. Representing powers \u00b6 These packs show up in compiler errors, and we want those errors to be as friendly as possible. Clutter is our enemy! Thus, we canonicalize each base power to its simplest form. Consider an arbitrary base type, B ; here is how it shows up in the pack: This power of B B \u2026 \u2026shows up in a pack as: B ^ 0 B ^ 0 (omitted) B ^ 1 B ^ 1 B B ^ N B ^ N , with N N any other integer Pow<B, N> B^{ N / D } B^{ N / D } , with D > 1 D > 1 RatioPow<B, N, D> Canonicalizing in this way keeps our compiler errors more concise and readable. Strict total ordering \u00b6 The above canonicalization tells us what items to store. We also need to be careful about which order to store them in. We are modeling multiplication, and in our applications, (A \\times B) (A \\times B) is always the same as (B \\times A) (B \\times A) . However, Pack<A, B> is not the same type as Pack<B, A> ! Thus, we are going to need a way to define whether A or B should come first inside of a Pack . What we need is a strict total ordering , which applies to all types which might represent a Base in a given kind of Pack. This is a critical foundational concept for the library, so we use explicit traits for each kind of pack. There are two main elements to this API: InOrderFor<Pack, A, B> is for generic algorithms . It\u2019s how we check whether A and B are in the right order for Pack . LexicographicTotalOrdering<A, B, Orderings...> is for implementing InOrderFor for a given Pack . It\u2019s how we define whether A and B are in order for Pack . The point in using LexicographicTotalOrdering is that it guards against the most common failure mode in our application: namely, two distinct types which compare as equivalent . LexicographicTotalOrdering tries A and B against every comparator in Orderings... , in sequence. If any comparator knows how to order A and B , we use it. If we run out of comparators, but A is not the same as B , then we produce a hard error. The fix is to add a new comparator to \u201cbreak the tie\u201d. Example: defining the ordering for a Pack Suppose we have a particular pack, Pack , and our bases are std::ratio instances. We need to define some canonical ordering. Let\u2019s say that we want to order first by denominator\u2014integers first, then halves, thirds, etc\u2014and then by numerator. We can define traits for those orderings, and then combine those traits using LexicographicTotalOrdering to implement InOrderFor<Pack, ...> . Specifically: template < typename A , typename B > struct OrderByDenom : stdx :: bool_constant < ( A :: den < B :: den ) > {}; template < typename A , typename B > struct OrderByNum : stdx :: bool_constant < ( A :: num < B :: num ) > {}; template < typename A , typename B > struct InOrderFor < Pack , A , B > : LexicographicTotalOrdering < A , B , OrderByDenom , OrderByNum > {}; With this definition, something like Pack<std::ratio<-1>, std::ratio<8>, std::ratio<1, 2>> would be in-order . Validation \u00b6 We validate packs using type traits. IsValidPack<Pack, T> is the \u201coverall\u201d validator. It verifies that T is an instance of Pack<...> , and that its parameters satisfy the necessary conditions. Specifically, those conditions are: AreBasesInOrder<Pack, T> : assuming T is Pack<BPs...> , verifies that all consecutive elements in BaseT<BPs>... are all properly ordered (according to InOrderFor<Pack, ...> , naturally). AreAllPowersNonzero<Pack, T> : assuming T is Pack<BPs...> , verifies that Exp<BPs>::num is nonzero for every element in BPs . Algebra on Packs \u00b6 The whole reason we built //au:packs was to support exact symbolic algebra for two operations: products , and rational powers . This section explains how we do that. Our strategy is: The //au:packs target provides generic versions of these operations that are pre-built, but cumbersome . (What makes them cumbersome? They need an extra parameter to specify which Pack they operate on. This is much like InOrderFor , which defines the ordering for a specific type of Pack .) Client targets provide aliases which \u201chide\u201d the extra parameter (because they know what value it should take!). Let\u2019s take the \u201cpack product\u201d operation as an example, using Dimension as our Pack: // The `//au:packs` library provides this: template < template < class ... > typename Pack , typename ... Ts > using PackProductT = /* (implementation; irrelevant here) */ ; // A _particular_ Pack (say, `Dimension`) would expose it to their users like this: template < typename ... Dims > using DimProductT = PackProductT < Dimension , Dims ... > ; // End users would use the _latter_, e.g.: using Length = DimProductT < Speed , Time > ; Supported algebraic operations \u00b6 Here are the operations we support: PackProductT<Pack, Ps...> : the product of arbitrarily many (0 or more) Pack<...> instances, Ps... . PackQuotientT<Pack, P1, P2> : the quotient P1 / P2 . PackPowerT<Pack, P, N, D=1> : raise the Pack P to the rational power N / D . PackInverseT<Pack, P> : the Pack that gives the null pack when multiplied with the Pack P .","title":"Parameter packs"},{"location":"reference/detail/packs/#parameter-packs","text":"Products of base powers are the foundation for the Au library. We use them for: The Dimension of a Unit. The Magnitude of a Unit. Making compound Units (products of powers of units, e.g., \\text{m} \\cdot \\text{s}^{-2} \\text{m} \\cdot \\text{s}^{-2} ). We represent them as variadic parameter packs. Each pack element represents a \u201cbase power\u201d: this is some \u201cbase\u201d, raised to some rational exponent. For a base power BP , BaseT<BP> retrieves its base, and ExpT<BP> retrieves its exponent (as a std::ratio ). Note This approach, with products of base powers, is known as the vector space representation for Dimensions, Magnitudes, and so on. The //au:packs target, which this page describes, is our tool for implementing these vector spaces robustly.","title":"Parameter packs"},{"location":"reference/detail/packs/#powers","text":"These packs show up in compiler errors, and we want those errors to be as friendly as possible. Clutter is our enemy! Thus, we canonicalize each base power to its simplest form. Consider an arbitrary base type, B ; here is how it shows up in the pack: This power of B B \u2026 \u2026shows up in a pack as: B ^ 0 B ^ 0 (omitted) B ^ 1 B ^ 1 B B ^ N B ^ N , with N N any other integer Pow<B, N> B^{ N / D } B^{ N / D } , with D > 1 D > 1 RatioPow<B, N, D> Canonicalizing in this way keeps our compiler errors more concise and readable.","title":"Representing powers"},{"location":"reference/detail/packs/#strict-total-ordering","text":"The above canonicalization tells us what items to store. We also need to be careful about which order to store them in. We are modeling multiplication, and in our applications, (A \\times B) (A \\times B) is always the same as (B \\times A) (B \\times A) . However, Pack<A, B> is not the same type as Pack<B, A> ! Thus, we are going to need a way to define whether A or B should come first inside of a Pack . What we need is a strict total ordering , which applies to all types which might represent a Base in a given kind of Pack. This is a critical foundational concept for the library, so we use explicit traits for each kind of pack. There are two main elements to this API: InOrderFor<Pack, A, B> is for generic algorithms . It\u2019s how we check whether A and B are in the right order for Pack . LexicographicTotalOrdering<A, B, Orderings...> is for implementing InOrderFor for a given Pack . It\u2019s how we define whether A and B are in order for Pack . The point in using LexicographicTotalOrdering is that it guards against the most common failure mode in our application: namely, two distinct types which compare as equivalent . LexicographicTotalOrdering tries A and B against every comparator in Orderings... , in sequence. If any comparator knows how to order A and B , we use it. If we run out of comparators, but A is not the same as B , then we produce a hard error. The fix is to add a new comparator to \u201cbreak the tie\u201d. Example: defining the ordering for a Pack Suppose we have a particular pack, Pack , and our bases are std::ratio instances. We need to define some canonical ordering. Let\u2019s say that we want to order first by denominator\u2014integers first, then halves, thirds, etc\u2014and then by numerator. We can define traits for those orderings, and then combine those traits using LexicographicTotalOrdering to implement InOrderFor<Pack, ...> . Specifically: template < typename A , typename B > struct OrderByDenom : stdx :: bool_constant < ( A :: den < B :: den ) > {}; template < typename A , typename B > struct OrderByNum : stdx :: bool_constant < ( A :: num < B :: num ) > {}; template < typename A , typename B > struct InOrderFor < Pack , A , B > : LexicographicTotalOrdering < A , B , OrderByDenom , OrderByNum > {}; With this definition, something like Pack<std::ratio<-1>, std::ratio<8>, std::ratio<1, 2>> would be in-order .","title":"Strict total ordering"},{"location":"reference/detail/packs/#validation","text":"We validate packs using type traits. IsValidPack<Pack, T> is the \u201coverall\u201d validator. It verifies that T is an instance of Pack<...> , and that its parameters satisfy the necessary conditions. Specifically, those conditions are: AreBasesInOrder<Pack, T> : assuming T is Pack<BPs...> , verifies that all consecutive elements in BaseT<BPs>... are all properly ordered (according to InOrderFor<Pack, ...> , naturally). AreAllPowersNonzero<Pack, T> : assuming T is Pack<BPs...> , verifies that Exp<BPs>::num is nonzero for every element in BPs .","title":"Validation"},{"location":"reference/detail/packs/#algebra-on-packs","text":"The whole reason we built //au:packs was to support exact symbolic algebra for two operations: products , and rational powers . This section explains how we do that. Our strategy is: The //au:packs target provides generic versions of these operations that are pre-built, but cumbersome . (What makes them cumbersome? They need an extra parameter to specify which Pack they operate on. This is much like InOrderFor , which defines the ordering for a specific type of Pack .) Client targets provide aliases which \u201chide\u201d the extra parameter (because they know what value it should take!). Let\u2019s take the \u201cpack product\u201d operation as an example, using Dimension as our Pack: // The `//au:packs` library provides this: template < template < class ... > typename Pack , typename ... Ts > using PackProductT = /* (implementation; irrelevant here) */ ; // A _particular_ Pack (say, `Dimension`) would expose it to their users like this: template < typename ... Dims > using DimProductT = PackProductT < Dimension , Dims ... > ; // End users would use the _latter_, e.g.: using Length = DimProductT < Speed , Time > ;","title":"Algebra on Packs"},{"location":"reference/detail/packs/#supported-algebraic-operations","text":"Here are the operations we support: PackProductT<Pack, Ps...> : the product of arbitrarily many (0 or more) Pack<...> instances, Ps... . PackQuotientT<Pack, P1, P2> : the quotient P1 / P2 . PackPowerT<Pack, P, N, D=1> : raise the Pack P to the rational power N / D . PackInverseT<Pack, P> : the Pack that gives the null pack when multiplied with the Pack P .","title":"Supported algebraic operations"},{"location":"tutorial/","text":"Tutorials: home \u00b6 Taking the time to understand the basic usage of the library is a wise investment. We\u2019ve tried to make that as easy as possible with these tutorials. We recommend starting from the beginning, and working your way through. Each tutorial includes an explanatory discussion, and is followed by an interactive exercise to help build your skills. 100-level courses \u00b6 These courses should be all you need to become proficient in day-to-day usage of the library. You\u2019ll learn how to store values safely inside a quantity; how to name types to make your interfaces safer; how to perform unit conversions; and how to work effectively with the included math functions (forthcoming) . Au 101: Quantity Makers Au 102: API Types Au 103: Unit Conversions","title":"Tutorials: home"},{"location":"tutorial/#tutorials-home","text":"Taking the time to understand the basic usage of the library is a wise investment. We\u2019ve tried to make that as easy as possible with these tutorials. We recommend starting from the beginning, and working your way through. Each tutorial includes an explanatory discussion, and is followed by an interactive exercise to help build your skills.","title":"Tutorials: home"},{"location":"tutorial/#100-level-courses","text":"These courses should be all you need to become proficient in day-to-day usage of the library. You\u2019ll learn how to store values safely inside a quantity; how to name types to make your interfaces safer; how to perform unit conversions; and how to work effectively with the included math functions (forthcoming) . Au 101: Quantity Makers Au 102: API Types Au 103: Unit Conversions","title":"100-level courses"},{"location":"tutorial/101-quantity-makers/","text":"Au 101: Quantity Makers \u00b6 This tutorial gives a gentle introduction to the Au library. Time: TBD. Prerequisites: Experience writing C++ code. You will learn: The concept and importance of \u201cunit safety\u201d. How to store a numeric value in a quantity . How to retrieve the stored numeric value. Some basic operations you can perform with a quantity. Status quo: no units library \u00b6 Suppose you have a variable that represents a physical quantity . That variable has some value , but that value is meaningless unless you also know the unit of measurement . We usually indicate the unit with a suffix on the variable name. Here\u2019s a concrete example: const double track_length_m = 100.0 ; // Unit suffix--^^ ^^^^^--Value const double best_time_s = 10.34 ; // Unit suffix--^^ ^^^^^--Value The first value is 100.0 . Since there\u2019s no such thing as a \u201clength of 100\u201d, we add a _m suffix on the end of our variable name to make it clear that the value is the length in meters . We take a similar approach for our time in seconds . This strategy works , in the sense that it can prevent unit errors, but it\u2019s labor intensive and error prone. The naming suffixes provide hints, but enforcement is basically on the honor system. Consider a function we might want to call: double average_speed_mps ( double length_m , double time_s ); With the above variables, our callsite might look like this: const auto speed_mps = average_speed_mps ( track_length_m , best_time_s ); It\u2019s time to consider a very important property: Definition Unit correctness: a program is unit-correct when every variable associated with physical units is used consistently with those units. So: is this unit-correct? Yes: track_length_m gets passed as the parameter length_m : meters to meters best_time_s gets passed as the parameter time_s : seconds to seconds However, it\u2019s quite fragile. We could just as easily have written the following. const auto speed_mps = average_speed_mps ( best_time_s , track_length_m ); By itself, this line looks correct: we\u2019re asking for an average speed, given a time and a length. We can even see that we\u2019re passing in values in seconds and meters to get a result in meters-per-second, increasing our confidence! Of course, the line is wrong, but the only way to know that it\u2019s wrong is to go read the declaration of average_speed_mps . This could easily be in some other file. In a big project, it might be hard to even figure out which file it\u2019s in. That\u2019s a lot of cognitive load! Our goal: unit safety \u00b6 To write code quickly and robustly, unit-correctness is not enough . We need more: we need unit safety . Definition Unit safety : We call a program unit-safe when the unit-correctness of each line of code can be checked by inspection , in isolation . This is the way to reduce cognitive load for code readers, when it comes to physical units. If you inspect a unit-safe line, and see that it\u2019s correct, then you\u2019re done with that line. You can move on; you don\u2019t have to hold it in your head. Tip A unit-safe line doesn\u2019t guarantee that the program has no unit errors. It does guarantee that if there are unit errors, then they\u2019re in some other line (which you can also inspect!). Unit-safety is not something you could ever get from the standard numeric types, but you can get it from the Au library. Let\u2019s learn how! Storing values: the \u201cquantity maker\u201d \u00b6 The way to achieve unit-safety is by turning our raw numeric values into quantities . We do this with quantity makers . These are callables\u2014things that act like functions\u2014which have the name of some unit , and accept any numeric type . For example, let\u2019s make our variable track_length_m unit-safe by using the quantity maker, meters : const auto track_length = meters ( track_length_m ); // ^^^^^^ ^^ // Quantity maker of *meters* Takes value in *meters* This is an example of a unit-safe handoff . We take a raw number whose name tells us it was in meters, and we pass it to the quantity maker for that same unit . We can see this line is unit-correct simply by inspection\u2014our first example of a unit-safe line. In fact, we have already achieved unit safety everywhere we use the quantity track_length instead of the raw number track_length_m ! Think of the quantity as a container , which holds its value securely together with information about its unit. We\u2019ll see that the quantity prevents us from using that value in ways that are incompatible with its unit. Retrieving values: you must name the unit \u00b6 Ideally, every interface that takes physical quantities would use unit-safe quantity types . In practice, you can\u2019t upgrade your entire codebase at once. Even if you could, there will always be third-party libraries which don\u2019t know about these quantity types. One way or another, it\u2019s important to be able to get the value out. Let\u2019s imagine we have this example third-party API, which needs a raw double . How can we call it if we have a quantity? // Example third-party API. class Racetrack ; class RacetrackBuilder { public : // Main function we'll call: void set_length_m ( double length_m ); Racetrack build_track (); }; Most units libraries provide a function that retrieves a quantity\u2019s value \u201cin whatever units it happens to be stored\u201d. (Think of std::chrono::duration::count() as a very common example.) These kinds of functions may be convenient, but they\u2019re not unit-safe. 1 Au takes a different approach. To retrieve the value from a quantity q , you call q.in(units) , where units is the quantity maker you used to store the value. Continuing with our earlier example, we could call that API like so: RacetrackBuilder builder ; builder . set_length_m ( track_length . in ( meters )); // ^^ ^^^^^^^^^^^ // API wants length in *meters* Get value in *meters* Here, we have another unit-safe handoff . Our first one showed how we enter the library by naming the unit. This one shows how we exit the library by naming that same unit. Tip Think of the quantity maker\u2019s name as a kind of \u201cpassword\u201d which you set when you create the quantity. The quantity will hold its underlying value securely. To retrieve that value, you must speak the same \u201cpassword\u201d (that is, name the same unit). Of course, this API is a best-case scenario for raw numeric APIs, since it names the units at the callsite (via the _m suffix on set_length_m() ). Our other API, average_speed_mps() , can\u2019t do this, because we can\u2019t see the parameter names at the callsite. In fact, although we\u2019ll see some coping strategies in later lessons, there is no unit-safe way to call average_speed_mps() directly . Basic quantity operations \u00b6 Quantity types do much more than simply hold their values securely: they support a variety of operations. In fact, we strive to support every meaningful operation, because operation implementations for quantity types can faithfully maintain unit safety. Tip Treat any instance of retrieving the value as \u201ccode smell\u201d. Stop and check whether there\u2019s some way to perform the operation within the quantity type. If there\u2019s not, stop and consider whether there should be. By \u201ccode smell\u201d, we don\u2019t mean that it\u2019s definitely wrong; in fact, it\u2019s often necessary. We just mean it\u2019s worth checking to see if there\u2019s a better pattern. The first and most basic operations which we\u2019ll cover here are arithmetic operations. You can add, subtract, and compare quantities of the same units. 2 You can multiply and divide quantities of any units. Example: same-unit operations Here are a couple examples of operations among quantities with the same unit . constexpr auto distance = meters ( 1.0 ) + meters ( 2.0 ); // distance -> meters(3.0) constexpr auto is_duration_greater = ( seconds ( 60 ) > seconds ( 55 )); // is_duration_greater -> true Admittedly, these examples are very basic for now. Future lessons will explore more interesting examples\u2014like, what happens when you compare a length in inches, to a length in centimeters? But for now, the takeaway is simply that we neither need nor want to extract underlying values to perform basic operations. Multiplying and dividing quantities \u00b6 The product of two quantities is another quantity. Recall that a quantity variable has two parts: the unit , and the value . These parts compose nicely with multiplication. The unit of the product is the product of the units. The value of the product is the product of the values. All of these same considerations apply to division. So for example: (meters / second) is a quantity maker. You can call it and pass any numerical type, just as with the quantity makers meters or seconds . In particular, meters ( 50.0 ) / seconds ( 10.0 ) == ( meters / second )( 5.0 ); Tip To form a compound quantity maker, use the grammatically correct name of the unit. Examples: meters / second , not meters / seconds newton * meters , not newtons * meters Empirically, we have found that this pattern works: (s * ...) * p / (s * ...) . That is: pluralize only one token for singular tokens: put those which multiply on the left , and those which divide on the right . Exercise: computing with quantities \u00b6 To get some practice with quantities, we\u2019ve included an exercise where you can make and print some quantities, and then upgrade an existing function implementation from raw numbers to quantities. Check out the Au 101: API Types Exercise ! Takeaways \u00b6 We strive for unit safety . If we can check the unit-correctness of every individual line of code, by inspection, in isolation, we can reduce cognitive load, and write code faster and more robustly. To store a raw numeric value safely inside of a quantity object, call the quantity maker whose name is the unit of interest. For example, meters(3) is quantity representing 3\\,\\text{m} 3\\,\\text{m} , stored as int . To retrieve a stored numeric value from a quantity q , call q.in(units) , where units was the quantity maker used in the first place. For example, meters(3).in(meters) is simply 3 . Quantity makers compose : you can multiply, divide, and raise them to powers to get a new quantity maker. For example, (meters / second) is a quantity maker which you can call like any other. (meters / second)(5) represents the quantity 5\\,\\text{m/s} 5\\,\\text{m/s} . Tip Au only contains unit-safe interfaces. That\u2019s why simply storing the value in a quantity is enough to achieve unit-safety! To take the example from std::chrono::duration , note that the system clock has different resolutions on different widely used toolchains . gcc uses 1\\,\\text{ns} 1\\,\\text{ns} , MSVC uses 100\\,\\text{ns} 100\\,\\text{ns} , and clang uses 1000\\,\\text{ns} 1000\\,\\text{ns} . So if you subtracted two calls to std::chrono::system_clock::now() and called .count() , your answers would vary by 3 orders of magnitude on different compilers! This is not to say that doing so would be a good use of the chrono library. It\u2019s not, and that\u2019s the point: a bare call to .count() gives the reader no idea how to interpret its result. \u21a9 What about adding, subtracting, and comparing quantities of different units, but the same dimensions\u2014like comparing seconds(100) to minutes(1) , or adding inches(1) to feet(6) ? In most cases, we do support this as well, but it\u2019s a more advanced usage which we\u2019ll discuss further in future lessons. \u21a9","title":"Au 101: Quantity Makers"},{"location":"tutorial/101-quantity-makers/#au-101-quantity-makers","text":"This tutorial gives a gentle introduction to the Au library. Time: TBD. Prerequisites: Experience writing C++ code. You will learn: The concept and importance of \u201cunit safety\u201d. How to store a numeric value in a quantity . How to retrieve the stored numeric value. Some basic operations you can perform with a quantity.","title":"Au 101: Quantity Makers"},{"location":"tutorial/101-quantity-makers/#status-quo-no-units-library","text":"Suppose you have a variable that represents a physical quantity . That variable has some value , but that value is meaningless unless you also know the unit of measurement . We usually indicate the unit with a suffix on the variable name. Here\u2019s a concrete example: const double track_length_m = 100.0 ; // Unit suffix--^^ ^^^^^--Value const double best_time_s = 10.34 ; // Unit suffix--^^ ^^^^^--Value The first value is 100.0 . Since there\u2019s no such thing as a \u201clength of 100\u201d, we add a _m suffix on the end of our variable name to make it clear that the value is the length in meters . We take a similar approach for our time in seconds . This strategy works , in the sense that it can prevent unit errors, but it\u2019s labor intensive and error prone. The naming suffixes provide hints, but enforcement is basically on the honor system. Consider a function we might want to call: double average_speed_mps ( double length_m , double time_s ); With the above variables, our callsite might look like this: const auto speed_mps = average_speed_mps ( track_length_m , best_time_s ); It\u2019s time to consider a very important property: Definition Unit correctness: a program is unit-correct when every variable associated with physical units is used consistently with those units. So: is this unit-correct? Yes: track_length_m gets passed as the parameter length_m : meters to meters best_time_s gets passed as the parameter time_s : seconds to seconds However, it\u2019s quite fragile. We could just as easily have written the following. const auto speed_mps = average_speed_mps ( best_time_s , track_length_m ); By itself, this line looks correct: we\u2019re asking for an average speed, given a time and a length. We can even see that we\u2019re passing in values in seconds and meters to get a result in meters-per-second, increasing our confidence! Of course, the line is wrong, but the only way to know that it\u2019s wrong is to go read the declaration of average_speed_mps . This could easily be in some other file. In a big project, it might be hard to even figure out which file it\u2019s in. That\u2019s a lot of cognitive load!","title":"Status quo: no units library"},{"location":"tutorial/101-quantity-makers/#our-goal-unit-safety","text":"To write code quickly and robustly, unit-correctness is not enough . We need more: we need unit safety . Definition Unit safety : We call a program unit-safe when the unit-correctness of each line of code can be checked by inspection , in isolation . This is the way to reduce cognitive load for code readers, when it comes to physical units. If you inspect a unit-safe line, and see that it\u2019s correct, then you\u2019re done with that line. You can move on; you don\u2019t have to hold it in your head. Tip A unit-safe line doesn\u2019t guarantee that the program has no unit errors. It does guarantee that if there are unit errors, then they\u2019re in some other line (which you can also inspect!). Unit-safety is not something you could ever get from the standard numeric types, but you can get it from the Au library. Let\u2019s learn how!","title":"Our goal: unit safety"},{"location":"tutorial/101-quantity-makers/#storing-values-the-quantity-maker","text":"The way to achieve unit-safety is by turning our raw numeric values into quantities . We do this with quantity makers . These are callables\u2014things that act like functions\u2014which have the name of some unit , and accept any numeric type . For example, let\u2019s make our variable track_length_m unit-safe by using the quantity maker, meters : const auto track_length = meters ( track_length_m ); // ^^^^^^ ^^ // Quantity maker of *meters* Takes value in *meters* This is an example of a unit-safe handoff . We take a raw number whose name tells us it was in meters, and we pass it to the quantity maker for that same unit . We can see this line is unit-correct simply by inspection\u2014our first example of a unit-safe line. In fact, we have already achieved unit safety everywhere we use the quantity track_length instead of the raw number track_length_m ! Think of the quantity as a container , which holds its value securely together with information about its unit. We\u2019ll see that the quantity prevents us from using that value in ways that are incompatible with its unit.","title":"Storing values: the \"quantity maker\""},{"location":"tutorial/101-quantity-makers/#retrieving-values-you-must-name-the-unit","text":"Ideally, every interface that takes physical quantities would use unit-safe quantity types . In practice, you can\u2019t upgrade your entire codebase at once. Even if you could, there will always be third-party libraries which don\u2019t know about these quantity types. One way or another, it\u2019s important to be able to get the value out. Let\u2019s imagine we have this example third-party API, which needs a raw double . How can we call it if we have a quantity? // Example third-party API. class Racetrack ; class RacetrackBuilder { public : // Main function we'll call: void set_length_m ( double length_m ); Racetrack build_track (); }; Most units libraries provide a function that retrieves a quantity\u2019s value \u201cin whatever units it happens to be stored\u201d. (Think of std::chrono::duration::count() as a very common example.) These kinds of functions may be convenient, but they\u2019re not unit-safe. 1 Au takes a different approach. To retrieve the value from a quantity q , you call q.in(units) , where units is the quantity maker you used to store the value. Continuing with our earlier example, we could call that API like so: RacetrackBuilder builder ; builder . set_length_m ( track_length . in ( meters )); // ^^ ^^^^^^^^^^^ // API wants length in *meters* Get value in *meters* Here, we have another unit-safe handoff . Our first one showed how we enter the library by naming the unit. This one shows how we exit the library by naming that same unit. Tip Think of the quantity maker\u2019s name as a kind of \u201cpassword\u201d which you set when you create the quantity. The quantity will hold its underlying value securely. To retrieve that value, you must speak the same \u201cpassword\u201d (that is, name the same unit). Of course, this API is a best-case scenario for raw numeric APIs, since it names the units at the callsite (via the _m suffix on set_length_m() ). Our other API, average_speed_mps() , can\u2019t do this, because we can\u2019t see the parameter names at the callsite. In fact, although we\u2019ll see some coping strategies in later lessons, there is no unit-safe way to call average_speed_mps() directly .","title":"Retrieving values: you must name the unit"},{"location":"tutorial/101-quantity-makers/#basic-quantity-operations","text":"Quantity types do much more than simply hold their values securely: they support a variety of operations. In fact, we strive to support every meaningful operation, because operation implementations for quantity types can faithfully maintain unit safety. Tip Treat any instance of retrieving the value as \u201ccode smell\u201d. Stop and check whether there\u2019s some way to perform the operation within the quantity type. If there\u2019s not, stop and consider whether there should be. By \u201ccode smell\u201d, we don\u2019t mean that it\u2019s definitely wrong; in fact, it\u2019s often necessary. We just mean it\u2019s worth checking to see if there\u2019s a better pattern. The first and most basic operations which we\u2019ll cover here are arithmetic operations. You can add, subtract, and compare quantities of the same units. 2 You can multiply and divide quantities of any units. Example: same-unit operations Here are a couple examples of operations among quantities with the same unit . constexpr auto distance = meters ( 1.0 ) + meters ( 2.0 ); // distance -> meters(3.0) constexpr auto is_duration_greater = ( seconds ( 60 ) > seconds ( 55 )); // is_duration_greater -> true Admittedly, these examples are very basic for now. Future lessons will explore more interesting examples\u2014like, what happens when you compare a length in inches, to a length in centimeters? But for now, the takeaway is simply that we neither need nor want to extract underlying values to perform basic operations.","title":"Basic quantity operations"},{"location":"tutorial/101-quantity-makers/#multiplying-and-dividing-quantities","text":"The product of two quantities is another quantity. Recall that a quantity variable has two parts: the unit , and the value . These parts compose nicely with multiplication. The unit of the product is the product of the units. The value of the product is the product of the values. All of these same considerations apply to division. So for example: (meters / second) is a quantity maker. You can call it and pass any numerical type, just as with the quantity makers meters or seconds . In particular, meters ( 50.0 ) / seconds ( 10.0 ) == ( meters / second )( 5.0 ); Tip To form a compound quantity maker, use the grammatically correct name of the unit. Examples: meters / second , not meters / seconds newton * meters , not newtons * meters Empirically, we have found that this pattern works: (s * ...) * p / (s * ...) . That is: pluralize only one token for singular tokens: put those which multiply on the left , and those which divide on the right .","title":"Multiplying and dividing quantities"},{"location":"tutorial/101-quantity-makers/#exercise-computing-with-quantities","text":"To get some practice with quantities, we\u2019ve included an exercise where you can make and print some quantities, and then upgrade an existing function implementation from raw numbers to quantities. Check out the Au 101: API Types Exercise !","title":"Exercise: computing with quantities"},{"location":"tutorial/101-quantity-makers/#takeaways","text":"We strive for unit safety . If we can check the unit-correctness of every individual line of code, by inspection, in isolation, we can reduce cognitive load, and write code faster and more robustly. To store a raw numeric value safely inside of a quantity object, call the quantity maker whose name is the unit of interest. For example, meters(3) is quantity representing 3\\,\\text{m} 3\\,\\text{m} , stored as int . To retrieve a stored numeric value from a quantity q , call q.in(units) , where units was the quantity maker used in the first place. For example, meters(3).in(meters) is simply 3 . Quantity makers compose : you can multiply, divide, and raise them to powers to get a new quantity maker. For example, (meters / second) is a quantity maker which you can call like any other. (meters / second)(5) represents the quantity 5\\,\\text{m/s} 5\\,\\text{m/s} . Tip Au only contains unit-safe interfaces. That\u2019s why simply storing the value in a quantity is enough to achieve unit-safety! To take the example from std::chrono::duration , note that the system clock has different resolutions on different widely used toolchains . gcc uses 1\\,\\text{ns} 1\\,\\text{ns} , MSVC uses 100\\,\\text{ns} 100\\,\\text{ns} , and clang uses 1000\\,\\text{ns} 1000\\,\\text{ns} . So if you subtracted two calls to std::chrono::system_clock::now() and called .count() , your answers would vary by 3 orders of magnitude on different compilers! This is not to say that doing so would be a good use of the chrono library. It\u2019s not, and that\u2019s the point: a bare call to .count() gives the reader no idea how to interpret its result. \u21a9 What about adding, subtracting, and comparing quantities of different units, but the same dimensions\u2014like comparing seconds(100) to minutes(1) , or adding inches(1) to feet(6) ? In most cases, we do support this as well, but it\u2019s a more advanced usage which we\u2019ll discuss further in future lessons. \u21a9","title":"Takeaways"},{"location":"tutorial/102-api-types/","text":"Au 102: API Types \u00b6 This tutorial explains how to name your types in function parameters and member variables. Time: 30 minutes. Prerequisites: Au 101: Quantity Makers . You will learn: The Quantity<Unit, Rep> type template. The convenient aliases ( QuantityD<Unit> , QuantityI32<Unit> , etc.) for each storage type. How to form compound units. A strategy for upgrading the APIs of existing functions. The Quantity<Unit, Rep> template \u00b6 In the previous tutorial , we practiced getting values into and out of the library, and even performing a few simple operations. However, we skipped the type name. Let\u2019s learn it now\u2014we\u2019ll need it in order to use a quantity as a function parameter, or a member variable. We store our quantities in a type template with two template parameters: Quantity<Unit, Rep> . Unit is a type representing the unit of measure. Rep , short for \u201cRepresentation\u201d, is the underlying numeric storage type. Here\u2019s how to provide each parameter. Unit : This will typically be the CamelCase version of the quantity maker, which is itself represented in snake_case . (For example, for the quantity maker meters , the unit type is Meters .) You can also provide a compound unit. We\u2019ll explain how to form compound units later in this section. Rep : This can be any numeric type: either floating point ( double , float ), or integral ( int , uint64_t , \u2026). Note Someday, we also hope to support more than just built-in numeric types for the Rep! See #52 for details. QuantityD<Unit> , and other aliases \u00b6 Templates with multiple parameters (for example, Quantity<Meters, double> ) can be cumbersome. The whitespace in the type name can make it harder to read at a glance. Moreover, preprocessor macros will be unable to parse it unless you surround it with extra parentheses. 1 To make things easier, we provide concise aliases to handle the most common cases. For example, QuantityD<Meters> (think: D for double ) is identical to Quantity<Meters, double> . Here\u2019s a table of the ones we support out of the box: Rep Alias double QuantityD float QuantityF int32_t QuantityI32 uint32_t QuantityU32 int64_t QuantityI64 uint64_t QuantityU64 Building new units from old \u00b6 What if your unit doesn\u2019t have its own proper name, but is instead built from other units? For example, \u201ccentimeters\u201d is built from the named unit \u201cmeters\u201d by applying a prefix , which scales it. Also, \u201crevolutions per minute\u201d is simply the quotient of the named units \u201crevolutions\u201d and \u201cminutes\u201d. Here\u2019s how we handle these cases. Prefixed units \u00b6 Every SI and binary prefix is available as a CamelCase -named template. If you apply it to a unit, you\u2019ll create the prefixed unit. Example: Centi<Meters> is a unit of \\text{cm} \\text{cm} . Example: Gibi<Bytes> is a unit of \\text{GiB} \\text{GiB} . Compound units \u00b6 \u201cCompound units\u201d are units such as \u201cmeters per second squared\u201d, where we form new units by essentially doing arithmetic on existing ones. This gets a little more complicated than prefixes, because even though we\u2019re both starting and ending with types , the arithmetic itself is more natural to perform on instances . So here are the steps. Convert each unit type to an instance , by instantiating it with {} . For example: Meters is a type ; Meters{} is an instance . Perform your arithmetic operation(s), making compound unit instances out of your single unit instances . For example: Meters{} / squared(Seconds{}) . Pass the result to decltype() , to go from your instance back to the type . Or, in diagram form, here\u2019s how we enter the \u201crealm of instances\u201d to do our arithmetic, and then return to the \u201crealm of types\u201d: flowchart TB subgraph \"Realm of Types\" UnitT[\"Single Unit Type\"] CompoundT[\"Compound Unit Type\"] end subgraph \"Realm of Instances\" UnitI[\"Single Unit Instance\"] CompoundI[\"Compound Unit Instance\"] end UnitT -->|\"{}\"| UnitI UnitI -->|\"Arithmetic ops:<br>*, /, squared(), ...\"| CompoundI CompoundI -->|\"decltype()\"| CompoundT Generally the best move is to store the result in an alias. Here\u2019s a complete example. using MetersPerSecondSquared = decltype ( Meters {} / squared ( Seconds {})); Now you can easily form, e.g., a QuantityD<MetersPerSecondSquared> to hold your acceleration values. Exercise: upgrading an API \u00b6 To get some practice with these API types, we\u2019ve included an exercise where you can offer a unit-safe interface alongside a legacy one. Check out the Au 102: API Types Exercise ! Takeaways \u00b6 The type name for a quantity is Quantity<Unit, Rep> , where Unit is the ( CamelCase ) name of the unit, and Rep is the storage type. For example, the return type of meters(3) is Quantity<Meters, int> . Prefer using the alias for each storage type , because using multiple template parameters can be cumbersome. For example, QuantityU64<Seconds> is an alias for Quantity<Seconds, uint64_t> . You can apply any prefix to a unit type. For example, Mega<Hertz> is the unit type for the quantity maker mega(hertz) . You can form compound units by simply performing arithmetic on instances of the unit types, and defining an alias. For example, decltype(Meters{} / squared(Seconds{})) is a unit type , representing the unit \\text{m} / \\text{s}^2 \\text{m} / \\text{s}^2 . While we avoid using macros in our own library, we can\u2019t avoid them in others! Even within this repository, we use googletest for our test cases, and googletest is macro-based. \u21a9","title":"Au 102: API Types"},{"location":"tutorial/102-api-types/#au-102-api-types","text":"This tutorial explains how to name your types in function parameters and member variables. Time: 30 minutes. Prerequisites: Au 101: Quantity Makers . You will learn: The Quantity<Unit, Rep> type template. The convenient aliases ( QuantityD<Unit> , QuantityI32<Unit> , etc.) for each storage type. How to form compound units. A strategy for upgrading the APIs of existing functions.","title":"Au 102: API Types"},{"location":"tutorial/102-api-types/#the-quantityunit-rep-template","text":"In the previous tutorial , we practiced getting values into and out of the library, and even performing a few simple operations. However, we skipped the type name. Let\u2019s learn it now\u2014we\u2019ll need it in order to use a quantity as a function parameter, or a member variable. We store our quantities in a type template with two template parameters: Quantity<Unit, Rep> . Unit is a type representing the unit of measure. Rep , short for \u201cRepresentation\u201d, is the underlying numeric storage type. Here\u2019s how to provide each parameter. Unit : This will typically be the CamelCase version of the quantity maker, which is itself represented in snake_case . (For example, for the quantity maker meters , the unit type is Meters .) You can also provide a compound unit. We\u2019ll explain how to form compound units later in this section. Rep : This can be any numeric type: either floating point ( double , float ), or integral ( int , uint64_t , \u2026). Note Someday, we also hope to support more than just built-in numeric types for the Rep! See #52 for details.","title":"The Quantity&lt;Unit, Rep&gt; template"},{"location":"tutorial/102-api-types/#quantitydunit-and-other-aliases","text":"Templates with multiple parameters (for example, Quantity<Meters, double> ) can be cumbersome. The whitespace in the type name can make it harder to read at a glance. Moreover, preprocessor macros will be unable to parse it unless you surround it with extra parentheses. 1 To make things easier, we provide concise aliases to handle the most common cases. For example, QuantityD<Meters> (think: D for double ) is identical to Quantity<Meters, double> . Here\u2019s a table of the ones we support out of the box: Rep Alias double QuantityD float QuantityF int32_t QuantityI32 uint32_t QuantityU32 int64_t QuantityI64 uint64_t QuantityU64","title":"QuantityD&lt;Unit&gt;, and other aliases"},{"location":"tutorial/102-api-types/#building-new-units-from-old","text":"What if your unit doesn\u2019t have its own proper name, but is instead built from other units? For example, \u201ccentimeters\u201d is built from the named unit \u201cmeters\u201d by applying a prefix , which scales it. Also, \u201crevolutions per minute\u201d is simply the quotient of the named units \u201crevolutions\u201d and \u201cminutes\u201d. Here\u2019s how we handle these cases.","title":"Building new units from old"},{"location":"tutorial/102-api-types/#prefixed-units","text":"Every SI and binary prefix is available as a CamelCase -named template. If you apply it to a unit, you\u2019ll create the prefixed unit. Example: Centi<Meters> is a unit of \\text{cm} \\text{cm} . Example: Gibi<Bytes> is a unit of \\text{GiB} \\text{GiB} .","title":"Prefixed units"},{"location":"tutorial/102-api-types/#compound-units","text":"\u201cCompound units\u201d are units such as \u201cmeters per second squared\u201d, where we form new units by essentially doing arithmetic on existing ones. This gets a little more complicated than prefixes, because even though we\u2019re both starting and ending with types , the arithmetic itself is more natural to perform on instances . So here are the steps. Convert each unit type to an instance , by instantiating it with {} . For example: Meters is a type ; Meters{} is an instance . Perform your arithmetic operation(s), making compound unit instances out of your single unit instances . For example: Meters{} / squared(Seconds{}) . Pass the result to decltype() , to go from your instance back to the type . Or, in diagram form, here\u2019s how we enter the \u201crealm of instances\u201d to do our arithmetic, and then return to the \u201crealm of types\u201d: flowchart TB subgraph \"Realm of Types\" UnitT[\"Single Unit Type\"] CompoundT[\"Compound Unit Type\"] end subgraph \"Realm of Instances\" UnitI[\"Single Unit Instance\"] CompoundI[\"Compound Unit Instance\"] end UnitT -->|\"{}\"| UnitI UnitI -->|\"Arithmetic ops:<br>*, /, squared(), ...\"| CompoundI CompoundI -->|\"decltype()\"| CompoundT Generally the best move is to store the result in an alias. Here\u2019s a complete example. using MetersPerSecondSquared = decltype ( Meters {} / squared ( Seconds {})); Now you can easily form, e.g., a QuantityD<MetersPerSecondSquared> to hold your acceleration values.","title":"Compound units"},{"location":"tutorial/102-api-types/#exercise-upgrading-an-api","text":"To get some practice with these API types, we\u2019ve included an exercise where you can offer a unit-safe interface alongside a legacy one. Check out the Au 102: API Types Exercise !","title":"Exercise: upgrading an API"},{"location":"tutorial/102-api-types/#takeaways","text":"The type name for a quantity is Quantity<Unit, Rep> , where Unit is the ( CamelCase ) name of the unit, and Rep is the storage type. For example, the return type of meters(3) is Quantity<Meters, int> . Prefer using the alias for each storage type , because using multiple template parameters can be cumbersome. For example, QuantityU64<Seconds> is an alias for Quantity<Seconds, uint64_t> . You can apply any prefix to a unit type. For example, Mega<Hertz> is the unit type for the quantity maker mega(hertz) . You can form compound units by simply performing arithmetic on instances of the unit types, and defining an alias. For example, decltype(Meters{} / squared(Seconds{})) is a unit type , representing the unit \\text{m} / \\text{s}^2 \\text{m} / \\text{s}^2 . While we avoid using macros in our own library, we can\u2019t avoid them in others! Even within this repository, we use googletest for our test cases, and googletest is macro-based. \u21a9","title":"Takeaways"},{"location":"tutorial/103-unit-conversions/","text":"Au 103: Unit Conversions \u00b6 This tutorial explains how to perform unit conversions, both implicitly and explicitly. Time: 30 minutes. Prerequisites: Au 101: Quantity Makers . Au 102: API types You will learn: How .in(...) , the \u201cvalue retrieving\u201d function, actually performs unit conversions. .as(...) : the safer cousin of .in(...) , which gives a quantity instead of a raw number. How to \u201cforce\u201d a physically meaningful conversion which Au thinks is dangerous. Which conversions work automatically, which work only when forced, and which are prevented. Which implicit conversions are allowed. New units for .in(...) \u00b6 Once we store a value in a Quantity , we know we need to name its unit explicitly to get the value back out \u2014 that\u2019s Au 101 . constexpr auto q = feet ( 6 ); q . in ( feet ); // <-- produces `6` That API is awfully suggestive, though. What happens if we pass some other unit? Answer: it does just what it looks like it does. constexpr auto q = feet ( 6 ); q . in ( inches ); // <-- produces `72` We introduced .in(...) as, essentially, \u201cthe function that gets the value back out\u201d. That was true, but incomplete. Now we see its true role: it\u2019s the quantity value conversion function . The role we saw earlier is just a special case: when we pass the same unit we used to create it, that \u201cconversion\u201d is simply the identity. Already, this opens up a new simple, self-contained use case for Au: it\u2019s very easy to conjure up highly readable unit conversions on the fly, even if you both start and end with raw numbers. Consider this example: // Starting with a raw numeric type: double angle_deg = 90.0 ; { // \u26a0\ufe0f Old, manual method for doing conversions: constexpr auto RAD_PER_DEG = M_PI / 180.0 ; double angle_rad = angle_deg * RAD_PER_DEG ; } { // \u2714\ufe0f Easy, readable ad hoc conversion with Au: double angle_rad = degrees ( angle_deg ). in ( radians ); } With the old method, we needed to manually craft a carefully named conversion constant. And because this was an angular conversion, we also needed to worry about how to get a good value for \\pi \\pi (here, we chose the M_PI macro). By contrast, the Au-based alternative gives you a readable, clearly correct one-liner out of the box \u2014 and it doesn\u2019t trouble the author or reader with the details of correctly obtaining (and using) \\pi \\pi . .as(...) : like .in(...) , but makes a quantity \u00b6 Using .in(...) works very well when you want a raw number \u2014 typically, when you\u2019re interacting with some legacy interface. However, sometimes what you want is a quantity that\u2019s expressed in a specific unit. For example, you might be comparing quantities in a hot loop, and you\u2019d rather avoid repeated conversions. Or, you might want to print your quantity in some specific unit. We could satisfy these use cases with .in(...) , but it\u2019s a little clunky: // Not recommended! See below. auto angle = radians ( degrees ( angle_deg ). in ( radians )); // ^^^^^^^ Raw number--^^ ^^^^^^^ // | | // \\--Repeated identifier--/ This approach wouldn\u2019t just be repetitive; it would also create a (small!) opportunity for error, because you temporarily leave the safety of the units library before re-entering it. Fortunately, there\u2019s a better choice. Quantity has another member function, .as(...) , for exactly this use case. You can pass it any unit you would pass to .in(...) , but .as(...) returns a quantity , not a raw number. Building on our earlier example: auto angle = degrees ( angle_deg ). as ( radians ); // \ud83d\udc4d Don't Repeat Yourself---^^^^^^^ Use .as(...) when you want easy, inline, fine-grained control over the units in which your quantities are expressed. Conversion categories \u00b6 The examples so far have been pretty straightforward. To convert from feet to inches , we simply multiply the underlying value by 12. That seems pretty safe for just about any Rep 1 , whether floating point or integral. However, other conversions can be more subtle. Let\u2019s look at a bunch of example unit conversions. We\u2019ll show how each conversion works with both int and double Rep, because the rules can differ significantly for integral and floating point types. Instructions For each example: stop and think about what you would expect the library to produce in each case. When you\u2019re ready, click over to the \u201cResults and Discussion\u201d tab to check your intuition. Example: feet to yards Conversion Results and Discussion feet ( 6 ). as ( yards ); feet ( 6.0 ). as ( yards ); feet ( 6 ). as ( yards ); // Compiler error! feet ( 6.0 ). as ( yards ); // yards(2.0) Converting from feet to yards means dividing the underlying value by 3. For an integral Rep, this actually yields a compiler error , because we can\u2019t guarantee that the result will be an integer. True, with feet(6) , it so happens that it would \u2014 but if we had feet(5) , this wouldn\u2019t be the case! Floating point Rep is simpler. When we divide any value by 3 , we won\u2019t exceed typical floating point error. Because this level of uncertainty simply goes with the territory when using floating point types, Au allows this operation with no complaint. Example: feet to nano(meters) Conversion Results and Discussion feet ( 6 ). as ( nano ( meters )); feet ( 6.0 ). as ( nano ( meters )); feet ( 6 ). as ( nano ( meters )); // Compiler error! feet ( 6.0 ). as ( nano ( meters )); // nano(meters)(1'828'800'000.0) Converting from feet to nano(meters) means multiplying the underlying value by 304,800,000. Unlike the last example, this is guaranteed to produce an integer result. Yet, the integral Rep again gives us a compiler error ! This time, we\u2019re guarding against a different risk: overflow . It turns out that any underlying value larger than feet(7) would overflow in this conversion. That\u2019s pretty scary, so we forbid this conversion. Of course, that\u2019s just because int is typically only 32 bits. Au adapts to the specific level of overflow risk, based on both the conversion and the range of the type. For example, this integral-type conversion would work: feet ( 6L L ). as ( nano ( meters )); // nano(meters)(1'828'800'000LL) Since long long is at least 64 bits, we could handle values into the tens of billions of feet before overflowing! In more detail: the \"Overflow Safety Surface\" Here is how to reason about which integral-Rep conversions the library supports. For every conversion operation, there is some smallest value which would overflow . This depends on both the size of the conversion factor, and the range of values which the type can hold. If that smallest value is small enough to be \u201cscary\u201d, we forbid the conversion. How small is \u201cscary\u201d? Here are some considerations. Once our values get over 1,000, we can consider switching to a larger SI-prefixed version of the unit. (For example, lengths over 1000\\,\\text{m} 1000\\,\\text{m} can be approximated in \\text{km} \\text{km} .) This means that if a value as small as 1,000 would overflow \u2014 so small that we haven\u2019t even reached the next unit \u2014 we should definitely forbid the conversion. On the other hand, we\u2019ve found it useful to initialize, say, QuantityU32<Hertz> variables with something like mega(hertz)(500) . Thus, we\u2019d like this operation to succeed (although it should probably be near the border of what\u2019s allowed). Putting it all together, we settled on a value threshold of 4,294 . If we can convert this value without overflow, then we permit the operation; otherwise, we don\u2019t. We picked this value because it satisfies our above criteria nicely. It will prevent operations that can\u2019t handle values of 1,000, but it still lets us use \\text{MHz} \\text{MHz} freely when storing \\text{Hz} \\text{Hz} quantities in uint32_t . We can picture this relationship in terms of the biggest allowable conversion factor , as a function of the max value of the type . This function separates the allowed conversions from the forbidden ones, permitting bigger conversions for bigger types. We call this abstract boundary the \u201coverflow safety surface\u201d , and it\u2019s the secret ingredient that lets us use a wide variety of integral types with confidence. As for the floating point value, this is again very safe, so we allow it without complaint. Example: feet to kelvins Conversion Results and Discussion feet ( 6 ). as ( kelvins ); feet ( 6.0 ). as ( kelvins ); feet ( 6 ). as ( kelvins ); // Compiler error! feet ( 6.0 ). as ( kelvins ); // Compiler error! Converting from feet to kelvins is an intrinsically meaningless operation, because they have different dimensions (namely, length and temperature ). For both integral and floating point Rep, we forbid this operation. Explicit-Rep versions: .in<T>(...) and .as<T>(...) \u00b6 You can choose the Rep for the result of your conversion by providing it as an explicit template parameter. For example: feet ( 6.0 ). as ( yards ); // yards(2.0) feet ( 6.0 ). as < float > ( yards ); // yards(2.0f) This \u201cexplicit-Rep\u201d version is morally equivalent to static_cast , in that it is forcing . For example: // Standard C++ intuition: static_cast < int > ( 3.14 ); // 3 // Similar \"forcing\" semantics: feet ( 5 ). as < int > ( yards ); // yards(1) --- a truncation of (5/3 = 1.6666...) yards You can use this to \u201coverrule\u201d Au when we prevent a physically meaningful conversion because we think it\u2019s too risky. Tip Prefer not to use the explicit-Rep version unless you have a good reason. If you do, consider adding a comment to explain why your specific use case is OK. As a code reviewer, if you see an explicit-Rep version that doesn\u2019t seem necessary or justified, ask about it! At this point, we\u2019ve seen several examples of conversions which Au forbids. We\u2019ve also seen how some of them can be forced anyway. Here\u2019s a chance to test your understanding: what will happen if you try to force that final example \u2014 the one where the dimensions differ? Example: forcing different-dimension conversions? As before, stop and think about what you would expect the library to produce. When you\u2019re ready, click over to the \u201cResults and Discussion\u201d tab to check your intuition. Conversion Results and Discussion feet ( 6 ). as < int > ( kelvins ); feet ( 6 ). as < int > ( kelvins ); // Compiler error! Converting units with different dimensions isn\u2019t merely \u201cunsafe\u201d; it\u2019s completely meaningless. We can\u2019t \u201cforce\u201d the answer because there isn\u2019t even an answer to force. Conversion summary \u00b6 This table gives a visual summary of how different kinds of risks impact conversions with different storage types. Conversion Result ( int Rep): length = feet(6) Result ( double Rep): length = feet(6.0) length.as(inches) inches(72) inches(72.0) length.as(yards) Forbidden : not guaranteed to be integral (can be forced with explicit-Rep) yards(2.0) length.as(nano(meters)) Forbidden : excessive overflow risk (can be forced with explicit-Rep) nano(meters)(1'828'800'000.0) length.as(kelvins) Forbidden : meaningless Forbidden : meaningless Implicit conversions \u00b6 Au emphasizes developer experience. We strive to provide the same ergonomics which developers have come to expect from the venerable std::chrono library. This means that any meaningful conversion which we consider \u201csafe enough\u201d (based on the above criteria), we permit implicitly . This lets you fluently initialize a quantity parameter with any convertible expression . For example: // API accepting a quantity parameter. void rotate ( QuantityD < Radians > angle ); // This works! // We'll automatically convert the integral quantity of degrees to `QuantityD<Radians>`. rotate ( degrees ( 45 )); Our conversion policy is a refinement of the policy for std::chrono::duration . Here is their policy (paraphrased and simplified): Implicit conversions are permitted if either : The destination is floating point; Or, the source type is integer, and the conversion multiplies by an integer. And here is our refinement (the overflow safety surface ): If an integral-Rep conversion would overflow the destination type for a source value as small as 4'294 , we forbid the conversion. Deeper dive: comparing overflow strategies for Au and chrono The std::chrono library doesn\u2019t consider overflow in its conversion policy, because they handle the problem in a different way. Instead of encouraging users to use duration directly, they provide pre-defined helper types such as std::chrono::nanoseconds , std::chrono::milliseconds , etc. The Rep for each of these types is chosen to guarantee covering at least 292 years in either direction. This is a good and practical solution, which is effective at preventing overflow for users who stick to these helper types. The downside is that it forces users to change their underlying storage types \u2014 changing the assembly code produced \u2014 in the process of acquiring unit safety. A key design goal of Au is to avoid forcing users to change their underyling numeric types. We want to empower people to get the same assembly they would have had without Au, just more safely. Because smaller numeric types bring this extra overflow risk (and in a way that\u2019s often non-obvious to developers), we designed this adaptive policy which prevents the biggest risks. (Lastly, of course we also forbid conversions between units of different dimensions. This consideration wasn\u2019t part of the std::chrono library, because that library only has a single dimension.) Exercise: practicing conversions \u00b6 Check out the Au 103: Unit Conversions Exercise ! Takeaways \u00b6 To convert a quantity to a particular unit, pass that unit\u2019s quantity maker to the appropriate member function, .in(...) or .as(...) . For example, minutes(3) is a quantity, and minutes(3).as(seconds) produces seconds(180) . .in(...) gives a raw number , while .as(...) gives a quantity . These names are used consistently in this way throughout the library. For example, we\u2019ll learn in the next tutorial that round_in(...) produces a raw number , while round_as(...) produces a quantity . Prefer .as(...) when you have a choice, because it stays within the safety of the library. Both conversion functions include safety checks . This means you can generally just use them , and rely on the library to guard against the biggest risks. Here are the details to remember about these safety checks. We forbid conversions with mismatched dimensions (as with any units library). We forbid conversions for integer destinations unless we\u2019re sure we\u2019ll always have an integer (as with the chrono library ), and we don\u2019t have excessive overflow risk (an Au-original feature!). You can force a conversion that is meaningful, but considered dangerous by providing an explicit target Rep as a template parameter. For example: seconds(200).as(minutes) won\u2019t compile, but seconds(200).as<int>(minutes) gives minutes(3) , because we forced this lossy conversion with the explicit <int> . Use this sparingly, since the safety checks are there for a reason, and consider adding a comment to explain why your usage is safe. You can never force a conversion to a different dimension, because this is not meaningful. Any conversion allowed by .as(...) will also work as an implicit conversion . For example, if you have an API which takes QuantityD<Radians> , you can pass degrees(45) directly to it. Recall that the \u201cRep\u201d is shorthand for the underlying storage type of the quantity. \u21a9","title":"Au 103: Unit Conversions"},{"location":"tutorial/103-unit-conversions/#au-103-unit-conversions","text":"This tutorial explains how to perform unit conversions, both implicitly and explicitly. Time: 30 minutes. Prerequisites: Au 101: Quantity Makers . Au 102: API types You will learn: How .in(...) , the \u201cvalue retrieving\u201d function, actually performs unit conversions. .as(...) : the safer cousin of .in(...) , which gives a quantity instead of a raw number. How to \u201cforce\u201d a physically meaningful conversion which Au thinks is dangerous. Which conversions work automatically, which work only when forced, and which are prevented. Which implicit conversions are allowed.","title":"Au 103: Unit Conversions"},{"location":"tutorial/103-unit-conversions/#new-units-for-in","text":"Once we store a value in a Quantity , we know we need to name its unit explicitly to get the value back out \u2014 that\u2019s Au 101 . constexpr auto q = feet ( 6 ); q . in ( feet ); // <-- produces `6` That API is awfully suggestive, though. What happens if we pass some other unit? Answer: it does just what it looks like it does. constexpr auto q = feet ( 6 ); q . in ( inches ); // <-- produces `72` We introduced .in(...) as, essentially, \u201cthe function that gets the value back out\u201d. That was true, but incomplete. Now we see its true role: it\u2019s the quantity value conversion function . The role we saw earlier is just a special case: when we pass the same unit we used to create it, that \u201cconversion\u201d is simply the identity. Already, this opens up a new simple, self-contained use case for Au: it\u2019s very easy to conjure up highly readable unit conversions on the fly, even if you both start and end with raw numbers. Consider this example: // Starting with a raw numeric type: double angle_deg = 90.0 ; { // \u26a0\ufe0f Old, manual method for doing conversions: constexpr auto RAD_PER_DEG = M_PI / 180.0 ; double angle_rad = angle_deg * RAD_PER_DEG ; } { // \u2714\ufe0f Easy, readable ad hoc conversion with Au: double angle_rad = degrees ( angle_deg ). in ( radians ); } With the old method, we needed to manually craft a carefully named conversion constant. And because this was an angular conversion, we also needed to worry about how to get a good value for \\pi \\pi (here, we chose the M_PI macro). By contrast, the Au-based alternative gives you a readable, clearly correct one-liner out of the box \u2014 and it doesn\u2019t trouble the author or reader with the details of correctly obtaining (and using) \\pi \\pi .","title":"New units for .in(...)"},{"location":"tutorial/103-unit-conversions/#as-like-in-but-makes-a-quantity","text":"Using .in(...) works very well when you want a raw number \u2014 typically, when you\u2019re interacting with some legacy interface. However, sometimes what you want is a quantity that\u2019s expressed in a specific unit. For example, you might be comparing quantities in a hot loop, and you\u2019d rather avoid repeated conversions. Or, you might want to print your quantity in some specific unit. We could satisfy these use cases with .in(...) , but it\u2019s a little clunky: // Not recommended! See below. auto angle = radians ( degrees ( angle_deg ). in ( radians )); // ^^^^^^^ Raw number--^^ ^^^^^^^ // | | // \\--Repeated identifier--/ This approach wouldn\u2019t just be repetitive; it would also create a (small!) opportunity for error, because you temporarily leave the safety of the units library before re-entering it. Fortunately, there\u2019s a better choice. Quantity has another member function, .as(...) , for exactly this use case. You can pass it any unit you would pass to .in(...) , but .as(...) returns a quantity , not a raw number. Building on our earlier example: auto angle = degrees ( angle_deg ). as ( radians ); // \ud83d\udc4d Don't Repeat Yourself---^^^^^^^ Use .as(...) when you want easy, inline, fine-grained control over the units in which your quantities are expressed.","title":".as(...): like .in(...), but makes a quantity"},{"location":"tutorial/103-unit-conversions/#conversion-categories","text":"The examples so far have been pretty straightforward. To convert from feet to inches , we simply multiply the underlying value by 12. That seems pretty safe for just about any Rep 1 , whether floating point or integral. However, other conversions can be more subtle. Let\u2019s look at a bunch of example unit conversions. We\u2019ll show how each conversion works with both int and double Rep, because the rules can differ significantly for integral and floating point types. Instructions For each example: stop and think about what you would expect the library to produce in each case. When you\u2019re ready, click over to the \u201cResults and Discussion\u201d tab to check your intuition. Example: feet to yards Conversion Results and Discussion feet ( 6 ). as ( yards ); feet ( 6.0 ). as ( yards ); feet ( 6 ). as ( yards ); // Compiler error! feet ( 6.0 ). as ( yards ); // yards(2.0) Converting from feet to yards means dividing the underlying value by 3. For an integral Rep, this actually yields a compiler error , because we can\u2019t guarantee that the result will be an integer. True, with feet(6) , it so happens that it would \u2014 but if we had feet(5) , this wouldn\u2019t be the case! Floating point Rep is simpler. When we divide any value by 3 , we won\u2019t exceed typical floating point error. Because this level of uncertainty simply goes with the territory when using floating point types, Au allows this operation with no complaint. Example: feet to nano(meters) Conversion Results and Discussion feet ( 6 ). as ( nano ( meters )); feet ( 6.0 ). as ( nano ( meters )); feet ( 6 ). as ( nano ( meters )); // Compiler error! feet ( 6.0 ). as ( nano ( meters )); // nano(meters)(1'828'800'000.0) Converting from feet to nano(meters) means multiplying the underlying value by 304,800,000. Unlike the last example, this is guaranteed to produce an integer result. Yet, the integral Rep again gives us a compiler error ! This time, we\u2019re guarding against a different risk: overflow . It turns out that any underlying value larger than feet(7) would overflow in this conversion. That\u2019s pretty scary, so we forbid this conversion. Of course, that\u2019s just because int is typically only 32 bits. Au adapts to the specific level of overflow risk, based on both the conversion and the range of the type. For example, this integral-type conversion would work: feet ( 6L L ). as ( nano ( meters )); // nano(meters)(1'828'800'000LL) Since long long is at least 64 bits, we could handle values into the tens of billions of feet before overflowing! In more detail: the \"Overflow Safety Surface\" Here is how to reason about which integral-Rep conversions the library supports. For every conversion operation, there is some smallest value which would overflow . This depends on both the size of the conversion factor, and the range of values which the type can hold. If that smallest value is small enough to be \u201cscary\u201d, we forbid the conversion. How small is \u201cscary\u201d? Here are some considerations. Once our values get over 1,000, we can consider switching to a larger SI-prefixed version of the unit. (For example, lengths over 1000\\,\\text{m} 1000\\,\\text{m} can be approximated in \\text{km} \\text{km} .) This means that if a value as small as 1,000 would overflow \u2014 so small that we haven\u2019t even reached the next unit \u2014 we should definitely forbid the conversion. On the other hand, we\u2019ve found it useful to initialize, say, QuantityU32<Hertz> variables with something like mega(hertz)(500) . Thus, we\u2019d like this operation to succeed (although it should probably be near the border of what\u2019s allowed). Putting it all together, we settled on a value threshold of 4,294 . If we can convert this value without overflow, then we permit the operation; otherwise, we don\u2019t. We picked this value because it satisfies our above criteria nicely. It will prevent operations that can\u2019t handle values of 1,000, but it still lets us use \\text{MHz} \\text{MHz} freely when storing \\text{Hz} \\text{Hz} quantities in uint32_t . We can picture this relationship in terms of the biggest allowable conversion factor , as a function of the max value of the type . This function separates the allowed conversions from the forbidden ones, permitting bigger conversions for bigger types. We call this abstract boundary the \u201coverflow safety surface\u201d , and it\u2019s the secret ingredient that lets us use a wide variety of integral types with confidence. As for the floating point value, this is again very safe, so we allow it without complaint. Example: feet to kelvins Conversion Results and Discussion feet ( 6 ). as ( kelvins ); feet ( 6.0 ). as ( kelvins ); feet ( 6 ). as ( kelvins ); // Compiler error! feet ( 6.0 ). as ( kelvins ); // Compiler error! Converting from feet to kelvins is an intrinsically meaningless operation, because they have different dimensions (namely, length and temperature ). For both integral and floating point Rep, we forbid this operation.","title":"Conversion categories"},{"location":"tutorial/103-unit-conversions/#explicit-rep-versions-int-and-ast","text":"You can choose the Rep for the result of your conversion by providing it as an explicit template parameter. For example: feet ( 6.0 ). as ( yards ); // yards(2.0) feet ( 6.0 ). as < float > ( yards ); // yards(2.0f) This \u201cexplicit-Rep\u201d version is morally equivalent to static_cast , in that it is forcing . For example: // Standard C++ intuition: static_cast < int > ( 3.14 ); // 3 // Similar \"forcing\" semantics: feet ( 5 ). as < int > ( yards ); // yards(1) --- a truncation of (5/3 = 1.6666...) yards You can use this to \u201coverrule\u201d Au when we prevent a physically meaningful conversion because we think it\u2019s too risky. Tip Prefer not to use the explicit-Rep version unless you have a good reason. If you do, consider adding a comment to explain why your specific use case is OK. As a code reviewer, if you see an explicit-Rep version that doesn\u2019t seem necessary or justified, ask about it! At this point, we\u2019ve seen several examples of conversions which Au forbids. We\u2019ve also seen how some of them can be forced anyway. Here\u2019s a chance to test your understanding: what will happen if you try to force that final example \u2014 the one where the dimensions differ? Example: forcing different-dimension conversions? As before, stop and think about what you would expect the library to produce. When you\u2019re ready, click over to the \u201cResults and Discussion\u201d tab to check your intuition. Conversion Results and Discussion feet ( 6 ). as < int > ( kelvins ); feet ( 6 ). as < int > ( kelvins ); // Compiler error! Converting units with different dimensions isn\u2019t merely \u201cunsafe\u201d; it\u2019s completely meaningless. We can\u2019t \u201cforce\u201d the answer because there isn\u2019t even an answer to force.","title":"Explicit-Rep versions: .in&lt;T&gt;(...) and .as&lt;T&gt;(...)"},{"location":"tutorial/103-unit-conversions/#conversion-summary","text":"This table gives a visual summary of how different kinds of risks impact conversions with different storage types. Conversion Result ( int Rep): length = feet(6) Result ( double Rep): length = feet(6.0) length.as(inches) inches(72) inches(72.0) length.as(yards) Forbidden : not guaranteed to be integral (can be forced with explicit-Rep) yards(2.0) length.as(nano(meters)) Forbidden : excessive overflow risk (can be forced with explicit-Rep) nano(meters)(1'828'800'000.0) length.as(kelvins) Forbidden : meaningless Forbidden : meaningless","title":"Conversion summary"},{"location":"tutorial/103-unit-conversions/#implicit-conversions","text":"Au emphasizes developer experience. We strive to provide the same ergonomics which developers have come to expect from the venerable std::chrono library. This means that any meaningful conversion which we consider \u201csafe enough\u201d (based on the above criteria), we permit implicitly . This lets you fluently initialize a quantity parameter with any convertible expression . For example: // API accepting a quantity parameter. void rotate ( QuantityD < Radians > angle ); // This works! // We'll automatically convert the integral quantity of degrees to `QuantityD<Radians>`. rotate ( degrees ( 45 )); Our conversion policy is a refinement of the policy for std::chrono::duration . Here is their policy (paraphrased and simplified): Implicit conversions are permitted if either : The destination is floating point; Or, the source type is integer, and the conversion multiplies by an integer. And here is our refinement (the overflow safety surface ): If an integral-Rep conversion would overflow the destination type for a source value as small as 4'294 , we forbid the conversion. Deeper dive: comparing overflow strategies for Au and chrono The std::chrono library doesn\u2019t consider overflow in its conversion policy, because they handle the problem in a different way. Instead of encouraging users to use duration directly, they provide pre-defined helper types such as std::chrono::nanoseconds , std::chrono::milliseconds , etc. The Rep for each of these types is chosen to guarantee covering at least 292 years in either direction. This is a good and practical solution, which is effective at preventing overflow for users who stick to these helper types. The downside is that it forces users to change their underlying storage types \u2014 changing the assembly code produced \u2014 in the process of acquiring unit safety. A key design goal of Au is to avoid forcing users to change their underyling numeric types. We want to empower people to get the same assembly they would have had without Au, just more safely. Because smaller numeric types bring this extra overflow risk (and in a way that\u2019s often non-obvious to developers), we designed this adaptive policy which prevents the biggest risks. (Lastly, of course we also forbid conversions between units of different dimensions. This consideration wasn\u2019t part of the std::chrono library, because that library only has a single dimension.)","title":"Implicit conversions"},{"location":"tutorial/103-unit-conversions/#exercise-practicing-conversions","text":"Check out the Au 103: Unit Conversions Exercise !","title":"Exercise: practicing conversions"},{"location":"tutorial/103-unit-conversions/#takeaways","text":"To convert a quantity to a particular unit, pass that unit\u2019s quantity maker to the appropriate member function, .in(...) or .as(...) . For example, minutes(3) is a quantity, and minutes(3).as(seconds) produces seconds(180) . .in(...) gives a raw number , while .as(...) gives a quantity . These names are used consistently in this way throughout the library. For example, we\u2019ll learn in the next tutorial that round_in(...) produces a raw number , while round_as(...) produces a quantity . Prefer .as(...) when you have a choice, because it stays within the safety of the library. Both conversion functions include safety checks . This means you can generally just use them , and rely on the library to guard against the biggest risks. Here are the details to remember about these safety checks. We forbid conversions with mismatched dimensions (as with any units library). We forbid conversions for integer destinations unless we\u2019re sure we\u2019ll always have an integer (as with the chrono library ), and we don\u2019t have excessive overflow risk (an Au-original feature!). You can force a conversion that is meaningful, but considered dangerous by providing an explicit target Rep as a template parameter. For example: seconds(200).as(minutes) won\u2019t compile, but seconds(200).as<int>(minutes) gives minutes(3) , because we forced this lossy conversion with the explicit <int> . Use this sparingly, since the safety checks are there for a reason, and consider adding a comment to explain why your usage is safe. You can never force a conversion to a different dimension, because this is not meaningful. Any conversion allowed by .as(...) will also work as an implicit conversion . For example, if you have an API which takes QuantityD<Radians> , you can pass degrees(45) directly to it. Recall that the \u201cRep\u201d is shorthand for the underlying storage type of the quantity. \u21a9","title":"Takeaways"},{"location":"tutorial/exercise/101-quantity-makers/","text":"Au 101: Quantity Makers Exercise \u00b6 Note This is the exercise for the concepts in the tutorial page Au 101: Quantity Makers . We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first. Tip Before you start, make sure you\u2019ve followed the developer\u2019s guide so you\u2019re able to build and test the code! Introduction \u00b6 The point of this exercise is to get some practice making and using quantities. We\u2019ll get values into and out of the units library, and we\u2019ll also perform a few operations (simple arithmetic, and streaming output). The file we\u2019ll be working in can be found here, relative to the repository root: \"tutorial/101_quantity_makers.cc\" The following command executes the code: bazel run //tutorial:101_quantity_makers Run it now to make sure everything\u2019s working: it should run to completion, and all tests should pass. Exercise 1: printing quantities \u00b6 Open up the file, \"tutorial/101_quantity_makers.cc\" , and scroll down to the EXERCISE 1(a) section. This takes you to a function, print_raw_number_and_quantity() , where you\u2019ll begin the exercise. Exercise 1(a) Task Solution and Discussion Read through the function print_raw_number_and_quantity() , and uncomment the final two lines. Note that in the second line, we\u2019re streaming a quantity variable to output. What do you expect to see? When you\u2019ve formed an expectation, run the target: bazel run //tutorial:101_quantity_makers What do you see? Did it match your expectations? Here\u2019s what will be printed: track_length_m: 100 track_length: 100 m Note how the unit information has effectively migrated. With the raw double , it was a suffix on the variable name, which means that human readers are responsible for keeping track of it. With the quantity, it becomes a part of the type itself, so the compiler is responsible for keeping track of it. The Au library has a compile-time label for every unit. When we stream the quantity, we first stream its underlying value, and then stream the unit label. Now we have a more interactive example. We\u2019ll create several quantities, and for each one, you need to write how you expect it to be printed. Exercise 1(b) Task Solution and Discussion Scroll down to the PrintsAsExpected test case (just below the EXERCISE 1(b) comment block), and uncomment each test assertion one at a time. Replace the empty string placeholder, \"\" , with the actual string you expect when streaming this quantity. For example, if you see this: EXPECT_EQ ( stream_to_string ( squared ( meters )( 100 )), \"\" ); then you would replace it with this: EXPECT_EQ ( stream_to_string ( squared ( meters )( 100 )), \"100 m^2\" ); When you\u2019re done, your assertions should look something like this: EXPECT_EQ ( stream_to_string ( meters ( 100 )), \"100 m\" ); EXPECT_EQ ( stream_to_string ( meters ( 100.0 ) / seconds ( 8.0 )), \"12.5 m / s\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 12.5 )), \"12.5 m / s\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 10.0 ) / seconds ( 8.0 )), \"1.25 m / s^2\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 10.0 ) * seconds ( 8.0 )), \"80 m\" ); The first is a warm-up problem: a checkpoint to make sure you\u2019re doing the exercise correctly. The second gives an example of a general principle: when we multiply or divide quantities, we can reason independently about the units, and the underlying values. In this case, we know that the result\u2019s underlying value will be 100.0 / 8.0 , that is, 12.5 . And the unit will be meters ( \\text{m} \\text{m} ) divided by seconds ( \\text{s} \\text{s} ), that is, \\text{m} / \\text{s} \\text{m} / \\text{s} . (Notice how the library automatically generates a label for compound units: from the input labels m and s , the compound label m / s is generated at compile time.) The third example represents the same quantity as the second, except that it\u2019s constructed directly via the compound quantity maker , (meters / second) . Again, as in the tutorial page, note the grammar: we write (meters / second) , not (meters / seconds) . The fourth example shows that when we accumulate powers of the same unit, the automatically generated label knows how to represent these. \u201cMeters per second\u201d, divided by \u201cseconds\u201d, gives \u201cmeters per squared second\u201d, labeled as m / s^2 . The fifth example shows that when any unit cancels out completely, it gets dropped from the label. \u201cMeters per second\u201d, times \u201cseconds\u201d, gives simply \u201cmeters\u201d. Exercise 2: implementing with quantities \u00b6 Exercise 2 Task Solution and Discussion Replace the implementation of the function stopping_accel_mpss() with quantities, instead of raw double s. You will probably want to do this in three stages. Create a new quantity variable for each parameter. It should have the same name, minus the unit suffix. For example, for a parameter double duration_s , you would write: const auto duration = seconds ( duration_s ); (Note the unit-safe handoff, between the quantity-maker seconds and the unit suffix _s .) Replace the raw double s in the core computation with their corresponding quantity variables. Note that you\u2019ll need to change both the type (to auto ), and the name (to eliminate the suffix). Use .in(...) to extract the raw double to return. You\u2019ll need to form the correct quantity maker to pass to it. When you\u2019re done, your implementation should look something like this: // Example updated solution: double stopping_accel_mpss ( double initial_speed_mps , double stopping_distance_m ) { const auto initial_speed = ( meters / second )( initial_speed_mps ); const auto stopping_distance = meters ( stopping_distance_m ); const auto accel = - ( initial_speed * initial_speed ) / ( 2.0 * stopping_distance ); return accel . in ( meters / squared ( second )); } Let\u2019s evaluate the code change relative to the original, which we\u2019ll reproduce here for convenience. // Original: double stopping_accel_mpss ( double initial_speed_mps , double stopping_distance_m ) { const double accel_mpss = - ( initial_speed_mps * initial_speed_mps ) / ( 2.0 * stopping_distance_m ); return accel_mpss ; } PRO: The core computation is now protected from unit errors. The core computation is also less cluttered without the unit suffixes. The runtime performance is identical, with even the slightest optimization levels enabled. CON: We\u2019ve added extra lines to turn our double variables into quantities. We haven\u2019t improved unit safety at the callsites at all. Admittedly, this change is pretty marginal for such a short function, but keep in mind that this example is just a baby step. The real power of the library will come when we learn how to use quantities in our API types : our function parameters, return values, and member variables. Then we\u2019ll gain far-reaching improvements that can make development faster and safer across an entire codebase. Summary \u00b6 This exercise showed the basics of how to work with quantities. Here are some skills we practiced: Turning a raw numeric value into a quantity, by calling a quantity maker (for example, meters(5.0) ). Extracting raw numeric values from quantities, by calling .in(...) (for example, accel.in(meters / squared(second)) ). Forming and using compound quantity makers, such as (meters / second)(12.5) . Performing basic operations with quantities, including: Multiplying and dividing them. Streaming them to output (but see the note below). Note I/O streaming support isn\u2019t included in every installation method . For single-file installations, it\u2019s included by default, but can be omitted by choice. For full library installations, one needs to include \"au/io.hh\" to get this functionality. The gist is that it will tend to be either already included, or easily accessible, unless somebody made a conscious decision during the installation to exclude it. Return to the main tutorial page .","title":"Au 101: Quantity Makers Exercise"},{"location":"tutorial/exercise/101-quantity-makers/#au-101-quantity-makers-exercise","text":"Note This is the exercise for the concepts in the tutorial page Au 101: Quantity Makers . We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first. Tip Before you start, make sure you\u2019ve followed the developer\u2019s guide so you\u2019re able to build and test the code!","title":"Au 101: Quantity Makers Exercise"},{"location":"tutorial/exercise/101-quantity-makers/#introduction","text":"The point of this exercise is to get some practice making and using quantities. We\u2019ll get values into and out of the units library, and we\u2019ll also perform a few operations (simple arithmetic, and streaming output). The file we\u2019ll be working in can be found here, relative to the repository root: \"tutorial/101_quantity_makers.cc\" The following command executes the code: bazel run //tutorial:101_quantity_makers Run it now to make sure everything\u2019s working: it should run to completion, and all tests should pass.","title":"Introduction"},{"location":"tutorial/exercise/101-quantity-makers/#exercise-1-printing-quantities","text":"Open up the file, \"tutorial/101_quantity_makers.cc\" , and scroll down to the EXERCISE 1(a) section. This takes you to a function, print_raw_number_and_quantity() , where you\u2019ll begin the exercise. Exercise 1(a) Task Solution and Discussion Read through the function print_raw_number_and_quantity() , and uncomment the final two lines. Note that in the second line, we\u2019re streaming a quantity variable to output. What do you expect to see? When you\u2019ve formed an expectation, run the target: bazel run //tutorial:101_quantity_makers What do you see? Did it match your expectations? Here\u2019s what will be printed: track_length_m: 100 track_length: 100 m Note how the unit information has effectively migrated. With the raw double , it was a suffix on the variable name, which means that human readers are responsible for keeping track of it. With the quantity, it becomes a part of the type itself, so the compiler is responsible for keeping track of it. The Au library has a compile-time label for every unit. When we stream the quantity, we first stream its underlying value, and then stream the unit label. Now we have a more interactive example. We\u2019ll create several quantities, and for each one, you need to write how you expect it to be printed. Exercise 1(b) Task Solution and Discussion Scroll down to the PrintsAsExpected test case (just below the EXERCISE 1(b) comment block), and uncomment each test assertion one at a time. Replace the empty string placeholder, \"\" , with the actual string you expect when streaming this quantity. For example, if you see this: EXPECT_EQ ( stream_to_string ( squared ( meters )( 100 )), \"\" ); then you would replace it with this: EXPECT_EQ ( stream_to_string ( squared ( meters )( 100 )), \"100 m^2\" ); When you\u2019re done, your assertions should look something like this: EXPECT_EQ ( stream_to_string ( meters ( 100 )), \"100 m\" ); EXPECT_EQ ( stream_to_string ( meters ( 100.0 ) / seconds ( 8.0 )), \"12.5 m / s\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 12.5 )), \"12.5 m / s\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 10.0 ) / seconds ( 8.0 )), \"1.25 m / s^2\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 10.0 ) * seconds ( 8.0 )), \"80 m\" ); The first is a warm-up problem: a checkpoint to make sure you\u2019re doing the exercise correctly. The second gives an example of a general principle: when we multiply or divide quantities, we can reason independently about the units, and the underlying values. In this case, we know that the result\u2019s underlying value will be 100.0 / 8.0 , that is, 12.5 . And the unit will be meters ( \\text{m} \\text{m} ) divided by seconds ( \\text{s} \\text{s} ), that is, \\text{m} / \\text{s} \\text{m} / \\text{s} . (Notice how the library automatically generates a label for compound units: from the input labels m and s , the compound label m / s is generated at compile time.) The third example represents the same quantity as the second, except that it\u2019s constructed directly via the compound quantity maker , (meters / second) . Again, as in the tutorial page, note the grammar: we write (meters / second) , not (meters / seconds) . The fourth example shows that when we accumulate powers of the same unit, the automatically generated label knows how to represent these. \u201cMeters per second\u201d, divided by \u201cseconds\u201d, gives \u201cmeters per squared second\u201d, labeled as m / s^2 . The fifth example shows that when any unit cancels out completely, it gets dropped from the label. \u201cMeters per second\u201d, times \u201cseconds\u201d, gives simply \u201cmeters\u201d.","title":"Exercise 1: printing quantities"},{"location":"tutorial/exercise/101-quantity-makers/#exercise-2-implementing-with-quantities","text":"Exercise 2 Task Solution and Discussion Replace the implementation of the function stopping_accel_mpss() with quantities, instead of raw double s. You will probably want to do this in three stages. Create a new quantity variable for each parameter. It should have the same name, minus the unit suffix. For example, for a parameter double duration_s , you would write: const auto duration = seconds ( duration_s ); (Note the unit-safe handoff, between the quantity-maker seconds and the unit suffix _s .) Replace the raw double s in the core computation with their corresponding quantity variables. Note that you\u2019ll need to change both the type (to auto ), and the name (to eliminate the suffix). Use .in(...) to extract the raw double to return. You\u2019ll need to form the correct quantity maker to pass to it. When you\u2019re done, your implementation should look something like this: // Example updated solution: double stopping_accel_mpss ( double initial_speed_mps , double stopping_distance_m ) { const auto initial_speed = ( meters / second )( initial_speed_mps ); const auto stopping_distance = meters ( stopping_distance_m ); const auto accel = - ( initial_speed * initial_speed ) / ( 2.0 * stopping_distance ); return accel . in ( meters / squared ( second )); } Let\u2019s evaluate the code change relative to the original, which we\u2019ll reproduce here for convenience. // Original: double stopping_accel_mpss ( double initial_speed_mps , double stopping_distance_m ) { const double accel_mpss = - ( initial_speed_mps * initial_speed_mps ) / ( 2.0 * stopping_distance_m ); return accel_mpss ; } PRO: The core computation is now protected from unit errors. The core computation is also less cluttered without the unit suffixes. The runtime performance is identical, with even the slightest optimization levels enabled. CON: We\u2019ve added extra lines to turn our double variables into quantities. We haven\u2019t improved unit safety at the callsites at all. Admittedly, this change is pretty marginal for such a short function, but keep in mind that this example is just a baby step. The real power of the library will come when we learn how to use quantities in our API types : our function parameters, return values, and member variables. Then we\u2019ll gain far-reaching improvements that can make development faster and safer across an entire codebase.","title":"Exercise 2: implementing with quantities"},{"location":"tutorial/exercise/101-quantity-makers/#summary","text":"This exercise showed the basics of how to work with quantities. Here are some skills we practiced: Turning a raw numeric value into a quantity, by calling a quantity maker (for example, meters(5.0) ). Extracting raw numeric values from quantities, by calling .in(...) (for example, accel.in(meters / squared(second)) ). Forming and using compound quantity makers, such as (meters / second)(12.5) . Performing basic operations with quantities, including: Multiplying and dividing them. Streaming them to output (but see the note below). Note I/O streaming support isn\u2019t included in every installation method . For single-file installations, it\u2019s included by default, but can be omitted by choice. For full library installations, one needs to include \"au/io.hh\" to get this functionality. The gist is that it will tend to be either already included, or easily accessible, unless somebody made a conscious decision during the installation to exclude it. Return to the main tutorial page .","title":"Summary"},{"location":"tutorial/exercise/102-api-types/","text":"Au 102: API Types Exercise \u00b6 Note This is the exercise for the concepts in the tutorial page Au 102: API Types . We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first. Tip Before you start, make sure you\u2019ve followed the developer\u2019s guide so you\u2019re able to build and test the code! Introduction: the legacy function \u00b6 Here\u2019s a simple example of a function that deals with physical quantities, but lacks unit safety because it\u2019s using raw numeric types. // The distance (in meters) it would take to stop, with a given starting speed // and constant (negative) acceleration. // // Parameters: // - speed_mps: The starting speed, in meters per second. // - acceleration_mpss: The braking acceleration, in meters per second squared. // // Preconditions: // - speed_mps >= 0.0 // - acceleration_mpss < 0.0 constexpr double stopping_distance_m ( double speed_mps , double acceleration_mpss ); We\u2019re going to provide a unit-safe interface for any clients that want to use it. We\u2019ll leave the old interface in place, so we won\u2019t be forced to update our codebase all at once! To make sure you\u2019re set up and ready to go, run bazel test //tutorial:102_api_types_test . All tests should pass. The three files we\u2019ll be working in can be found here, relative to the repository root: \"tutorial/102_api_types.hh\" \"tutorial/102_api_types.cc\" \"tutorial/102_api_types_test.cc\" Exercise 1: new interface shim \u00b6 Open up the test file, \"tutorial/102_api_types_test.cc\" , and scroll down to the EXERCISE 1 section. You\u2019ll find two test cases below, which are commented out. Uncomment them, and rerun the tests. As before: bazel test //tutorial:102_api_types_test They\u2019ll fail. Exercise 1(a) Task Solution and Discussion Make these new tests compile by declaring a new function, in \"tutorial/102_api_types.hh\" , with this signature: AAA stopping_distance ( BBB speed , CCC acceleration ); The types AAA , BBB , and CCC are placeholders for quantity types; it\u2019s your job to figure out the actual types which should go there. The Rep for each quantity should be double , since that\u2019s what the function we\u2019re replacing uses. As for the Unit , you may find it useful to define appropriate aliases for, say, MetersPerSecond and MetersPerSecondSquared . Something like this inside of your \"tutorial/102_api_types.hh\" file should work: using MetersPerSecond = decltype ( Meters {} / Seconds {}); using MetersPerSecondSquared = decltype ( MetersPerSecond {} / Seconds {}); QuantityD < Meters > stopping_distance ( QuantityD < MetersPerSecond > speed , QuantityD < MetersPerSecondSquared > acceleration ); First, we declared the aliases for the compound units. Then, we made a new signature with quantity types instead of raw double . We used the QuantityD<U> form, rather than Quantity<U, double> , for conciseness. Warning When composing unit type instances (like Meters{} ), we don\u2019t get the same fluency as when we compose quantity makers (like meters ). In particular, we can\u2019t offer the same grammatical fluency. With quantity makers, we would write meters / second . However, with unit type instances, we end up needing to write Meters{} / Seconds{} , rather than Meters{} / Second{} . Note that we also removed the suffixes (such as _m , _mps , and _mpss ) from the variable and function names. Those suffixes were there to help humans keep track of units. Now that\u2019s the compiler\u2019s job! If we rerun the tests now, we\u2019ll find we get a linker error rather than a compiler error. This makes sense: our function hasn\u2019t been implemented yet. Exercise 1(a) Task Solution and Discussion Go to 102_api_types.cc , and implement the function you had just declared. Your function implementation should amount to a thin wrapper on the existing function. First, we\u2019ll \u201cunwrap\u201d the input quantity parameters, giving us raw double values we can pass to the old version. Then, we\u2019ll \u201cwrap\u201d the answer with the appropriate quantity maker. Something like this inside of your \"tutorial/102_api_types.cc\" file should work: QuantityD < Meters > stopping_distance ( QuantityD < MetersPerSecond > speed , QuantityD < MetersPerSecondSquared > acceleration ) { return meters ( stopping_distance_m ( speed . in ( meters / second ), acceleration . in ( meters / squared ( second )))); } Notice how we have a unit-safe handoff on the output. We\u2019re passing the result of stopping_distance_m(...) to meters(...) , and we can see that the units match. We don\u2019t have a unit-safe handoff on the inputs . The only way to check they\u2019re correct is by carefully inspecting the order and comparing to the signature of stopping_distance_m() . Fortunately, that function lives in the same file, so it\u2019s not too onerous to verify the correctness. Reminder about .in(...) syntax The argument you pass needs to be an instance , not a type . It may be tempting to call speed.in(MetersPerSecond) , but that\u2019s not valid C++ (you can\u2019t \u201cpass a type\u201d to a function). That\u2019s why we passed the quantity maker instead: speed.in(meters / second) . Exercise 2: reverse the roles \u00b6 At this point, we\u2019re in pretty decent shape. We\u2019ve provided a unit-safe interface which anyone can take advantage of. And we\u2019ve left the old interface in place, so we haven\u2019t broken any existing clients! However, we can do a lot better. First, if you read the commentary in the previous section\u2019s solution, you\u2019ll know that the input parameters don\u2019t have a unit-safe handoff. That\u2019s a small problem. A bigger problem is that we\u2019re not taking full advantage of the units library in our implementation itself! To see why this matters, introduce a unit error by deleting the * t_s from the end of the implementation: return speed_mps * t_s + 0.5 * acceleration_mpss * t_s * t_s ; // Delete this---^^^^^^ Save the file and rerun all the tests. Even though the implementation is wrong, the tests all pass! Note that we\u2019re adding a distance and a speed here. If we were using quantities , the wrong code wouldn\u2019t even compile . (That said: in a real project, this would also be a good signal to add more test cases, too. ) Undo the error you introduced. Now you\u2019re ready to fix both these problems at once. Exercise 2 Task Solution and Discussion Reverse the roles of the functions. Use quantity types for the core logic . Turn the raw numeric version into the thin wrapper . All existing tests should pass without modification. Something like this inside of your \"tutorial/102_api_types.cc\" file should work: double stopping_distance_m ( double speed_mps , double acceleration_mpss ) { // Convenient ad hoc quantity makers, for readability. constexpr auto mps = meters / second ; constexpr auto mpss = meters / squared ( second ); return stopping_distance ( mps ( speed_mps ), mpss ( acceleration_mpss )). in ( meters ); } QuantityD < Meters > stopping_distance ( QuantityD < MetersPerSecond > speed , QuantityD < MetersPerSecondSquared > acceleration ) { // This first implementation uses only the most basic kinematic equations. // We could refactor it later to be more efficient. // t = (v - v0) / a const auto t = - speed / acceleration ; // (x - x0) = (v0 * t) + (1/2)(a * t^2) return speed * t + 0.5 * acceleration * t * t ; } Here, we chose to separate out the construction of our quantity makers, so we could make the \u201creal\u201d line more concise and readable. This has no impact on performance either way, but in this case it makes the unit-safe handoffs easier to see at a glance. Do whatever makes your code the most readable! As for the \u201ccore logic\u201d implementation, note how it turns out to be much cleaner without the unit suffixes clogging up the variable name. It\u2019s also more robust. If you try introducing the same unit error we did up above, you should find that it gets caught at compile time. Summary \u00b6 This exercise showed how you can upgrade the unit safety of your codebase incrementally , without forcing huge changes across your project. You can provide a new, unit-safe API which coexists with the old one, which becomes a thin wrapper. You can migrate your clients independently in small batches. And when they\u2019re all migrated, simply delete the old one! Tip As you become more proficient with the library, you may prefer to skip straight to the second step, and turn the old function into the \u201cshim\u201d right away. This is generally a better approach. Return to the main tutorial page .","title":"Au 102: API Types Exercise"},{"location":"tutorial/exercise/102-api-types/#au-102-api-types-exercise","text":"Note This is the exercise for the concepts in the tutorial page Au 102: API Types . We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first. Tip Before you start, make sure you\u2019ve followed the developer\u2019s guide so you\u2019re able to build and test the code!","title":"Au 102: API Types Exercise"},{"location":"tutorial/exercise/102-api-types/#introduction-the-legacy-function","text":"Here\u2019s a simple example of a function that deals with physical quantities, but lacks unit safety because it\u2019s using raw numeric types. // The distance (in meters) it would take to stop, with a given starting speed // and constant (negative) acceleration. // // Parameters: // - speed_mps: The starting speed, in meters per second. // - acceleration_mpss: The braking acceleration, in meters per second squared. // // Preconditions: // - speed_mps >= 0.0 // - acceleration_mpss < 0.0 constexpr double stopping_distance_m ( double speed_mps , double acceleration_mpss ); We\u2019re going to provide a unit-safe interface for any clients that want to use it. We\u2019ll leave the old interface in place, so we won\u2019t be forced to update our codebase all at once! To make sure you\u2019re set up and ready to go, run bazel test //tutorial:102_api_types_test . All tests should pass. The three files we\u2019ll be working in can be found here, relative to the repository root: \"tutorial/102_api_types.hh\" \"tutorial/102_api_types.cc\" \"tutorial/102_api_types_test.cc\"","title":"Introduction: the legacy function"},{"location":"tutorial/exercise/102-api-types/#exercise-1-new-interface-shim","text":"Open up the test file, \"tutorial/102_api_types_test.cc\" , and scroll down to the EXERCISE 1 section. You\u2019ll find two test cases below, which are commented out. Uncomment them, and rerun the tests. As before: bazel test //tutorial:102_api_types_test They\u2019ll fail. Exercise 1(a) Task Solution and Discussion Make these new tests compile by declaring a new function, in \"tutorial/102_api_types.hh\" , with this signature: AAA stopping_distance ( BBB speed , CCC acceleration ); The types AAA , BBB , and CCC are placeholders for quantity types; it\u2019s your job to figure out the actual types which should go there. The Rep for each quantity should be double , since that\u2019s what the function we\u2019re replacing uses. As for the Unit , you may find it useful to define appropriate aliases for, say, MetersPerSecond and MetersPerSecondSquared . Something like this inside of your \"tutorial/102_api_types.hh\" file should work: using MetersPerSecond = decltype ( Meters {} / Seconds {}); using MetersPerSecondSquared = decltype ( MetersPerSecond {} / Seconds {}); QuantityD < Meters > stopping_distance ( QuantityD < MetersPerSecond > speed , QuantityD < MetersPerSecondSquared > acceleration ); First, we declared the aliases for the compound units. Then, we made a new signature with quantity types instead of raw double . We used the QuantityD<U> form, rather than Quantity<U, double> , for conciseness. Warning When composing unit type instances (like Meters{} ), we don\u2019t get the same fluency as when we compose quantity makers (like meters ). In particular, we can\u2019t offer the same grammatical fluency. With quantity makers, we would write meters / second . However, with unit type instances, we end up needing to write Meters{} / Seconds{} , rather than Meters{} / Second{} . Note that we also removed the suffixes (such as _m , _mps , and _mpss ) from the variable and function names. Those suffixes were there to help humans keep track of units. Now that\u2019s the compiler\u2019s job! If we rerun the tests now, we\u2019ll find we get a linker error rather than a compiler error. This makes sense: our function hasn\u2019t been implemented yet. Exercise 1(a) Task Solution and Discussion Go to 102_api_types.cc , and implement the function you had just declared. Your function implementation should amount to a thin wrapper on the existing function. First, we\u2019ll \u201cunwrap\u201d the input quantity parameters, giving us raw double values we can pass to the old version. Then, we\u2019ll \u201cwrap\u201d the answer with the appropriate quantity maker. Something like this inside of your \"tutorial/102_api_types.cc\" file should work: QuantityD < Meters > stopping_distance ( QuantityD < MetersPerSecond > speed , QuantityD < MetersPerSecondSquared > acceleration ) { return meters ( stopping_distance_m ( speed . in ( meters / second ), acceleration . in ( meters / squared ( second )))); } Notice how we have a unit-safe handoff on the output. We\u2019re passing the result of stopping_distance_m(...) to meters(...) , and we can see that the units match. We don\u2019t have a unit-safe handoff on the inputs . The only way to check they\u2019re correct is by carefully inspecting the order and comparing to the signature of stopping_distance_m() . Fortunately, that function lives in the same file, so it\u2019s not too onerous to verify the correctness. Reminder about .in(...) syntax The argument you pass needs to be an instance , not a type . It may be tempting to call speed.in(MetersPerSecond) , but that\u2019s not valid C++ (you can\u2019t \u201cpass a type\u201d to a function). That\u2019s why we passed the quantity maker instead: speed.in(meters / second) .","title":"Exercise 1: new interface shim"},{"location":"tutorial/exercise/102-api-types/#exercise-2-reverse-the-roles","text":"At this point, we\u2019re in pretty decent shape. We\u2019ve provided a unit-safe interface which anyone can take advantage of. And we\u2019ve left the old interface in place, so we haven\u2019t broken any existing clients! However, we can do a lot better. First, if you read the commentary in the previous section\u2019s solution, you\u2019ll know that the input parameters don\u2019t have a unit-safe handoff. That\u2019s a small problem. A bigger problem is that we\u2019re not taking full advantage of the units library in our implementation itself! To see why this matters, introduce a unit error by deleting the * t_s from the end of the implementation: return speed_mps * t_s + 0.5 * acceleration_mpss * t_s * t_s ; // Delete this---^^^^^^ Save the file and rerun all the tests. Even though the implementation is wrong, the tests all pass! Note that we\u2019re adding a distance and a speed here. If we were using quantities , the wrong code wouldn\u2019t even compile . (That said: in a real project, this would also be a good signal to add more test cases, too. ) Undo the error you introduced. Now you\u2019re ready to fix both these problems at once. Exercise 2 Task Solution and Discussion Reverse the roles of the functions. Use quantity types for the core logic . Turn the raw numeric version into the thin wrapper . All existing tests should pass without modification. Something like this inside of your \"tutorial/102_api_types.cc\" file should work: double stopping_distance_m ( double speed_mps , double acceleration_mpss ) { // Convenient ad hoc quantity makers, for readability. constexpr auto mps = meters / second ; constexpr auto mpss = meters / squared ( second ); return stopping_distance ( mps ( speed_mps ), mpss ( acceleration_mpss )). in ( meters ); } QuantityD < Meters > stopping_distance ( QuantityD < MetersPerSecond > speed , QuantityD < MetersPerSecondSquared > acceleration ) { // This first implementation uses only the most basic kinematic equations. // We could refactor it later to be more efficient. // t = (v - v0) / a const auto t = - speed / acceleration ; // (x - x0) = (v0 * t) + (1/2)(a * t^2) return speed * t + 0.5 * acceleration * t * t ; } Here, we chose to separate out the construction of our quantity makers, so we could make the \u201creal\u201d line more concise and readable. This has no impact on performance either way, but in this case it makes the unit-safe handoffs easier to see at a glance. Do whatever makes your code the most readable! As for the \u201ccore logic\u201d implementation, note how it turns out to be much cleaner without the unit suffixes clogging up the variable name. It\u2019s also more robust. If you try introducing the same unit error we did up above, you should find that it gets caught at compile time.","title":"Exercise 2: reverse the roles"},{"location":"tutorial/exercise/102-api-types/#summary","text":"This exercise showed how you can upgrade the unit safety of your codebase incrementally , without forcing huge changes across your project. You can provide a new, unit-safe API which coexists with the old one, which becomes a thin wrapper. You can migrate your clients independently in small batches. And when they\u2019re all migrated, simply delete the old one! Tip As you become more proficient with the library, you may prefer to skip straight to the second step, and turn the old function into the \u201cshim\u201d right away. This is generally a better approach. Return to the main tutorial page .","title":"Summary"},{"location":"tutorial/exercise/103-unit-conversions/","text":"Au 103: Unit Conversions Exercise \u00b6 Note This is the exercise for the concepts in the tutorial page Au 103: Unit Conversions . We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first. Tip Before you start, make sure you\u2019ve followed the developer\u2019s guide so you\u2019re able to build and test the code! Introduction \u00b6 This exercise is a chance to practice unit conversions. The file we\u2019ll be working in can be found here, relative to the repository root: \"tutorial/103_unit_conversions_test.cc\" The following command executes the tests. bazel test --test_output = all //tutorial:103_unit_conversions_test Exercise 1: ad hoc conversions \u00b6 We\u2019ll practice writing some ad hoc conversions that can replace their more labor-intensive, error-prone manual counterparts. Since these both start and end with raw numeric types, we\u2019ll use .in rather than .as , even though the latter is generally preferred whenever we have a choice. (Perhaps a future refactoring could replace these raw numeric types with quantities in the rest of this hypothetical codebase. ) Open up the file, \"tutorial/103_unit_conversions_test.cc\" , and scroll down to the EXERCISE 1 section. This takes you to two unit tests in the AdHocConversions group: DegreesToRadians , and MilesPerHourToMetersPerSecond . In each test, find the unit conversion, which is currently done with manual conversion factors. Replace it with an ad hoc inline conversion based on Au. Exercise 1(a) Task Solution and Discussion Convert the DegreesToRadians test: TEST ( AdHocConversions , DegreesToRadians ) { constexpr double angle_deg = 135.0 ; constexpr double RAD_PER_DEG = M_PI / 180.0 ; // TODO: replace `angle_rad` computation with an ad hoc conversion, using Au. constexpr double angle_rad = angle_deg * RAD_PER_DEG ; EXPECT_DOUBLE_EQ ( angle_rad , 3.0 * M_PI / 4.0 ); } A possible solution: TEST ( AdHocConversions , DegreesToRadians ) { constexpr double angle_deg = 135.0 ; constexpr double angle_rad = degrees ( angle_deg ). in ( radians ); EXPECT_DOUBLE_EQ ( angle_rad , 3.0 * M_PI / 4.0 ); } Tip Instead of deleting the obsolete lines, we replaced them with blank lines. This lets you go back and forth, using the left and right arrow keys, to see exactly what changed. We start with a unit-safe handoff, degrees(angle_deg) , from the _deg suffix to the degrees() function. Then we end with another unit-safe handoff: from .in(radians) to the _rad \u201csuffix\u201d in the variable name. Overall, we can see that this conversion is correct by just reading this single line of code. That\u2019s unit safety! Exercise 1(b) Task Solution and Discussion Convert the MilesPerHourToMetersPerSecond test: TEST ( AdHocConversions , MilesPerHourToMetersPerSecond ) { constexpr double speed_mph = 65.0 ; // Carefully compute conversion factor manually. constexpr double M_PER_CM = 0.01 ; constexpr double CM_PER_INCH = 2.54 ; constexpr double INCHES_PER_FEET = 12.0 ; constexpr double FEET_PER_MILE = 5280.0 ; constexpr double M_PER_MILE = M_PER_CM * CM_PER_INCH * INCHES_PER_FEET * FEET_PER_MILE ; constexpr double S_PER_H = 3600.0 ; constexpr double MPS_PER_MPH = M_PER_MILE / S_PER_H ; // TODO: replace `speed_mps` computation with an ad hoc conversion, using Au. constexpr double speed_mps = speed_mph * MPS_PER_MPH ; EXPECT_DOUBLE_EQ ( speed_mps , 29.0576 ); } A possible solution: TEST ( AdHocConversions , MilesPerHourToMetersPerSecond ) { constexpr double speed_mph = 65.0 ; constexpr double speed_mps = ( miles / hour )( speed_mph ). in ( meters / second ); EXPECT_DOUBLE_EQ ( speed_mps , 29.0576 ); } Tip Instead of deleting the obsolete lines, we replaced them with blank lines. This lets you go back and forth, using the left and right arrow keys, to see exactly what changed. As before, we start and end our conversion with unit-safe handoffs . The units themselves are a little more complicated than before because they\u2019re compound units, but overall this Au-based conversion has similar readability to the one from the previous example. We can\u2019t say the same for the code it replaced, however \u2014 it\u2019s much more complicated than the previous example! In order to write it in a form which is clearly correct, we need to chain together a string of carefully named elementary conversion factors. Even once we do, it probably takes some squinting to convince yourself that MPS_PER_MPH really is \u201cmeters-per-mile\u201d divided by \u201cseconds-per-hour\u201d. The Au-based conversion is a huge improvement in readability and simplicity, as evidenced by all the whitespace above (which we can now remove). Exercise 2: decomposing inches onto feet-and-inches \u00b6 Now we want to take a height in inches, and decompose it so we can represent it as some integer number of feet, plus some integer number of inches which measures less than a foot. Scroll down to the function decompose_height() , and fill in the PLACEHOLDER instances with correct expressions that will make the test below pass. You may find it useful to use the explicit-Rep overload to force a conversion that is generally risky, but in this instance is known to be OK. You should not need to use floating point numbers at all. Exercise 1(b) Task Solution and Discussion Replace PLACEHOLDER instances with correct expressions. // Decompose a height, given in inches, into the largest whole number of feet, plus the leftover // inches. For example, `inches(17)` would be decomposed into `Height{feet(1), inches(5)}`. Height decompose_height ( QuantityU32 < Inches > total_height ) { Height h ; h . feet = PLACEHOLDER ; h . inches = PLACEHOLDER ; return h ; } A possible solution: // Decompose a height, given in inches, into the largest whole number of feet, plus the leftover // inches. For example, `inches(17)` would be decomposed into `Height{feet(1), inches(5)}`. Height decompose_height ( QuantityU32 < Inches > total_height ) { Height h ; h . feet = total_height . as < uint32_t > ( feet ); // NOTE: truncation is intended. h . inches = total_height - h . feet . as ( inches ); return h ; } If we convert the total height from inches to feet, and force it to remain an integer, it will truncate. In this case, that\u2019s actually the desired behaviour! (Of course, it\u2019s nice to leave a comment to reassure the reader.) We can then reduce the total height by this integral number of feet, and we obtain the leftover inches. Tip As it happens, the .as(inches) is unnecessary. You can subtract a QuantityU32<Feet> from a QuantityU32<Inches> directly! If you do, the quantity of feet will be automatically converted to inches, because inches is a \u201ccommon unit\u201d in which we can express both quantities. However, common units will be the topic of a later, 200-level tutorial, so we wrote the example solution using only constructs you\u2019ve already seen. Summary \u00b6 This exercise gave a few worked examples of unit conversions. We saw how Au can immediately replace crufty, error-prone manual conversions, making code more readable. We also saw a practical example of quantity-to-quantity conversion using .as(...) , including one example where the forcing \u201cexplicit-Rep\u201d form is clearly safe and correct to use. Return to the main tutorial page .","title":"Au 103: Unit Conversions Exercise"},{"location":"tutorial/exercise/103-unit-conversions/#au-103-unit-conversions-exercise","text":"Note This is the exercise for the concepts in the tutorial page Au 103: Unit Conversions . We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first. Tip Before you start, make sure you\u2019ve followed the developer\u2019s guide so you\u2019re able to build and test the code!","title":"Au 103: Unit Conversions Exercise"},{"location":"tutorial/exercise/103-unit-conversions/#introduction","text":"This exercise is a chance to practice unit conversions. The file we\u2019ll be working in can be found here, relative to the repository root: \"tutorial/103_unit_conversions_test.cc\" The following command executes the tests. bazel test --test_output = all //tutorial:103_unit_conversions_test","title":"Introduction"},{"location":"tutorial/exercise/103-unit-conversions/#exercise-1-ad-hoc-conversions","text":"We\u2019ll practice writing some ad hoc conversions that can replace their more labor-intensive, error-prone manual counterparts. Since these both start and end with raw numeric types, we\u2019ll use .in rather than .as , even though the latter is generally preferred whenever we have a choice. (Perhaps a future refactoring could replace these raw numeric types with quantities in the rest of this hypothetical codebase. ) Open up the file, \"tutorial/103_unit_conversions_test.cc\" , and scroll down to the EXERCISE 1 section. This takes you to two unit tests in the AdHocConversions group: DegreesToRadians , and MilesPerHourToMetersPerSecond . In each test, find the unit conversion, which is currently done with manual conversion factors. Replace it with an ad hoc inline conversion based on Au. Exercise 1(a) Task Solution and Discussion Convert the DegreesToRadians test: TEST ( AdHocConversions , DegreesToRadians ) { constexpr double angle_deg = 135.0 ; constexpr double RAD_PER_DEG = M_PI / 180.0 ; // TODO: replace `angle_rad` computation with an ad hoc conversion, using Au. constexpr double angle_rad = angle_deg * RAD_PER_DEG ; EXPECT_DOUBLE_EQ ( angle_rad , 3.0 * M_PI / 4.0 ); } A possible solution: TEST ( AdHocConversions , DegreesToRadians ) { constexpr double angle_deg = 135.0 ; constexpr double angle_rad = degrees ( angle_deg ). in ( radians ); EXPECT_DOUBLE_EQ ( angle_rad , 3.0 * M_PI / 4.0 ); } Tip Instead of deleting the obsolete lines, we replaced them with blank lines. This lets you go back and forth, using the left and right arrow keys, to see exactly what changed. We start with a unit-safe handoff, degrees(angle_deg) , from the _deg suffix to the degrees() function. Then we end with another unit-safe handoff: from .in(radians) to the _rad \u201csuffix\u201d in the variable name. Overall, we can see that this conversion is correct by just reading this single line of code. That\u2019s unit safety! Exercise 1(b) Task Solution and Discussion Convert the MilesPerHourToMetersPerSecond test: TEST ( AdHocConversions , MilesPerHourToMetersPerSecond ) { constexpr double speed_mph = 65.0 ; // Carefully compute conversion factor manually. constexpr double M_PER_CM = 0.01 ; constexpr double CM_PER_INCH = 2.54 ; constexpr double INCHES_PER_FEET = 12.0 ; constexpr double FEET_PER_MILE = 5280.0 ; constexpr double M_PER_MILE = M_PER_CM * CM_PER_INCH * INCHES_PER_FEET * FEET_PER_MILE ; constexpr double S_PER_H = 3600.0 ; constexpr double MPS_PER_MPH = M_PER_MILE / S_PER_H ; // TODO: replace `speed_mps` computation with an ad hoc conversion, using Au. constexpr double speed_mps = speed_mph * MPS_PER_MPH ; EXPECT_DOUBLE_EQ ( speed_mps , 29.0576 ); } A possible solution: TEST ( AdHocConversions , MilesPerHourToMetersPerSecond ) { constexpr double speed_mph = 65.0 ; constexpr double speed_mps = ( miles / hour )( speed_mph ). in ( meters / second ); EXPECT_DOUBLE_EQ ( speed_mps , 29.0576 ); } Tip Instead of deleting the obsolete lines, we replaced them with blank lines. This lets you go back and forth, using the left and right arrow keys, to see exactly what changed. As before, we start and end our conversion with unit-safe handoffs . The units themselves are a little more complicated than before because they\u2019re compound units, but overall this Au-based conversion has similar readability to the one from the previous example. We can\u2019t say the same for the code it replaced, however \u2014 it\u2019s much more complicated than the previous example! In order to write it in a form which is clearly correct, we need to chain together a string of carefully named elementary conversion factors. Even once we do, it probably takes some squinting to convince yourself that MPS_PER_MPH really is \u201cmeters-per-mile\u201d divided by \u201cseconds-per-hour\u201d. The Au-based conversion is a huge improvement in readability and simplicity, as evidenced by all the whitespace above (which we can now remove).","title":"Exercise 1: ad hoc conversions"},{"location":"tutorial/exercise/103-unit-conversions/#exercise-2-decomposing-inches-onto-feet-and-inches","text":"Now we want to take a height in inches, and decompose it so we can represent it as some integer number of feet, plus some integer number of inches which measures less than a foot. Scroll down to the function decompose_height() , and fill in the PLACEHOLDER instances with correct expressions that will make the test below pass. You may find it useful to use the explicit-Rep overload to force a conversion that is generally risky, but in this instance is known to be OK. You should not need to use floating point numbers at all. Exercise 1(b) Task Solution and Discussion Replace PLACEHOLDER instances with correct expressions. // Decompose a height, given in inches, into the largest whole number of feet, plus the leftover // inches. For example, `inches(17)` would be decomposed into `Height{feet(1), inches(5)}`. Height decompose_height ( QuantityU32 < Inches > total_height ) { Height h ; h . feet = PLACEHOLDER ; h . inches = PLACEHOLDER ; return h ; } A possible solution: // Decompose a height, given in inches, into the largest whole number of feet, plus the leftover // inches. For example, `inches(17)` would be decomposed into `Height{feet(1), inches(5)}`. Height decompose_height ( QuantityU32 < Inches > total_height ) { Height h ; h . feet = total_height . as < uint32_t > ( feet ); // NOTE: truncation is intended. h . inches = total_height - h . feet . as ( inches ); return h ; } If we convert the total height from inches to feet, and force it to remain an integer, it will truncate. In this case, that\u2019s actually the desired behaviour! (Of course, it\u2019s nice to leave a comment to reassure the reader.) We can then reduce the total height by this integral number of feet, and we obtain the leftover inches. Tip As it happens, the .as(inches) is unnecessary. You can subtract a QuantityU32<Feet> from a QuantityU32<Inches> directly! If you do, the quantity of feet will be automatically converted to inches, because inches is a \u201ccommon unit\u201d in which we can express both quantities. However, common units will be the topic of a later, 200-level tutorial, so we wrote the example solution using only constructs you\u2019ve already seen.","title":"Exercise 2: decomposing inches onto feet-and-inches"},{"location":"tutorial/exercise/103-unit-conversions/#summary","text":"This exercise gave a few worked examples of unit conversions. We saw how Au can immediately replace crufty, error-prone manual conversions, making code more readable. We also saw a practical example of quantity-to-quantity conversion using .as(...) , including one example where the forcing \u201cexplicit-Rep\u201d form is clearly safe and correct to use. Return to the main tutorial page .","title":"Summary"}]}