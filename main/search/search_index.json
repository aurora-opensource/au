{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Au documentation","text":"<p>Welcome to the Au library!  Au (pronounced \u201cay yoo\u201d) is a C++14-compatible units library, by Aurora.  Its key strengths include safety, accessibility, performance, and developer experience.</p> <p>The library source is on GitHub, at aurora-opensource/au.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>These pages will be most useful as you begin your Au journey:</p> <ul> <li> <p>Alternatives.  First off: is Au the right fit for your needs?   What else is out there?  This page gives a detailed comparison to some of the most prominent other   C++ units libraries.</p> </li> <li> <p>Supported Compilers.  Au aims to work with any C++ compiler that   fully supports C++14 or later.  That said, some platform/compiler combinations have more detailed   data.  Learn about our tiers of support and what it takes to add a specific compiler.</p> </li> <li> <p>Installation.  Once you\u2019re ready to try it out, here\u2019s how.  You can be up and   running in any project within minutes!</p> </li> <li> <p>Tutorials.  Start with Au 101: Quantity   Makers, and go forward from there.  You\u2019ll learn the basic   library concepts, and get some hands on experience with the included exercises.</p> </li> </ul>"},{"location":"#continuing-your-journey","title":"Continuing your journey","text":"<p>Once you\u2019re up and running with the library, these pages will be handy tools to help you use it more effectively:</p> <ul> <li> <p>Troubleshooting.  A guide to the most commonly encountered types of   error, what they mean, and how to fix them.  Take key snippets from your compiler errors, and   use in-page search to get help!</p> </li> <li> <p>How-to guides.  Step-by-step instructions for accomplishing common tasks   you may encounter in using the library.</p> </li> <li> <p>Reference.  Detailed reference documentation on <code>Quantity</code>,   <code>QuantityPoint</code>, units, magnitudes, and other core library abstractions.</p> </li> </ul> <p>We also have a GitHub Issues page for tracking problems and future work.  If you have a bug report or feature request, check the existing issues to see if it\u2019s been posted, and file a new one if it hasn\u2019t.  While we can\u2019t promise timely resolution, we will do our best to respond quickly so you know both that you\u2019ve been heard and where we stand on the issue.</p> <p>Tip</p> <p>Feel free to vote for existing issues by reacting to the main post with the  emoji: we\u2019ll take this into account in prioritizing what to work on!</p>"},{"location":"#shoring-up-foundations","title":"Shoring up foundations","text":"<p>When you\u2019re looking to understand the library better (as opposed to actively trying to accomplish some task), these docs will help you strengthen your foundations.</p> <ul> <li>Discussion.  Philosophy and principles, deep dives on design choices,   explanations of core concepts, and more.</li> </ul>"},{"location":"develop/","title":"Development Setup","text":"<p>This page explains how to set up the repository for development.  This is for two main groups of users:</p> <ul> <li>Those who want to contribute to the library, either the code or the docs.</li> <li>Those who want to work through the tutorial exercises.</li> </ul> <p>Tip</p> <p>If all you want to do is install the library in your project, you can simply use our installation guide.</p>"},{"location":"develop/#core-development-setup","title":"Core development setup","text":"<p>These steps are common to all workflows.</p>"},{"location":"develop/#step-0-decide-whether-to-fork","title":"Step 0: Decide whether to fork","text":"<p>If you\u2019re confident that you want to contribute, you should start out by forking the repository. This gives you your own copy which you can modify, and from which you can create pull requests to share your changes with the main repository.  Here are GitHub\u2019s instructions for forking.</p> <p>Everyone else can simply skip this step and work directly from the main repository.  If you decide later on to make a pull request, you\u2019ll still need to create a fork, but it\u2019s easy to set it up after the fact.  We\u2019ll provide detailed instructions below.</p> Instructions for switching an existing clone to a fork <p>If you\u2019re here, you probably cloned the main repository directly, and then later decided to make a pull request.  For that, you\u2019ll need to switch your <code>origin</code> remote to point to your fork instead of the main repository.</p> <p>You can directly use the instructions below, which we adapted from this guide.</p> <ol> <li> <p>Create the fork on GitHub.</p> <p>You will need to note the name of your fork, in the format <code>user_name/repo_name</code>.    Typically, the <code>user_name</code> part will be replaced with your GitHub username, and the    <code>repo_name</code> part will simply be <code>au</code>.</p> </li> <li> <p>Rename <code>origin</code> to <code>upstream</code>.  We still want to track the main repository; we just need    to give it a different name.  Run this command verbatim:</p> <pre><code>git remote rename origin upstream\n</code></pre> </li> <li> <p>Make your fork the new <code>origin</code>.  Your command will start with <code>git remote add origin</code>,    and end with a URL for your repository.  If your GitHub username were <code>user_name</code>, the full    command should look like this:</p> <pre><code>git remote add origin git@github.com:user_name/au.git\n#                                    ^^^^^^^^^\n# Example only: remember to replace user name!\n</code></pre> </li> <li> <p>Fetch from <code>origin</code>.  Run this command verbatim:</p> <pre><code>git fetch origin\n</code></pre> </li> <li> <p>Track <code>origin</code> from <code>main</code>.  Run this command verbatim:</p> <pre><code>git branch -u origin/main main\n</code></pre> </li> </ol> <p>At this point, you should be able to create a pull request in the usual way, simply by pushing a local branch to your fork via the <code>origin</code> remote.</p>"},{"location":"develop/#step-1-clone-the-repository","title":"Step 1: Clone the repository","text":"<p>This step gets the Au source code onto your machine.  The precise details depend on whether you decided to fork or not in the previous step.</p> <p>Did you fork, or not?</p> No fork (default)Fork <p>This is for users who just want to work through the tutorials, or play around with the code.</p> <pre><code>git clone https://github.com/aurora-opensource/au.git\n</code></pre> <p>Follow GitHub\u2019s cloning instructions, using the fork you created as the repository.</p> <p>Whichever approach you took, you should have a folder named <code>au/</code> in your current directory which contains the Au source code.</p>"},{"location":"develop/#step-2-set-up-direnv","title":"Step 2: Set up <code>direnv</code>","text":"<p>direnv is a tool that makes it easy to use the correct version of every tool we use: <code>bazel</code>, <code>clang-format</code>, <code>buildifier</code>, and other project-specific ones like <code>make-single-file</code> and <code>au-docs-serve</code>.  It will add these tools to your <code>$PATH</code>, but only when you\u2019re inside your copy of the repository.</p> What if you skip this step? <p>This step is optional, but highly recommended.  If you skip this step, you\u2019ll need to prepend <code>tools/bin/</code> to every command that comes from Au\u2019s tools directory.  For example,</p> <ul> <li>Replace <code>bazel</code> with <code>tools/bin/bazel</code>.</li> <li>Replace <code>clang-format</code> with <code>tools/bin/clang-format</code>.</li> </ul> <p>And so on.</p> <p>Additionally, if you use <code>direnv</code>, you can run the tools from any folder.  However, if you don\u2019t, you can only run them from the project root folder.</p> <p>The first step to set up <code>direnv</code> is to install the tool itself, using their installation instructions.</p> <p>The next time you enter your Au folder, you\u2019ll get a warning message like this:</p> <pre><code>direnv: error .envrc is blocked. Run `direnv allow` to approve its content.\n</code></pre> <p>Simply do what it says and run <code>direnv allow</code>, and you\u2019re all set!</p> Testing your installation <p>You can test that everything\u2019s working by running <code>bazel --version</code> inside your Au folder.  You should get a result compatible with the current contents of the <code>.bazelversion</code> file.  For example, at the time of writing, we\u2019re on bazel 6.0.0, so this command produces the output:</p> <pre><code>bazel 6.0.0\n</code></pre>"},{"location":"develop/#specific-workflows","title":"Specific workflows","text":"<p>Now that your basic development setup is complete, here are some types of workflows you can do.</p>"},{"location":"develop/#building-and-testing-the-code","title":"Building and testing the code","text":"<p>To build and test the entire repository, run <code>bazel test //...:all</code>.</p> <p>Note</p> <p>The first time you run any command such as <code>bazel</code>, there may be some additional overhead from downloading or configuring the tool itself.  This is a one-time cost, and each subsequent run should be fast.</p> <p>You can also specify any number of specific targets or target patterns, using bazel\u2019s target syntax.  For example, if you wanted to test the core library code (which lives in <code>//au</code>), and test the generated single-file package (whose target is <code>//release:au_hh_test</code>), you could write:</p> <pre><code>bazel test //au:all //release:au_hh_test\n</code></pre>"},{"location":"develop/#using-different-toolchains","title":"Using different toolchains","text":"<p>Au comes pre-packaged with support for several different compiler toolchains.  To use a specific toolchain \u2014 say, <code>X</code> \u2014 pass it as a <code>--config=X</code> argument.  For example, here\u2019s how you would run all of the tests using gcc 10:</p> <pre><code>bazel test --config=gcc10 //...:all\n</code></pre> <p>Here are the possible values we support for <code>--config</code>:</p> <code>--config</code> value compiler <code>clang14</code> Clang 14 (default) <code>clang11</code> Clang 11 <code>gcc10</code> gcc 10 What if your preferred compiler isn\u2019t in this list? <p>Our goal is for Au to work with any standards-compliant compiler that fully supports C++14, or any later language standard.  We\u2019ve had good results with a variety of compilers already, so we recommend simply trying Au in yours!</p> <p>If you do, and you find a bug, please feel free to file an issue.  If the compiler is fully C++14-compatible, we\u2019ll do our best to find a fix, or an acceptable workaround.  We may also consider adding the compiler to our officially supported list, as long as we can use it via a hermetic bazel toolchain.</p>"},{"location":"develop/#building-and-viewing-documentation","title":"Building and viewing documentation","text":"<p>It\u2019s easy to set up a local version of the documentation website.  Simply run the included command, <code>au-docs-serve</code>.  Here\u2019s some example output:</p> <pre><code>INFO: Analyzed target //:update_docs (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //:update_docs up-to-date:\n  bazel-bin/update_docs\nINFO: Elapsed time: 0.309s, Critical Path: 0.06s\nINFO: 1 process: 1 internal.\nINFO: Build completed successfully, 1 total action\nINFO: Build completed successfully, 1 total action\nINFO     -  Building documentation...\nINFO     -  Cleaning site directory\nINFO     -  Documentation built in 0.35 seconds\nINFO     -  [16:02:34] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO     -  [16:02:34] Serving on http://127.0.0.1:8000/au/\n</code></pre> <p>The last line shows that you can view the website at the included (local) URL, <code>http://127.0.0.1:8000/au/</code>.</p> <p>The command stays running until you interrupt it (typically via <code>Ctrl-C</code>, or the equivalent on your terminal).  Note that as long as it stays running, it will automatically regenerate the website whenever you edit any file, and the browser will automatically reload the page!</p> Viewing documentation on a remote machine <p>Some users connect to a remote machine via <code>ssh</code> to do their development.  In this case, <code>au-docs-serve</code> won\u2019t work out of the box.  The reason is that it\u2019s running on your remote machine, but your web browser is on your local machine.  When you try to open the URL <code>http://127.0.0.1:8000/au/</code>, which points to the local machine, it can\u2019t find the web server, because it\u2019s running on the remote machine.</p> <p>The solution is to forward the port, <code>8000</code>, when you connect to your remote machine.  If you do, then local requests on that port will be forwarded along to the remote machine, where the web server is running.  Here\u2019s how you do that.</p> <ol> <li> <p>Find your usual ssh command.  This is whatever you run on your local machine to connect    to the remote host.  For example, if your username is <code>user</code> and your remote hostname is    <code>remote.host</code>, this might look like the following:</p> <pre><code>ssh user@remote.host\n</code></pre> </li> <li> <p>Add an option for port forwarding.  Expanding on the previous example, this would be:</p> <pre><code>ssh -L 8000:localhost:8000 user@remote.host\n#  ^^^^^^^^^^^^^^^^^^^^^^^ Note: this is added\n</code></pre> </li> <li> <p>Run <code>au-docs-serve</code> on the remote host.  Naturally, you\u2019ll need to be in your Au folder    to do this.</p> </li> </ol> <p>At this point, as long as that command stays running on your remote host, you should be able to visit the URL in your local browser, and view the documentation website.</p>"},{"location":"install/","title":"Installation","text":"<p>Au can be installed in multiple ways.  First, we\u2019ll help you decide which one is right for you. Then, we\u2019ll provide full instructions for each option.</p> <p>Broadly, you can either do a \u201cfull install\u201d of the library, or you can package it into a single header file.  For the latter approach, there are two options:</p> <ul> <li>Pre-built versions you can download right away.</li> <li>Custom versions with exactly the units you choose.</li> </ul>"},{"location":"install/#choosing-a-method","title":"Choosing a method","text":"<p>These days, Au supports both bazel and CMake build systems natively.  We also have community support for the most popular C++ package managers, conan and vcpkg.  Setup via any of these methods is pretty quick, so just doing a full install is usually best.</p> <p>The main reason to consider a single-file approach is if you\u2019re not using any of these build systems: clearly, a single file works with any build system imaginable.  The pre-built single file packages are also the quickest way to start playing with the library.</p> <p>Here\u2019s an overview of the tradeoffs involved.</p> Legend Unsupported Fair Good Best Full Install Single File bazel, CMake, conan, vcpkg Other build systems Pre-built Custom Setup time Fast (a few minutes) Full Install unsupported (use single-file instead) Instant Fast (a few minutes) Unit selection Any units desired, without needing \"reinstall\" Base units only(or too many units) Any units desired Compile time cost Each file only pays for the units it uses Cost of core, plus ~10 units Very competitive up to a few dozen units Flexibility        Include I/O, testing utilities, individual units as desired, on a per-file basis             Awkward: would need to download <pre>io.hh</pre> and/or <pre>testing.hh</pre> separately, and       modify their includes manually"},{"location":"install/#installation-instructions","title":"Installation instructions","text":"<p>Here are the instructions for each installation method we support.</p>"},{"location":"install/#full","title":"Full library installation","text":""},{"location":"install/#bazel","title":"bazel","text":"<ol> <li> <p>Choose your Au version.</p> <ul> <li>This can be a tag, or a commit hash.  Let\u2019s take <code>0.3.5</code> as an example.</li> </ul> </li> <li> <p>Form the URL to the archive.</p> <ul> <li>For <code>0.3.5</code>, this would be:   <pre><code>https://github.com/aurora-opensource/au/releases/download/0.3.5/au-0.3.5.tar.gz\n                       NOTE: Your au version ID goes HERE ^^^^^    ^^^^^\n</code></pre></li> </ul> </li> <li> <p>Compute your SHA256 hash.</p> <ol> <li>Follow the URL from the previous step to download the archive.</li> <li>Compute the SHA256 hash: <code>sha256sum au-0.3.5.tar.gz</code></li> <li>The first token that appears is the hash.  Save it for the next step.</li> </ol> </li> <li> <p>Add <code>http_archive</code> rule to <code>WORKSPACE</code>.</p> <ul> <li>Follow this pattern:   <pre><code>http_archive(\n    name = \"au\",\n    sha256 = \"7ec826dc42968dc1633de56e4f9d06e70de73e820d2ac4788e8453343a622c9b\",\n    strip_prefix = \"au-0.3.5\",\n    urls = [\"https://github.com/aurora-opensource/au/releases/download/0.3.5/au-0.3.5.tar.gz\"],\n)\n</code></pre></li> <li>In particular, here\u2019s how to fill out the fields:<ul> <li><code>sha256</code>: Use the SHA256 hash you got from step 3.</li> <li><code>strip_prefix</code>: write <code>\"au-0.3.5\"</code>, except use your ID from step 1 instead of <code>0.3.5</code>.</li> <li><code>urls</code>: This should be a list, whose only entry is the URL you formed in step 2.</li> </ul> </li> </ul> </li> </ol> <p>At this point, the Au library is installed, and you can use it in your project!</p> <p>Here are the headers provided by each Au target.  To use, add the entry from the \u201cDependency\u201d column to your <code>deps</code> attribute, and include the appropriate files.</p> Dependency Headers provided Notes <code>@au//au</code> <code>\"au/au.hh\"</code><code>\"au/fwd.hh\"</code><code>\"au/units/*.hh\"</code><code>\"au/units/*_fwd.hh\"</code> Core library functionality.  See all available units <code>@au//au:io</code> <code>\"au/io.hh\"</code> <code>operator&lt;&lt;</code> support <code>@au//au:testing</code> <code>\"au/testing.hh\"</code> Utilities for writing googletest testsNote: <code>testonly = True</code>"},{"location":"install/#cmake","title":"CMake","text":"<p>There are two ways to include the Au library in your CMake project.</p> <ol> <li> <p>(Recommended) Use the <code>FetchContent</code> module to download the library directly from GitHub.</p> </li> <li> <p>Install the library to the system, and use <code>find_package</code>.</p> </li> </ol> <p>We recommend <code>FetchContent</code> because each project can get the exact version of Au that they need, and can update it independently of other projects.  <code>FetchContent</code> also means you don\u2019t need to manually clone the Au repo, or build and run the tests.  On the other hand, if you want a single global system-wide version of Au, then you can install it to the system, and simply use <code>find_package</code>.</p> <p>In either case, here are the main targets and include files provided by the Au library:</p> Target Headers provided Notes <code>Au::au</code> <code>\"au/au.hh\"</code><code>\"au/fwd.hh\"</code><code>\"au/io.hh\"</code><code>\"au/units/*.hh\"</code><code>\"au/units/*_fwd.hh\"</code> Core library functionality.  See all available units <code>Au::testing</code> <code>\"au/testing.hh\"</code> Utilities for writing googletest tests <p>Note</p> <p>These instructions are for adding Au to a project that uses CMake, not building Au itself using CMake.</p> <p>Au is a bazel-first project, so most Au development would normally be done using bazel. However, we do have instructions for doing this with CMake as well: see the <code>find_package</code> tab below.</p> Using <code>FetchContent</code>Using <code>find_package</code> <p>Add the following to your <code>CMakeLists.txt</code> file:</p> <pre><code>include(FetchContent)\nFetchContent_Declare(\n  Au\n  GIT_REPOSITORY https://github.com/aurora-opensource/au\n  GIT_TAG \"main\"  # Or a specific tag.\n  EXCLUDE_FROM_ALL\n)\nFetchContent_MakeAvailable(Au)\n</code></pre> <p>You should now be able to depend on Au targets, such as <code>Au::au</code> or <code>Au::testing</code>, and include headers from them, such as <code>#include \"au/au.hh\"</code> or <code>#include \"au/testing.hh\"</code>.</p> <p>Before you can use <code>find_package</code>, you need to install the library to your system.  This means cloning the repo, building the library, running the tests, and installing it.</p> <p>First, clone the repository.</p> <pre><code>git clone https://github.com/aurora-opensource/au.git\ncd au\n</code></pre> <p>If you want a specific release, check out the tag you want.  Note that the first version of Au that supports CMake is 0.3.5.</p> <pre><code># Optional, but recommended:\ngit checkout \"0.3.5\"  # Or whichever tag you prefer.\n</code></pre> <p>Now, build and test the library.  These commands will include both the explicit tests, and also several CMake-generated tests to make sure that the includes are set up correctly.</p> <pre><code># CMake is a \"meta build system\", not a build system.\n# This first command generates the actual build files.\ncmake -S . -B cmake/build -DCMAKE_VERIFY_INTERFACE_HEADER_SETS=TRUE\n\n# This command builds Au, checks include paths, and runs unit tests.\ncmake \\\n  --build cmake/build \\\n  --target \\\n    all \\\n    all_verify_interface_header_sets \\\n    test\n</code></pre> <p>If the tests pass, you can install the library to your system.</p> <pre><code>sudo cmake --install cmake/build\n</code></pre> <p>At this point, the <code>Au</code> CMake library is installed to your system, and can be found via the usual <code>find_package</code> mechanism!</p> <pre><code>find_package(Au)\n</code></pre>"},{"location":"install/#package-managers-conan-vcpkg","title":"Package managers (conan, vcpkg)","text":"<p>If you\u2019re using these in your project, we assume you already know how to add new libraries.  These methods have \u201ccommunity support\u201d, which means:</p> <ul> <li>The recipes are added and maintained by external users</li> <li>Au\u2019s maintainers will provide our best effort to respond to issues, but we\u2019ll need to rely on   users of these package managers to help us reproduce and understand them</li> </ul> <p>Each package manager contains setup instructions on its page for Au.  Here are the packages:</p> <ul> <li>Conan: au</li> <li>vcpkg: aurora-au</li> </ul>"},{"location":"install/#single-file","title":"Single file","text":"<p>The Au library can be packaged as a single header file, which you can include in your project just like any other header.  This works with any build system!</p> <p>To take this approach, obtain the single file by one of the methods described below.  Then, put it inside a <code>third_party</code> folder (for example, as <code>third_party/au.hh</code>).  Now you\u2019re up and running with Au!</p> <p>Every single-file package automatically includes the following features:</p> <ul> <li>Basic \u201cunit container\u201d types: <code>Quantity</code>,   <code>QuantityPoint</code></li> <li>Magnitude types and values, including constants for any integer such   as <code>mag&lt;5280&gt;()</code>.</li> <li>All prefixes for SI (<code>kilo</code>, <code>mega</code>, \u2026) and informational (<code>kibi</code>,   <code>mebi</code>, \u2026) quantities.</li> <li>Math functions, including unit-aware rounding and inverses, trigonometric   functions, square roots, and so on.</li> <li>Bidirectional implicit conversion between <code>Quantity</code> types and any equivalent counterparts in the   <code>std::chrono</code> library.</li> </ul> <p>Here are the two ways to get a single-file packaging of the library.</p>"},{"location":"install/#pre-built-single-file","title":"Pre-built single file","text":"<p>Tip</p> <p>This approach is mainly for playing with the library.  It\u2019s very fast to get up and running, but it\u2019s not the best choice as the \u201cproduction\u201d installation of your library.</p> <p>For a single-file approach, most users will be much better served by the next section, which explains how to customize it to get exactly the units you want.</p> <p>We provide pre-generated single-file versions of the library, automatically generated from the latest commit in the repo:</p> <ul> <li><code>au.hh</code></li> <li><code>au_noio.hh</code>   (Same as above, but with <code>&lt;iostream&gt;</code> support stripped out)</li> </ul> <p>These include very few units (to keep compile times short).  However, combinations of these units should get you any other unit you\u2019re likely to want.  The units we include are:</p> <ul> <li>Every SI base unit (<code>seconds</code>, <code>meters</code>, <code>kilo(grams)</code>, <code>amperes</code>, <code>kelvins</code>, <code>moles</code>, <code>candelas</code>)</li> <li>Base units for angles and information (<code>radians</code>, <code>bits</code>)</li> <li>A base dimensionless unit (<code>unos</code>)</li> </ul> <p>Note</p> <p>How do you go about constructing other units from these?  By composing them.  For example, you can make other coherent SI units like this:</p> <pre><code>constexpr auto newtons = kilo(gram) * meters / squared(second);\n</code></pre> <p>Now you can call, say, <code>newtons(10)</code> and get a quantity equivalent to 10 Newtons.  You can also scale a unit by multiplying by Magnitude objects.  For example:</p> <pre><code>constexpr auto degrees = radians * Magnitude&lt;Pi&gt;{} / mag&lt;180&gt;();\n</code></pre> <p>These will \u201cwork\u201d, in the sense of producing correct results.  But these ad hoc unit definitions are far less usable than fully defined units.  Both the type names and the unit symbols will be needlessly complicated.</p> <p>Again, we recommend following the directions in the next section to get exactly the units you care about.</p> Pre-built files with all units <p>We also provide pre-built files with every unit the library knows about.</p> <p>We don\u2019t advertise this option widely, because the library\u2019s compile time slowdown is largely proportional to the number of units included in a translation unit.  Thus, not only will this configuration be the slowest of all, but it will get increasingly slower as the library gets better over time (by supporting more and more units out of the box).</p> <p>Therefore, these files are only for use cases where you don\u2019t care about compile time.  The primary example is the Compiler Explorer (\u201cgodbolt\u201d).</p> <p>If you don\u2019t care about compile times, here are the files:</p> <ul> <li><code>au_all_units.hh</code></li> <li><code>au_all_units_noio.hh</code>   (Same as above, but with <code>&lt;iostream&gt;</code> support stripped out)</li> </ul>"},{"location":"install/#custom-single-file","title":"Custom single file","text":"<p>It\u2019s easy to package the library in a custom single file with exactly the units you need. Here\u2019s how:</p> <ol> <li> <p>Clone the repo.  Go to the aurora-opensource/au    repo, and follow the typical instructions.</p> <ul> <li>If you\u2019re just a user of Au, not a contributor, this should be: <code>git clone https://github.com/aurora-opensource/au.git</code></li> </ul> </li> <li> <p>Run the script.  <code>tools/bin/make-single-file --units meters seconds newtons &gt; ~/au.hh</code>    creates a file, <code>~/au.hh</code>, which packages the entire library in a single file with these three    units.</p> <ul> <li>To see the full list of available units, search the <code>.hh</code> files in the <code>au/units/</code> folder. For   example, <code>meters</code> will include the contents of <code>au/units/meters.hh</code>.</li> <li>Provide the <code>--noio</code> flag if you prefer to avoid the expense of the <code>&lt;iostream&gt;</code> library.</li> </ul> </li> </ol> <p>Now you have a file, <code>~/au.hh</code>, which you can add to your <code>third_party</code> folder.</p>"},{"location":"supported-compilers/","title":"Supported Compilers","text":"<p>We\u2019ve endeavored to use only standards-compliant C++14 in Au, with the goal of making it work with any compiler that fully supports the C++14 standard (or any newer one). Of course, there\u2019s no substitute for testing!  So we also include certain platform/compiler combinations in our automated test suites, which we run on every commit.</p> <p>Note</p> <p>We\u2019ll use \u201cconfiguration\u201d as a shorthand for \u201cplatform/compiler combination\u201d for the rest of this doc.</p> <p>Formally, we have three tiers of support.</p> <ol> <li>Full Support.  These configurations must be kept passing on every commit.</li> <li>Best Effort Support.  We measure whether these configurations are passing on every commit,    and strive to keep them passing.  However, if we cannot do so, we may let them break.</li> <li>Assumed Support.  These include all other C++14-compatible configurations which we do not    measure explicitly.</li> </ol> <p>Each tier has requirements that must be met for a configuration to be included in it. Any configuration that doesn\u2019t meet the bar for any higher tier is in the \u201cAssumed Support\u201d tier.</p>"},{"location":"supported-compilers/#status-changes","title":"Status changes","text":"<p>We expect most status changes will be user-led.  Users who want a higher tier of support for their preferred configuration are welcome to file an issue, especially if they can provide some guidance as to how we can help it meet the requirements for that tier (that is, how to set up suitable GitHub workflows or bazel toolchains for it).</p> <p>Some status changes may be out of our control.  For example, if GitHub actions drops support for Windows Server 2019, we won\u2019t be able to continue running GitHub workflows for MSVC x64 19.29.  If that happened, we would have to move that configuration to the \u201cAssumed Support\u201d tier.</p>"},{"location":"supported-compilers/#tiers-requirements-and-members","title":"Tiers: Requirements and members","text":"<p>Now we\u2019ll go into more detail about each tier.  We\u2019ll explain the requirements which a configuration must meet to join that tier, and we\u2019ll list the configurations that are currently included.</p>"},{"location":"supported-compilers/#full-support","title":"Full support","text":"<p>To add a configuration to the Full Support tier, we must be able to add a hermetic toolchain to our bazel workspace. The motivation for this requirement is that we want any developer to be able to check out the repository, and have a tight iteration cycle with full local reproducibility for any CI errors.</p> <p>Here are the configurations that have Full Support status.</p> Platform Compiler Status Ubuntu clang 11 Ubuntu clang 14 Ubuntu gcc 10"},{"location":"supported-compilers/#best-effort-support","title":"Best effort support","text":"<p>To add a configuration to the Best Effort tier, we must be able to set up an automated GitHub workflow job which runs tests on that configuration.  This means that any developer will be able to iterate on these configurations, although some may be forced to push commits remotely and trigger CI jobs to do so.</p> <p>Although we reserve the right to drop support for these configurations, we will strive to avoid doing so if at all possible.  We expect to be able to succeed and keep these passing in perpetuity. Even in the unlikely event that any of these configurations break, we\u2019ll continue to provide measurement badges, so that potential users with these configurations are forewarned.</p> <p>Here are the configurations that have Best Effort Support status.</p> Platform Compiler Status Windows Server 2019 MSVC 2019 x64 Windows Server 2022 MSVC 2022 x64"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This page is a guide to the most commonly encountered types of error, what they mean, and how to fix them.</p> <p>The intended use case is to help you interpret an actual error in your code, at the point where you encounter it.  To use this page, copy some relevant snippets from your compiler error, and then search the text of this page using your browser\u2019s Find function.</p> <p>Tip</p> <p>To improve your chances of finding what you\u2019re looking for, we include full compiler errors from both gcc and clang, inline with the text.  Naturally, this makes this page very long, so it\u2019s not meant to be read straight through.  Stick with your browser\u2019s Find function.</p> <p>Each section below lists one category of compiler error you might encounter when using the library. It explains what it means and how to solve it, and gives specific snippets of erroneous code, along with the compiler errors that each would yield.</p>"},{"location":"troubleshooting/#private-constructor","title":"Private constructor","text":"<p>Meaning:  This means you passed a raw numeric value to an interface that expected a Quantity. It\u2019s the \u201cclassic\u201d error the units library aims to prevent.</p> <p>Solution: Call the appropriate Quantity maker: instead of passing <code>x</code>, pass <code>meters(x)</code>, <code>(kilo(meters) / hour)(x)</code>, etc.</p> A note on quantity makers vs. constructors <p>Every other major units library lets you construct its Quantity types from raw numeric values; it just makes that constructor explicit.  Au goes further, and makes this constructor private. The reason is to preserve unit safety at all callsites.  We can\u2019t know whether you made an alias that doesn\u2019t name the unit.  For example, if you want everybody to measure lengths in <code>Meters</code> in your codebase, you might provide a common alias like this:</p> <pre><code>using Length = QuantityD&lt;Meters&gt;;\n</code></pre> <p>If you did, then end users could write the following:</p> <pre><code>constexpr Length MAX_LENGTH{5.5};  // Unsafe!  Units unclear.  :(\n</code></pre> <p>A core principle of the Au library is that the only way to enter or exit the library boundaries is to name the unit of measure, explicitly, at the callsite, like this:</p> <pre><code>constexpr Length MAX_LENGTH = meters(5.5);  // Usable!  Units unambiguous.  :)\n</code></pre> <p>This enables users who want to use this kind of \u201cdimension-named alias\u201d in their codebase to do so safely.</p> <p>Example</p> <p>Code</p> BrokenFixed <pre><code>void set_timeout(QuantityD&lt;Seconds&gt; dt);\n\n// A (BROKEN): passing raw number where duration expected.\nset_timeout(0.5);\n\n// B (BROKEN): calling Quantity constructor directly.\nconstexpr QuantityD&lt;Meters&gt; length{5.5};\n</code></pre> <pre><code>void set_timeout(QuantityD&lt;Seconds&gt; dt);\n\n// A (FIXED): name the unit.\nset_timeout(seconds(0.5));\n\n// B (FIXED): calling Quantity constructor directly.\nconstexpr QuantityD&lt;Meters&gt; length = meters(5.5);\n</code></pre> <p>Compiler error (clang 14) <pre><code>au/error_examples.cc:33:17: error: calling a private constructor of class 'au::Quantity&lt;au::Seconds, double&gt;'\n    set_timeout(0.5);\n                ^\nau/code/au/quantity.hh:400:15: note: declared private here\n    constexpr Quantity(Rep value) : value_{value} {}\n              ^\nau/error_examples.cc:36:33: error: calling a private constructor of class 'au::Quantity&lt;au::Meters, double&gt;'\n    constexpr QuantityD&lt;Meters&gt; length{5.5};\n                                ^\nau/code/au/quantity.hh:400:15: note: declared private here\n    constexpr Quantity(Rep value) : value_{value} {}\n              ^\n</code></pre></p> <p>Compiler error (clang 11) <pre><code>au/error_examples.cc:33:17: error: calling a private constructor of class 'au::Quantity&lt;au::Seconds, double&gt;'\n    set_timeout(0.5);\n                ^\nau/code/au/quantity.hh:400:15: note: declared private here\n    constexpr Quantity(Rep value) : value_{value} {}\n              ^\nau/error_examples.cc:36:33: error: calling a private constructor of class 'au::Quantity&lt;au::Meters, double&gt;'\n    constexpr QuantityD&lt;Meters&gt; length{5.5};\n                                ^\nau/code/au/quantity.hh:400:15: note: declared private here\n    constexpr Quantity(Rep value) : value_{value} {}\n              ^\n</code></pre></p> <p>Compiler error (gcc 10) <pre><code>au/error_examples.cc: In function 'void au::example_private_constructor()':\nau/error_examples.cc:33:20: error: 'constexpr au::Quantity&lt;UnitT, RepT&gt;::Quantity(au::Quantity&lt;UnitT, RepT&gt;::Rep) [with UnitT = au::Seconds; RepT = double; au::Quantity&lt;UnitT, RepT&gt;::Rep = double]' is private within this context\n   33 |     set_timeout(0.5);\n      |                    ^\nIn file included from au/code/au/prefix.hh:18,\n                 from au/code/au/chrono_interop.hh:20,\n                 from au/code/au/au.hh:17,\n                 from au/error_examples.cc:15:\nau/code/au/quantity.hh:400:15: note: declared private here\n  400 |     constexpr Quantity(Rep value) : value_{value} {}\n      |               ^~~~~~~~\nau/error_examples.cc:36:43: error: 'constexpr au::Quantity&lt;UnitT, RepT&gt;::Quantity(au::Quantity&lt;UnitT, RepT&gt;::Rep) [with UnitT = au::Meters; RepT = double; au::Quantity&lt;UnitT, RepT&gt;::Rep = double]' is private within this context\n   36 |     constexpr QuantityD&lt;Meters&gt; length{5.5};\n      |                                           ^\nIn file included from au/code/au/prefix.hh:18,\n                 from au/code/au/chrono_interop.hh:20,\n                 from au/code/au/au.hh:17,\n                 from au/error_examples.cc:15:\nau/code/au/quantity.hh:400:15: note: declared private here\n  400 |     constexpr Quantity(Rep value) : value_{value} {}\n      |               ^~~~~~~~\n</code></pre></p> <p>Compiler error (MSVC 2019 x64) <pre><code>error_examples.cc(32): error C2248: 'au::Quantity&lt;au::Seconds,double&gt;::Quantity': cannot access private member declared in class 'au::Quantity&lt;au::Seconds,double&gt;'\nD:\\a\\au\\au\\au.hh(3202): note: see declaration of 'au::Quantity&lt;au::Seconds,double&gt;::Quantity'\nD:\\a\\au\\au\\au.hh(3269): note: see declaration of 'au::Quantity&lt;au::Seconds,double&gt;'\nerror_examples.cc(35): error C2248: 'au::Quantity&lt;au::Meters,double&gt;::Quantity': cannot access private member declared in class 'au::Quantity&lt;au::Meters,double&gt;'\nD:\\a\\au\\au\\au.hh(3202): note: see declaration of 'au::Quantity&lt;au::Meters,double&gt;::Quantity'\nD:\\a\\au\\au\\au.hh(3269): note: see declaration of 'au::Quantity&lt;au::Meters,double&gt;'\n</code></pre></p> <p>Compiler error (MSVC 2022 x64) <pre><code>error_examples.cc(32): error C2248: 'au::Quantity&lt;au::Seconds,double&gt;::Quantity': cannot access private member declared in class 'au::Quantity&lt;au::Seconds,double&gt;'\nD:\\a\\au\\au\\au.hh(3202): note: see declaration of 'au::Quantity&lt;au::Seconds,double&gt;::Quantity'\nD:\\a\\au\\au\\au.hh(3269): note: see declaration of 'au::Quantity&lt;au::Seconds,double&gt;'\nerror_examples.cc(35): error C2248: 'au::Quantity&lt;au::Meters,double&gt;::Quantity': cannot access private member declared in class 'au::Quantity&lt;au::Meters,double&gt;'\nD:\\a\\au\\au\\au.hh(3202): note: see declaration of 'au::Quantity&lt;au::Meters,double&gt;::Quantity'\nD:\\a\\au\\au\\au.hh(3269): note: see declaration of 'au::Quantity&lt;au::Meters,double&gt;'\n</code></pre></p>"},{"location":"troubleshooting/#input-to-maker","title":"Input to Maker","text":"<p>Meaning:  This happens when you try to pass something to a \u201cmaker\u201d (quantity maker, or quantity point maker), but it\u2019s already a <code>Quantity</code> or <code>QuantityPoint</code>.</p> <p>Solution: Generally, this is pretty easy: just remove the redundant call.</p> <p>Example</p> <p>Code</p> BrokenFixed <pre><code>constexpr auto x = meters(1);\nconstexpr auto x_pt = meters_pt(1);\n\n// A (BROKEN): passing something that is already a quantity to a quantity maker.\nmeters(x);\n\n// B (BROKEN): same as above, but with quantity _points_.\nmeters_pt(x_pt);\n</code></pre> <pre><code>constexpr auto x = meters(1);\nconstexpr auto x_pt = meters_pt(1);\n\n// A (FIXED): just use the quantity directly.\nx;\n\n// B (FIXED): just use the quantity point directly.\nx_pt;\n</code></pre> <p>Compiler error (clang 14) <pre><code>au/code/au/quantity.hh:523:9: error: static_assert failed due to requirement 'is_not_already_a_quantity' \"Input to QuantityMaker is already a Quantity\"\n        static_assert(is_not_already_a_quantity, \"Input to QuantityMaker is already a Quantity\");\n        ^             ~~~~~~~~~~~~~~~~~~~~~~~~~\nau/error_examples.cc:47:11: note: in instantiation of function template specialization 'au::QuantityMaker&lt;au::Meters&gt;::operator()&lt;au::Meters, int&gt;' requested here\n    meters(x);\n          ^\nIn file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:20:\nIn file included from au/code/au/prefix.hh:19:\nau/code/au/quantity_point.hh:295:9: error: static_assert failed due to requirement 'is_not_already_a_quantity_point' \"Input to QuantityPointMaker is already a QuantityPoint\"\n        static_assert(is_not_already_a_quantity_point,\n        ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nau/error_examples.cc:50:14: note: in instantiation of function template specialization 'au::QuantityPointMaker&lt;au::Meters&gt;::operator()&lt;au::Meters, int&gt;' requested here\n    meters_pt(x_pt);\n             ^\nIn file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:20:\nIn file included from au/code/au/prefix.hh:18:\n</code></pre></p> <p>Compiler error (clang 11) <pre><code>au/code/au/quantity.hh:523:9: error: static_assert failed due to requirement 'is_not_already_a_quantity' \"Input to QuantityMaker is already a Quantity\"\n        static_assert(is_not_already_a_quantity, \"Input to QuantityMaker is already a Quantity\");\n        ^             ~~~~~~~~~~~~~~~~~~~~~~~~~\nau/error_examples.cc:47:11: note: in instantiation of function template specialization 'au::QuantityMaker&lt;au::Meters&gt;::operator()&lt;au::Meters, int&gt;' requested here\n    meters(x);\n          ^\nIn file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:20:\nIn file included from au/code/au/prefix.hh:19:\nau/code/au/quantity_point.hh:295:9: error: static_assert failed due to requirement 'is_not_already_a_quantity_point' \"Input to QuantityPointMaker is already a QuantityPoint\"\n        static_assert(is_not_already_a_quantity_point,\n        ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nau/error_examples.cc:50:14: note: in instantiation of function template specialization 'au::QuantityPointMaker&lt;au::Meters&gt;::operator()&lt;au::Meters, int&gt;' requested here\n    meters_pt(x_pt);\n             ^\nIn file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:20:\nIn file included from au/code/au/prefix.hh:18:\n</code></pre></p> <p>Compiler error (gcc 10) <pre><code>In file included from au/code/au/prefix.hh:18,\n                 from au/code/au/chrono_interop.hh:20,\n                 from au/code/au/au.hh:17,\n                 from au/error_examples.cc:15:\nau/code/au/quantity.hh: In instantiation of 'constexpr void au::QuantityMaker&lt;UnitT&gt;::operator()(au::Quantity&lt;OtherUnit, OtherRep&gt;) const [with U = au::Meters; R = int; UnitT = au::Meters]':\nau/error_examples.cc:47:13:   required from here\nau/code/au/quantity.hh:523:23: error: static assertion failed: Input to QuantityMaker is already a Quantity\n  523 |         static_assert(is_not_already_a_quantity, \"Input to QuantityMaker is already a Quantity\");\n      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from au/code/au/prefix.hh:19,\n                 from au/code/au/chrono_interop.hh:20,\n                 from au/code/au/au.hh:17,\n                 from au/error_examples.cc:15:\nau/code/au/quantity_point.hh: In instantiation of 'constexpr void au::QuantityPointMaker&lt;UnitT&gt;::operator()(au::QuantityPoint&lt;U, R&gt;) const [with U = au::Meters; R = int; Unit = au::Meters]':\nau/error_examples.cc:50:19:   required from here\nau/code/au/quantity_point.hh:295:23: error: static assertion failed: Input to QuantityPointMaker is already a QuantityPoint\n  295 |         static_assert(is_not_already_a_quantity_point,\n      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre></p> <p>Compiler error (MSVC 2019 x64) <pre><code>D:\\a\\au\\au\\au.hh(4391): error C2338: Input to QuantityMaker is already a Quantity\nerror_examples.cc(48): note: see reference to function template instantiation 'void au::QuantityMaker&lt;au::Meters&gt;::operator ()&lt;au::Meters,int&gt;(au::Quantity&lt;au::Meters,int&gt;) const' being compiled\nerror_examples.cc(48): note: see reference to function template instantiation 'void au::QuantityMaker&lt;au::Meters&gt;::operator ()&lt;au::Meters,int&gt;(au::Quantity&lt;au::Meters,int&gt;) const' being compiled\nD:\\a\\au\\au\\au.hh(5111): error C2338: Input to QuantityPointMaker is already a QuantityPoint\nerror_examples.cc(51): note: see reference to function template instantiation 'void au::QuantityPointMaker&lt;au::Meters&gt;::operator ()&lt;Unit,T&gt;(au::QuantityPoint&lt;Unit,T&gt;) const' being compiled\n        with\n        [\n            Unit=au::Meters,\n            T=int\n        ]\nerror_examples.cc(51): note: see reference to function template instantiation 'void au::QuantityPointMaker&lt;au::Meters&gt;::operator ()&lt;Unit,T&gt;(au::QuantityPoint&lt;Unit,T&gt;) const' being compiled\n        with\n        [\n            Unit=au::Meters,\n            T=int\n        ]\n</code></pre></p> <p>Compiler error (MSVC 2022 x64) <pre><code>D:\\a\\au\\au\\au.hh(4391): error C2338: static_assert failed: 'Input to QuantityMaker is already a Quantity'\nD:\\a\\au\\au\\au.hh(4391): note: the template instantiation context (the oldest one first) is\nerror_examples.cc(48): note: see reference to function template instantiation 'void au::QuantityMaker&lt;au::Meters&gt;::operator ()&lt;au::Meters,int&gt;(au::Quantity&lt;au::Meters,int&gt;) const' being compiled\nerror_examples.cc(48): note: see the first reference to 'au::QuantityMaker&lt;au::Meters&gt;::operator ()' in 'au::example_input_to_maker'\nD:\\a\\au\\au\\au.hh(5111): error C2338: static_assert failed: 'Input to QuantityPointMaker is already a QuantityPoint'\nD:\\a\\au\\au\\au.hh(5111): note: the template instantiation context (the oldest one first) is\nerror_examples.cc(51): note: see reference to function template instantiation 'void au::QuantityPointMaker&lt;au::Meters&gt;::operator ()&lt;Unit,T&gt;(au::QuantityPoint&lt;Unit,T&gt;) const' being compiled\n        with\n        [\n            Unit=au::Meters,\n            T=int\n        ]\nerror_examples.cc(51): note: see the first reference to 'au::QuantityPointMaker&lt;au::Meters&gt;::operator ()' in 'au::example_input_to_maker'\n</code></pre></p>"},{"location":"troubleshooting/#dangerous-conversion","title":"Dangerous conversion","text":"<p>Meaning:  This is a physically meaningful conversion, but we think the risk of a grossly incorrect answer is too high, so we forbid it.  There are two main sources for this risk, both having to do with integral storage types.</p> <ol> <li> <p>Inexact conversion.  Example: <code>inches(24).as(feet)</code>.</p> </li> <li> <p>Overflow.  Example: <code>giga(hertz)(1).as(hertz)</code>.</p> </li> </ol> <p>Both of these examples would in fact produce the correct answer with the specific values given (<code>24</code> and <code>1</code>).  However, many (most!) other values would not.  Thus, we disallow the entire conversion operation (at least in this format).</p> <p>Solution:  There are different strategies to solve this, depending on your use case.</p> <ol> <li> <p>Use floating point.  As mentioned above, these risks only apply to integer values.  If    floating point is what you want anyway, just use it.  <code>giga(hertz)(1.0).as(hertz)</code> produces    <code>hertz(1'000'000'000.0)</code>.</p> </li> <li> <p>Use the \u201ccoercing\u201d version.  <code>inches(24).coerce_as(feet)</code> produces <code>feet(2)</code>.</p> </li> </ol> <p>Warning</p> <p>Stop and think before using the coercing version.  If you\u2019re reviewing code that uses it, ask about it.  The library is trying to protect you from an error prone operation.  The mechanism exists because sometimes you can know that it\u2019s OK, but remember to stop and check first!</p> <p>Example</p> <p>Code</p> BrokenFixed (1. Floating Point)Fixed (2. Coercing version) <pre><code>// A (BROKEN): inexact conversion.\ninches(24).as(feet);\n\n// B (BROKEN): overflow risk.\ngiga(hertz)(1).as(hertz);\n</code></pre> <pre><code>// A (FIXED): 1. use floating point.\ninches(24.0).as(feet);\n\n// B (FIXED): 1. use floating point.\ngiga(hertz)(1.0).as(hertz);\n</code></pre> <pre><code>// A (FIXED): 2. use coercing version.\ninches(24).coerce_as(feet);\n\n// B (FIXED): 2. use coercing version.\ngiga(hertz)(1).coerce_as(hertz);\n</code></pre> <p>Compiler error (clang 14) <pre><code>au/code/au/quantity.hh:163:9: error: static_assert failed due to requirement 'IMPLICIT_OK' \"Dangerous conversion for integer Rep!  See: https://aurora-opensource.github.io/au/main/troubleshooting/#dangerous-conversion\"\n        static_assert(\n        ^\nau/error_examples.cc:58:16: note: in instantiation of function template specialization 'au::Quantity&lt;au::Inches, int&gt;::as&lt;au::QuantityMaker&lt;au::Feet&gt;, void&gt;' requested here\n    inches(24).as(feet);\n               ^\nIn file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:20:\nIn file included from au/code/au/prefix.hh:18:\nau/code/au/quantity.hh:163:9: error: static_assert failed due to requirement 'IMPLICIT_OK' \"Dangerous conversion for integer Rep!  See: https://aurora-opensource.github.io/au/main/troubleshooting/#dangerous-conversion\"\n        static_assert(\n        ^\nau/error_examples.cc:61:20: note: in instantiation of function template specialization 'au::Quantity&lt;au::Giga&lt;au::Hertz&gt;, int&gt;::as&lt;au::QuantityMaker&lt;au::Hertz&gt;, void&gt;' requested here\n    giga(hertz)(1).as(hertz);\n                   ^\n</code></pre></p> <p>Compiler error (clang 11) <pre><code>au/code/au/quantity.hh:163:9: error: static_assert failed due to requirement 'IMPLICIT_OK' \"Dangerous conversion for integer Rep!  See: https://aurora-opensource.github.io/au/main/troubleshooting/#dangerous-conversion\"\n        static_assert(\n        ^\nau/error_examples.cc:58:16: note: in instantiation of function template specialization 'au::Quantity&lt;au::Inches, int&gt;::as&lt;au::QuantityMaker&lt;au::Feet&gt;, void&gt;' requested here\n    inches(24).as(feet);\n               ^\nIn file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:20:\nIn file included from au/code/au/prefix.hh:18:\nau/code/au/quantity.hh:163:9: error: static_assert failed due to requirement 'IMPLICIT_OK' \"Dangerous conversion for integer Rep!  See: https://aurora-opensource.github.io/au/main/troubleshooting/#dangerous-conversion\"\n        static_assert(\n        ^\nau/error_examples.cc:61:20: note: in instantiation of function template specialization 'au::Quantity&lt;au::Giga&lt;au::Hertz&gt;, int&gt;::as&lt;au::QuantityMaker&lt;au::Hertz&gt;, void&gt;' requested here\n    giga(hertz)(1).as(hertz);\n                   ^\n</code></pre></p> <p>Compiler error (gcc 10) <pre><code>./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity&lt;UnitT, RepT&gt;::as(NewUnit) const [with NewUnit = au::Feet; &lt;template-parameter-2-2&gt; = void; UnitT = au::Inches; RepT = int]':\n./au/quantity.hh:206:18:   required from 'constexpr auto au::Quantity&lt;UnitT, RepT&gt;::as(au::QuantityMaker&lt;NewUnit&gt;) const [with NewUnit = au::Feet; UnitT = au::Inches; RepT = int]'\nau/error_examples.cc:44:23:   required from here\n./au/quantity.hh:169:13: error: static assertion failed: Dangerous conversion for integer Rep!  See: https://aurora-opensource.github.io/au/main/troubleshooting/#dangerous-conversion\n  169 |             IMPLICIT_OK,\n      |             ^~~~~~~~~~~\n./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity&lt;UnitT, RepT&gt;::as(NewUnit) const [with NewUnit = au::Hertz; &lt;template-parameter-2-2&gt; = void; UnitT = au::Giga&lt;au::Hertz&gt;; RepT = int]':\n./au/quantity.hh:206:18:   required from 'constexpr auto au::Quantity&lt;UnitT, RepT&gt;::as(au::QuantityMaker&lt;NewUnit&gt;) const [with NewUnit = au::Hertz; UnitT = au::Giga&lt;au::Hertz&gt;; RepT = int]'\nau/error_examples.cc:47:28:   required from here\n./au/quantity.hh:169:13: error: static assertion failed: Dangerous conversion for integer Rep!  See: https://aurora-opensource.github.io/au/main/troubleshooting/#dangerous-conversion\n</code></pre></p> <p>Compiler error (MSVC 2019 x64) <pre><code>D:\\a\\au\\au\\au.hh(2952): error C2338: Dangerous conversion for integer Rep!  See: https://aurora-opensource.github.io/au/main/troubleshooting/#dangerous-conversion\nD:\\a\\au\\au\\au.hh(2989): note: see reference to function template instantiation 'auto au::Quantity&lt;au::Inches,int&gt;::as&lt;NewUnit,void&gt;(NewUnit) const' being compiled\n        with\n        [\n            NewUnit=au::Feet\n        ]\nerror_examples.cc(45): note: see reference to function template instantiation 'auto au::Quantity&lt;au::Inches,int&gt;::as&lt;au::Feet&gt;(au::QuantityMaker&lt;au::Feet&gt;) const' being compiled\n</code></pre></p> <p>Compiler error (MSVC 2022 x64) <pre><code>D:\\a\\au\\au\\au.hh(2952): error C2338: static_assert failed: 'Dangerous conversion for integer Rep!  See: https://aurora-opensource.github.io/au/main/troubleshooting/#dangerous-conversion'\nD:\\a\\au\\au\\au.hh(2989): note: see reference to function template instantiation 'auto au::Quantity&lt;au::Inches,int&gt;::as&lt;NewUnit,void&gt;(NewUnit) const' being compiled\n        with\n        [\n            NewUnit=au::Feet\n        ]\nerror_examples.cc(45): note: see reference to function template instantiation 'auto au::Quantity&lt;au::Inches,int&gt;::as&lt;au::Feet&gt;(au::QuantityMaker&lt;au::Feet&gt;) const' being compiled\n</code></pre></p>"},{"location":"troubleshooting/#no-type-named-type-in-stdcommon_type","title":"No type named \u2018type\u2019 in \u2018std::common_type\u2019","text":"<p>Meaning:  You probably tried to perform a \u201ccommon-unit operation\u201d (addition, subtraction, comparison) with two incompatible Quantities.  Typically, this means they have different dimensions, which makes this an intrinsically meaningless operation.</p> <p>Solution:  Figure out what dimension you expected them to have, and which value had the wrong dimension.  Then, figure out how to fix your expression so it has the right dimension.</p> <p>Example</p> <p>Code</p> BrokenFixed <pre><code>// (BROKEN): different dimensions.\nmeters(1) + seconds(1);\n</code></pre> <pre><code>// (FIXED): fix coding mistake.\nmeters(1) + seconds(1) * (meters / second)(10);\n</code></pre> <p>Compiler error (clang 14) <pre><code>In file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:17:\nIn file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/chrono:697:\nIn file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/__chrono/calendar.h:13:\nIn file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/__chrono/duration.h:14:\nIn file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/limits:105:\nexternal/llvm_14_toolchain_llvm/bin/../include/c++/v1/type_traits:2388:25: error: no type named 'type' in 'std::common_type&lt;au::Quantity&lt;au::Meters, int&gt;, au::Quantity&lt;au::Seconds, int&gt;&gt;'\ntemplate &lt;class ..._Tp&gt; using common_type_t = typename common_type&lt;_Tp...&gt;::type;\n                        ^~~~~\nau/code/au/quantity.hh:625:20: note: in instantiation of template type alias 'common_type_t' requested here\n    using C = std::common_type_t&lt;T, U&gt;;\n                   ^\nau/code/au/quantity.hh:663:20: note: in instantiation of function template specialization 'au::detail::using_common_type&lt;au::Quantity&lt;au::Meters, int&gt;, au::Quantity&lt;au::Seconds, int&gt;, au::detail::Plus&gt;' requested here\n    return detail::using_common_type(q1, q2, detail::plus);\n                   ^\nau/error_examples.cc:69:15: note: in instantiation of function template specialization 'au::operator+&lt;au::Meters, au::Seconds, int, int&gt;' requested here\n    meters(1) + seconds(1);\n              ^\n</code></pre></p> <p>Compiler error (clang 11) <pre><code>In file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:17:\nIn file included from external/llvm_11_toolchain_llvm/bin/../include/c++/v1/chrono:828:\nexternal/llvm_11_toolchain_llvm/bin/../include/c++/v1/type_traits:2462:25: error: no type named 'type' in 'std::__1::common_type&lt;au::Quantity&lt;au::Meters, int&gt;, au::Quantity&lt;au::Seconds, int&gt;&gt;'\ntemplate &lt;class ..._Tp&gt; using common_type_t = typename common_type&lt;_Tp...&gt;::type;\n                        ^~~~~\nau/code/au/quantity.hh:625:20: note: in instantiation of template type alias 'common_type_t' requested here\n    using C = std::common_type_t&lt;T, U&gt;;\n                   ^\nau/code/au/quantity.hh:663:20: note: in instantiation of function template specialization 'au::detail::using_common_type&lt;au::Quantity&lt;au::Meters, int&gt;, au::Quantity&lt;au::Seconds, int&gt;, au::detail::Plus&gt;' requested here\n    return detail::using_common_type(q1, q2, detail::plus);\n                   ^\nau/error_examples.cc:69:15: note: in instantiation of function template specialization 'au::operator+&lt;au::Meters, au::Seconds, int, int&gt;' requested here\n    meters(1) + seconds(1);\n              ^\n</code></pre></p> <p>Compiler error (gcc 10) <pre><code>In file included from external/sysroot_x86_64//include/c++/10.3.0/ratio:39,\n                 from external/sysroot_x86_64//include/c++/10.3.0/chrono:39,\n                 from au/code/au/chrono_interop.hh:17,\n                 from au/code/au/au.hh:17,\n                 from au/error_examples.cc:15:\nexternal/sysroot_x86_64//include/c++/10.3.0/type_traits: In substitution of 'template&lt;class ... _Tp&gt; using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity&lt;au::Meters, int&gt;, au::Quantity&lt;au::Seconds, int&gt;}]':\nau/code/au/quantity.hh:625:11:   required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity&lt;au::Meters, int&gt;; U = au::Quantity&lt;au::Seconds, int&gt;; Func = au::detail::Plus]'\nau/code/au/quantity.hh:663:37:   required from 'constexpr auto au::operator+(au::Quantity&lt;U1, R1&gt;, au::Quantity&lt;U2, R2&gt;) [with U1 = au::Meters; U2 = au::Seconds; R1 = int; R2 = int]'\nau/error_examples.cc:69:26:   required from here\nexternal/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: error: no type named 'type' in 'struct std::common_type&lt;au::Quantity&lt;au::Meters, int&gt;, au::Quantity&lt;au::Seconds, int&gt; &gt;'\n 2562 |     using common_type_t = typename common_type&lt;_Tp...&gt;::type;\n      |           ^~~~~~~~~~~~~\nIn file included from au/code/au/prefix.hh:18,\n                 from au/code/au/chrono_interop.hh:20,\n                 from au/code/au/au.hh:17,\n                 from au/error_examples.cc:15:\nau/code/au/quantity.hh: In instantiation of 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity&lt;au::Meters, int&gt;; U = au::Quantity&lt;au::Seconds, int&gt;; Func = au::detail::Plus]':\nau/code/au/quantity.hh:663:37:   required from 'constexpr auto au::operator+(au::Quantity&lt;U1, R1&gt;, au::Quantity&lt;U2, R2&gt;) [with U1 = au::Meters; U2 = au::Seconds; R1 = int; R2 = int]'\nau/error_examples.cc:69:26:   required from here\nau/code/au/quantity.hh:627:94: error: no type named 'type' in 'struct std::common_type&lt;au::Quantity&lt;au::Meters, int&gt;, au::Quantity&lt;au::Seconds, int&gt; &gt;'\n  627 |         std::is_same&lt;typename C::Rep, std::common_type_t&lt;typename T::Rep, typename U::Rep&gt;&gt;::value,\n      |                                                                                              ^~~~~\n</code></pre></p> <p>Compiler error (MSVC 2019 x64) <pre><code>C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits(1164): error C2794: 'type': is not a member of any direct or indirect base class of 'std::common_type&lt;T,U&gt;'\n        with\n        [\n            T=au::Quantity&lt;au::Meters,int&gt;,\n            U=au::Quantity&lt;au::Seconds,int&gt;\n        ]\nD:\\a\\au\\au\\au.hh(4493): note: see reference to alias template instantiation 'std::common_type_t&lt;au::Quantity&lt;au::Meters,int&gt;,U&gt;' being compiled\n        with\n        [\n            U=au::Quantity&lt;au::Seconds,int&gt;\n        ]\nD:\\a\\au\\au\\au.hh(4531): note: see reference to function template instantiation 'auto au::detail::using_common_type&lt;au::Quantity&lt;au::Meters,int&gt;,au::Quantity&lt;au::Seconds,int&gt;,au::detail::Plus&gt;(T,U,Func)' being compiled\n        with\n        [\n            T=au::Quantity&lt;au::Meters,int&gt;,\n            U=au::Quantity&lt;au::Seconds,int&gt;,\n            Func=au::detail::Plus\n        ]\nerror_examples.cc(70): note: see reference to function template instantiation 'auto au::operator +&lt;au::Meters,au::Seconds,int,int&gt;(au::Quantity&lt;au::Meters,int&gt;,au::Quantity&lt;au::Seconds,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4493): error C2938: 'std::common_type_t' : Failed to specialize alias template\nD:\\a\\au\\au\\au.hh(4495): error C2057: expected constant expression\nD:\\a\\au\\au\\au.hh(4367): error C2668: 'au::Quantity&lt;au::Meters,int&gt;::as': ambiguous call to overloaded function\nD:\\a\\au\\au\\au.hh(4023): note: could be 'auto au::Quantity&lt;au::Meters,int&gt;::as&lt;NewRep,enable_if&lt;au::IsUnit&lt;AssociatedUnit&lt;NewUnit&gt;::type&gt;::value,void&gt;::type&gt;(NewUnit) const'\n        with\n        [\n            NewRep=TargetUnit::Rep,\n            NewUnit=TargetUnit::Rep\n        ]\nD:\\a\\au\\au\\au.hh(4013): note: or       'auto au::Quantity&lt;au::Meters,int&gt;::as&lt;NewRep,Unit,void&gt;(NewUnit) const'\n        with\n        [\n            NewRep=TargetUnit::Rep,\n            Unit=au::Meters,\n            NewUnit=au::Meters\n        ]\nD:\\a\\au\\au\\au.hh(4367): note: while trying to match the argument list '(Unit)'\n        with\n        [\n            Unit=au::Meters\n        ]\nD:\\a\\au\\au\\au.hh(4488): note: see reference to function template instantiation 'auto au::rep_cast&lt;TargetUnit::Rep,au::Meters,int&gt;(au::Quantity&lt;au::Meters,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4498): note: see reference to function template instantiation 'auto au::detail::cast_to_common_type&lt;C,au::Meters,int&gt;(au::Quantity&lt;au::Meters,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4367): error C2668: 'au::Quantity&lt;au::Seconds,int&gt;::as': ambiguous call to overloaded function\nD:\\a\\au\\au\\au.hh(4023): note: could be 'auto au::Quantity&lt;au::Seconds,int&gt;::as&lt;NewRep,enable_if&lt;au::IsUnit&lt;AssociatedUnit&lt;NewUnit&gt;::type&gt;::value,void&gt;::type&gt;(NewUnit) const'\n        with\n        [\n            NewRep=TargetUnit::Rep,\n            NewUnit=TargetUnit::Rep\n        ]\nD:\\a\\au\\au\\au.hh(4013): note: or       'auto au::Quantity&lt;au::Seconds,int&gt;::as&lt;NewRep,Unit,void&gt;(NewUnit) const'\n        with\n        [\n            NewRep=TargetUnit::Rep,\n            Unit=au::Seconds,\n            NewUnit=au::Seconds\n        ]\nD:\\a\\au\\au\\au.hh(4367): note: while trying to match the argument list '(Unit)'\n        with\n        [\n            Unit=au::Seconds\n        ]\nD:\\a\\au\\au\\au.hh(4488): note: see reference to function template instantiation 'auto au::rep_cast&lt;TargetUnit::Rep,au::Seconds,int&gt;(au::Quantity&lt;au::Seconds,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4498): note: see reference to function template instantiation 'auto au::detail::cast_to_common_type&lt;C,au::Seconds,int&gt;(au::Quantity&lt;au::Seconds,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4498): error C2672: 'operator __surrogate_func': no matching overloaded function found\nD:\\a\\au\\au\\au.hh(4498): error C2893: Failed to specialize function template 'auto au::detail::Plus::operator ()(const T &amp;,const U &amp;) const'\nD:\\a\\au\\au\\au.hh(954): note: see declaration of 'au::detail::Plus::operator ()'\nD:\\a\\au\\au\\au.hh(4498): note: With the following template arguments:\nD:\\a\\au\\au\\au.hh(4498): note: 'T=void'\nD:\\a\\au\\au\\au.hh(4498): note: 'U=void'\n</code></pre></p> <p>Compiler error (MSVC 2022 x64) <pre><code>C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\VC\\Tools\\MSVC\\14.41.34120\\include\\type_traits(1334): error C2794: 'type': is not a member of any direct or indirect base class of 'std::common_type&lt;T,U&gt;'\n        with\n        [\n            T=au::Quantity&lt;au::Meters,int&gt;,\n            U=au::Quantity&lt;au::Seconds,int&gt;\n        ]\nC:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\VC\\Tools\\MSVC\\14.41.34120\\include\\type_traits(1334): note: the template instantiation context (the oldest one first) is\nerror_examples.cc(70): note: see reference to function template instantiation 'auto au::operator +&lt;au::Meters,au::Seconds,int,int&gt;(au::Quantity&lt;au::Meters,int&gt;,au::Quantity&lt;au::Seconds,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4531): note: see reference to function template instantiation 'auto au::detail::using_common_type&lt;au::Quantity&lt;au::Meters,int&gt;,au::Quantity&lt;au::Seconds,int&gt;,au::detail::Plus&gt;(T,U,Func)' being compiled\n        with\n        [\n            T=au::Quantity&lt;au::Meters,int&gt;,\n            U=au::Quantity&lt;au::Seconds,int&gt;,\n            Func=au::detail::Plus\n        ]\nD:\\a\\au\\au\\au.hh(4493): note: see reference to alias template instantiation 'std::common_type_t&lt;T,U&gt;' being compiled\n        with\n        [\n            T=au::Quantity&lt;au::Meters,int&gt;,\n            U=au::Quantity&lt;au::Seconds,int&gt;\n        ]\nD:\\a\\au\\au\\au.hh(4493): error C2938: 'std::common_type_t' : Failed to specialize alias template\nD:\\a\\au\\au\\au.hh(4495): error C2057: expected constant expression\nD:\\a\\au\\au\\au.hh(4367): error C2668: 'au::Quantity&lt;au::Meters,int&gt;::as': ambiguous call to overloaded function\nD:\\a\\au\\au\\au.hh(4023): note: could be 'auto au::Quantity&lt;au::Meters,int&gt;::as&lt;NewRep,enable_if&lt;au::IsUnit&lt;AssociatedUnit&lt;NewUnit&gt;::type&gt;::value,void&gt;::type&gt;(NewUnit) const'\n        with\n        [\n            NewRep=TargetUnit::Rep,\n            NewUnit=TargetUnit::Rep\n        ]\nD:\\a\\au\\au\\au.hh(4013): note: or       'auto au::Quantity&lt;au::Meters,int&gt;::as&lt;NewRep,Unit,void&gt;(NewUnit) const'\n        with\n        [\n            NewRep=TargetUnit::Rep,\n            Unit=au::Meters,\n            NewUnit=au::Meters\n        ]\nD:\\a\\au\\au\\au.hh(4367): note: while trying to match the argument list '(Unit)'\n        with\n        [\n            Unit=au::Meters\n        ]\nD:\\a\\au\\au\\au.hh(4367): note: the template instantiation context (the oldest one first) is\nD:\\a\\au\\au\\au.hh(4498): note: see reference to function template instantiation 'auto au::detail::cast_to_common_type&lt;au::detail::using_common_type::C,au::Meters,int&gt;(au::Quantity&lt;au::Meters,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4488): note: see reference to function template instantiation 'auto au::rep_cast&lt;TargetUnit::Rep,au::Meters,int&gt;(au::Quantity&lt;au::Meters,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4367): error C2668: 'au::Quantity&lt;au::Seconds,int&gt;::as': ambiguous call to overloaded function\nD:\\a\\au\\au\\au.hh(4023): note: could be 'auto au::Quantity&lt;au::Seconds,int&gt;::as&lt;NewRep,enable_if&lt;au::IsUnit&lt;AssociatedUnit&lt;NewUnit&gt;::type&gt;::value,void&gt;::type&gt;(NewUnit) const'\n        with\n        [\n            NewRep=TargetUnit::Rep,\n            NewUnit=TargetUnit::Rep\n        ]\nD:\\a\\au\\au\\au.hh(4013): note: or       'auto au::Quantity&lt;au::Seconds,int&gt;::as&lt;NewRep,Unit,void&gt;(NewUnit) const'\n        with\n        [\n            NewRep=TargetUnit::Rep,\n            Unit=au::Seconds,\n            NewUnit=au::Seconds\n        ]\nD:\\a\\au\\au\\au.hh(4367): note: while trying to match the argument list '(Unit)'\n        with\n        [\n            Unit=au::Seconds\n        ]\nD:\\a\\au\\au\\au.hh(4367): note: the template instantiation context (the oldest one first) is\nD:\\a\\au\\au\\au.hh(4498): note: see reference to function template instantiation 'auto au::detail::cast_to_common_type&lt;au::detail::using_common_type::C,au::Seconds,int&gt;(au::Quantity&lt;au::Seconds,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4488): note: see reference to function template instantiation 'auto au::rep_cast&lt;TargetUnit::Rep,au::Seconds,int&gt;(au::Quantity&lt;au::Seconds,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4498): error C3889: call to object of class type 'au::detail::Plus': no matching call operator found\nD:\\a\\au\\au\\au.hh(954): note: could be 'auto au::detail::Plus::operator ()(const T &amp;,const U &amp;) const'\nD:\\a\\au\\au\\au.hh(4498): note: Failed to specialize function template 'auto au::detail::Plus::operator ()(const T &amp;,const U &amp;) const'\nD:\\a\\au\\au\\au.hh(4498): note: With the following template arguments:\nD:\\a\\au\\au\\au.hh(4498): note: 'T=void'\nD:\\a\\au\\au\\au.hh(4498): note: 'U=void'\nD:\\a\\au\\au\\au.hh(4498): note: you cannot create a reference to 'void'\n</code></pre></p>"},{"location":"troubleshooting/#integer-division-forbidden","title":"Integer division forbidden","text":"<p>Meaning:  Although Au generally tries to act just like the underlying raw numeric types, we also try to prevent wrong code that looks correct from compiling.  It turns out to be just too easy to use integral Reps without noticing, and thus to get integer division without noticing.  This can lead to very large errors.</p> <p>Solution:  If you really wanted integer division, wrap the denominator in <code>unblock_int_div()</code>. Otherwise, use floating point types.</p> <p>Example</p> <p>Code</p> <p>How long does it take to travel 60 m at a speed of 65 MPH?</p> BrokenFixed (1. Floating point)Fixed (2. <code>unblock_int_div()</code>) <pre><code>// (BROKEN): gives (60 / 65) == 0 before conversion!\nQuantityD&lt;Seconds&gt; t = meters(60) / (miles / hour)(65);\n</code></pre> <pre><code>// (FIXED): 1. Using floating point, we get ~= seconds(2.06486)\nQuantityD&lt;Seconds&gt; t = meters(60.0) / (miles / hour)(65.0);\n</code></pre> <pre><code>// (FIXED): 2. Integer result == (meter * hours / mile)(0)\nauto t = meters(60) / unblock_int_div((miles / hour)(65));\n</code></pre> <p>Compiler error (clang 14) <pre><code>In file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:20:\nIn file included from au/code/au/prefix.hh:18:\nau/code/au/quantity.hh:395:9: error: static_assert failed due to requirement 'are_units_quantity_equivalent || !uses_integer_division' \"Integer division forbidden: wrap denominator in `unblock_int_div()` if you really want it\"\n        static_assert(are_units_quantity_equivalent || !uses_integer_division,\n        ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nau/code/au/quantity.hh:325:9: note: in instantiation of function template specialization 'au::Quantity&lt;au::Meters, int&gt;::warn_if_integer_division&lt;au::UnitProduct&lt;au::Miles, au::Pow&lt;au::Hours, -1&gt;&gt;, int&gt;' requested here\n        warn_if_integer_division&lt;OtherUnit, OtherRep&gt;();\n        ^\nau/error_examples.cc:77:39: note: in instantiation of function template specialization 'au::Quantity&lt;au::Meters, int&gt;::operator/&lt;au::UnitProduct&lt;au::Miles, au::Pow&lt;au::Hours, -1&gt;&gt;, int&gt;' requested here\n    QuantityD&lt;Seconds&gt; t = meters(60) / (miles / hour)(65);\n                                      ^\n</code></pre></p> <p>Compiler error (clang 11) <pre><code>In file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:20:\nIn file included from au/code/au/prefix.hh:18:\nau/code/au/quantity.hh:395:9: error: static_assert failed due to requirement 'are_units_quantity_equivalent || !uses_integer_division' \"Integer division forbidden: wrap denominator in `unblock_int_div()` if you really want it\"\n        static_assert(are_units_quantity_equivalent || !uses_integer_division,\n        ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nau/code/au/quantity.hh:325:9: note: in instantiation of function template specialization 'au::Quantity&lt;au::Meters, int&gt;::warn_if_integer_division&lt;au::UnitProduct&lt;au::Miles, au::Pow&lt;au::Hours, -1&gt;&gt;, int&gt;' requested here\n        warn_if_integer_division&lt;OtherUnit, OtherRep&gt;();\n        ^\nau/error_examples.cc:77:39: note: in instantiation of function template specialization 'au::Quantity&lt;au::Meters, int&gt;::operator/&lt;au::UnitProduct&lt;au::Miles, au::Pow&lt;au::Hours, -1&gt;&gt;, int&gt;' requested here\n    QuantityD&lt;Seconds&gt; t = meters(60) / (miles / hour)(65);\n                                      ^\n</code></pre></p> <p>Compiler error (gcc 10) <pre><code>au/code/au/quantity.hh: In instantiation of 'static constexpr void au::Quantity&lt;UnitT, RepT&gt;::warn_if_integer_division() [with OtherUnit = au::UnitProduct&lt;au::Miles, au::Pow&lt;au::Hours, -1&gt; &gt;; OtherRep = int; UnitT = au::Meters; RepT = int]':\nau/code/au/quantity.hh:325:54:   required from here\nau/error_examples.cc:77:58:   in 'constexpr' expansion of 'au::meters.au::QuantityMaker&lt;au::Meters&gt;::operator()&lt;int&gt;(60).au::Quantity&lt;au::Meters, int&gt;::operator/&lt;au::UnitProduct&lt;au::Miles, au::Pow&lt;au::Hours, -1&gt; &gt;, int&gt;(au::miles.au::QuantityMaker&lt;au::Miles&gt;::operator/&lt;au::Hours&gt;((au::hour, const au::SingularNameFor&lt;au::Hours&gt;())).au::QuantityMaker&lt;au::UnitProduct&lt;au::Miles, au::Pow&lt;au::Hours, -1&gt; &gt; &gt;::operator()&lt;int&gt;(65))'\nau/code/au/quantity.hh:395:53: error: static assertion failed: Integer division forbidden: wrap denominator in `unblock_int_div()` if you really want it\n  395 |         static_assert(are_units_quantity_equivalent || !uses_integer_division,\n      |                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre></p> <p>Compiler error (MSVC 2019 x64) <pre><code>D:\\a\\au\\au\\au.hh(4263): error C2338: Integer division forbidden: wrap denominator in `unblock_int_div()` if you really want it\nD:\\a\\au\\au\\au.hh(4193): note: see reference to function template instantiation 'void au::Quantity&lt;au::Meters,int&gt;::warn_if_integer_division&lt;OtherUnit,OtherRep&gt;(void)' being compiled\n        with\n        [\n            OtherUnit=au::UnitProduct&lt;au::Miles,au::Pow&lt;au::Hours,-1&gt;&gt;,\n            OtherRep=int\n        ]\nD:\\a\\au\\au\\au.hh(4193): note: see reference to function template instantiation 'void au::Quantity&lt;au::Meters,int&gt;::warn_if_integer_division&lt;OtherUnit,OtherRep&gt;(void)' being compiled\n        with\n        [\n            OtherUnit=au::UnitProduct&lt;au::Miles,au::Pow&lt;au::Hours,-1&gt;&gt;,\n            OtherRep=int\n        ]\nerror_examples.cc(78): note: see reference to function template instantiation 'au::Quantity&lt;au::UnitProduct&lt;T,au::Pow&lt;B,-1&gt;,au::Hours&gt;,int&gt; au::Quantity&lt;au::Meters,int&gt;::operator /&lt;au::UnitProduct&lt;au::Miles,au::Pow&lt;au::Hours,-1&gt;&gt;,int&gt;(au::Quantity&lt;au::UnitProduct&lt;au::Miles,au::Pow&lt;au::Hours,-1&gt;&gt;,int&gt;) const' being compiled\n        with\n        [\n            T=au::Meters,\n            B=au::Miles\n        ]\n</code></pre></p> <p>Compiler error (MSVC 2022 x64) <pre><code>D:\\a\\au\\au\\au.hh(4263): error C2338: static_assert failed: 'Integer division forbidden: wrap denominator in `unblock_int_div()` if you really want it'\nD:\\a\\au\\au\\au.hh(4263): note: the template instantiation context (the oldest one first) is\nerror_examples.cc(78): note: see reference to function template instantiation 'au::Quantity&lt;au::UnitProduct&lt;T,au::Pow&lt;B,-1&gt;,au::Hours&gt;,int&gt; au::Quantity&lt;au::Meters,int&gt;::operator /&lt;au::UnitProduct&lt;au::Miles,au::Pow&lt;au::Hours,-1&gt;&gt;,int&gt;(au::Quantity&lt;au::UnitProduct&lt;au::Miles,au::Pow&lt;au::Hours,-1&gt;&gt;,int&gt;) const' being compiled\n        with\n        [\n            T=au::Meters,\n            B=au::Miles\n        ]\nD:\\a\\au\\au\\au.hh(4193): note: see reference to function template instantiation 'void au::Quantity&lt;au::Meters,int&gt;::warn_if_integer_division&lt;OtherUnit,OtherRep&gt;(void)' being compiled\n        with\n        [\n            OtherUnit=au::UnitProduct&lt;au::Miles,au::Pow&lt;au::Hours,-1&gt;&gt;,\n            OtherRep=int\n        ]\n</code></pre></p>"},{"location":"troubleshooting/#dangerous-inversion","title":"Dangerous inversion","text":"<p>Meaning:  This is analogous to our overflow safety surface.  When computing the inverse of an integral quantity in a given target unit, there is some smallest value that will get truncated down to zero (a tremendous error!).  If that value is \u201csmall enough to be scary\u201d (currently 1,000), we forbid the conversion.</p> <p>Solution:  Consider using floating point; you\u2019ll always get a precise answer.  Alternatively, use a smaller target unit.</p> <p>Example</p> <p>Code</p> BrokenFixed (1. Floating point)Fixed (2. Smaller target unit) <pre><code>// (BROKEN): excessive truncation risk.\ninverse_as(seconds, hertz(5));\n</code></pre> <pre><code>// (FIXED): 1. Floating point result ~= seconds(0.2)\ninverse_as(seconds, hertz(5.0));\n</code></pre> <pre><code>// (FIXED): 2. Integer result == milli(seconds)(200)\ninverse_as(milli(seconds), hertz(5));\n</code></pre> <p>Note</p> <p>If you\u2019re really sure it\u2019s OK, you can use the explicit-Rep version of <code>inverse_as</code>, which is forcing like a <code>static_cast</code>.  This is rarely the right choice, though.  Consider:</p> <pre><code>inverse_as&lt;int&gt;(seconds, hertz(5));\n</code></pre> <p>This yields <code>seconds(0)</code>, due to the gross truncation error which the check was designed to prevent in the first place.</p> <p>Compiler error (clang 14) <pre><code>In file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:19:\nau/code/au/math.hh:278:5: error: static_assert failed due to requirement 'UNITY.in&lt;int&gt;(associated_unit(target_units) * au::Hertz{}) &gt;= threshold || std::is_floating_point&lt;int&gt;::value' \"Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\"\n    static_assert(\n    ^\nau/code/au/math.hh:294:56: note: in instantiation of function template specialization 'au::inverse_in&lt;au::QuantityMaker&lt;au::Seconds&gt;, au::Hertz, int&gt;' requested here\n    return make_quantity&lt;AssociatedUnitT&lt;TargetUnits&gt;&gt;(inverse_in(target_units, q));\n                                                       ^\nau/error_examples.cc:85:5: note: in instantiation of function template specialization 'au::inverse_as&lt;au::QuantityMaker&lt;au::Seconds&gt;, au::Hertz, int&gt;' requested here\n    inverse_as(seconds, hertz(5));\n    ^\n</code></pre></p> <p>Compiler error (clang 11) <pre><code>In file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:19:\nau/code/au/math.hh:278:5: error: static_assert failed due to requirement 'UNITY.in&lt;int&gt;(associated_unit(target_units) * au::Hertz{}) &gt;= threshold || std::is_floating_point&lt;int&gt;::value' \"Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\"\n    static_assert(\n    ^\nau/code/au/math.hh:294:56: note: in instantiation of function template specialization 'au::inverse_in&lt;au::QuantityMaker&lt;au::Seconds&gt;, au::Hertz, int&gt;' requested here\n    return make_quantity&lt;AssociatedUnitT&lt;TargetUnits&gt;&gt;(inverse_in(target_units, q));\n                                                       ^\nau/error_examples.cc:85:5: note: in instantiation of function template specialization 'au::inverse_as&lt;au::QuantityMaker&lt;au::Seconds&gt;, au::Hertz, int&gt;' requested here\n    inverse_as(seconds, hertz(5));\n    ^\n</code></pre></p> <p>Compiler error (gcc 10) <pre><code>In file included from au/code/au/au.hh:19,\n                 from au/error_examples.cc:15:\nau/code/au/math.hh: In instantiation of 'constexpr auto au::inverse_in(TargetUnits, au::Quantity&lt;U, R&gt;) [with TargetUnits = au::QuantityMaker&lt;au::Seconds&gt;; U = au::Hertz; R = int]':\nau/code/au/math.hh:294:66:   required from 'constexpr auto au::inverse_as(TargetUnits, au::Quantity&lt;U, R&gt;) [with TargetUnits = au::QuantityMaker&lt;au::Seconds&gt;; U = au::Hertz; R = int]'\nau/error_examples.cc:85:33:   required from here\nau/code/au/math.hh:279:71: error: static assertion failed: Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\n  279 |         UNITY.in&lt;R&gt;(associated_unit(target_units) * U{}) &gt;= threshold ||\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n  280 |             std::is_floating_point&lt;R&gt;::value,\n      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           \n</code></pre></p> <p>Compiler error (MSVC 2019 x64) <pre><code>D:\\a\\au\\au\\au.hh(6120): error C2338: Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\nD:\\a\\au\\au\\au.hh(6135): note: see reference to function template instantiation 'auto au::inverse_in&lt;TargetUnits,au::Hertz,int&gt;(TargetUnits,au::Quantity&lt;au::Hertz,int&gt;)' being compiled\n        with\n        [\n            TargetUnits=au::QuantityMaker&lt;au::Seconds&gt;\n        ]\nerror_examples.cc(86): note: see reference to function template instantiation 'auto au::inverse_as&lt;au::QuantityMaker&lt;au::Seconds&gt;,au::Hertz,int&gt;(TargetUnits,au::Quantity&lt;au::Hertz,int&gt;)' being compiled\n        with\n        [\n            TargetUnits=au::QuantityMaker&lt;au::Seconds&gt;\n        ]\n</code></pre></p> <p>Compiler error (MSVC 2022 x64) <pre><code>D:\\a\\au\\au\\au.hh(6120): error C2338: static_assert failed: 'Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired'\nD:\\a\\au\\au\\au.hh(6120): note: the template instantiation context (the oldest one first) is\nerror_examples.cc(86): note: see reference to function template instantiation 'auto au::inverse_as&lt;au::QuantityMaker&lt;au::Seconds&gt;,au::Hertz,int&gt;(TargetUnits,au::Quantity&lt;au::Hertz,int&gt;)' being compiled\n        with\n        [\n            TargetUnits=au::QuantityMaker&lt;au::Seconds&gt;\n        ]\nD:\\a\\au\\au\\au.hh(6135): note: see reference to function template instantiation 'auto au::inverse_in&lt;TargetUnits,au::Hertz,int&gt;(TargetUnits,au::Quantity&lt;au::Hertz,int&gt;)' being compiled\n        with\n        [\n            TargetUnits=au::QuantityMaker&lt;au::Seconds&gt;\n        ]\n</code></pre></p>"},{"location":"troubleshooting/#deduced-conflicting-types","title":"Deduced conflicting types","text":"<p>Meaning:  In some contexts, it\u2019s not enough to have Quantity types that can easily convert to each other.  (Common examples include the ternary operator <code>?:</code>, and initializer lists.)  You need types that are identical, or very nearly so.  Even fully quantity-equivalent types, such as \\text{Hz} and \\text{s}^{-1}, often won\u2019t work in these contexts!</p> <p>Solution:  You can always cast non-conforming instances to your favored unit, using <code>.as()</code>. For the initializer list case, you can also make an explicit container, which will handle the casting automatically when possible.</p> <p>Example</p> <p>Code</p> BrokenFixed (1. Cast to explicit unit)Fixed (2. Use explicit container) <pre><code>// (BROKEN): Initializer list confused by Hz and s^(-1).\nfor (const auto &amp;frequency : {\n         hertz(1.0),\n         (1 / seconds(2.0)),\n     }) {\n    // ...\n}\n</code></pre> <pre><code>// (FIXED): 1. Cast individual elements to desired unit.\nfor (const auto &amp;frequency : {\n         hertz(1.0),\n         (1 / seconds(2.0)).as(hertz),\n     }) {\n    // ...\n}\n</code></pre> <pre><code>// (FIXED): 2. Use container with explicit type.\nfor (const auto &amp;frequency : std::vector&lt;QuantityD&lt;Hertz&gt;&gt;{\n         hertz(1.0),\n         (1 / seconds(2.0)),\n     }) {\n    // ...\n}\n</code></pre> <p>Compiler error (clang 14) <pre><code>au/error_examples.cc:93:34: error: deduced conflicting types ('Quantity&lt;au::QuantityMaker&lt;au::Hertz&gt;::Unit, [...]&gt;' vs 'Quantity&lt;au::QuantityMaker&lt;au::Pow&lt;au::Seconds, -1&gt;&gt;::Unit, [...]&gt;') for initializer list element type\n    for (const auto &amp;frequency : {\n                                 ^\n</code></pre></p> <p>Compiler error (clang 11) <pre><code>au/error_examples.cc:93:34: error: deduced conflicting types ('Quantity&lt;au::Hertz, [...]&gt;' vs 'Quantity&lt;au::Pow&lt;au::Seconds, -1&gt;, [...]&gt;') for initializer list element type\n    for (const auto &amp;frequency : {\n                                 ^\n</code></pre></p> <p>Compiler error (gcc 10) <pre><code>au/error_examples.cc: In function 'void au::example_deduced_conflicting_types()':\nau/error_examples.cc:96:10: error: unable to deduce 'std::initializer_list&lt;auto&gt;&amp;&amp;' from '{au::hertz.au::QuantityMaker&lt;au::Hertz&gt;::operator()&lt;double&gt;(1.0e+0), au::operator/&lt;int&gt;(1, au::seconds.au::QuantityMaker&lt;au::Seconds&gt;::operator()&lt;double&gt;(2.0e+0))}'\n   96 |          }) {\n      |          ^\nau/error_examples.cc:96:10: note:   deduced conflicting types for parameter 'auto' ('au::Quantity&lt;au::Hertz, double&gt;' and 'au::Quantity&lt;au::Pow&lt;au::Seconds, -1&gt;, double&gt;')\n</code></pre></p> <p>Compiler error (MSVC 2019 x64) <pre><code>error_examples.cc(94): error C3535: cannot deduce type for 'auto &amp;&amp;' from 'initializer list'\nerror_examples.cc(94): error C2440: 'initializing': cannot convert from 'initializer list' to 'std::initializer_list&lt;int&gt; &amp;&amp;'\nerror_examples.cc(97): note: Reason: cannot convert from 'initializer list' to 'std::initializer_list&lt;int&gt;'\nerror_examples.cc(94): note: Element '1': no conversion from 'au::Quantity&lt;au::Hertz,double&gt;' to 'int'\nerror_examples.cc(94): note: Element '2': no conversion from 'au::Quantity&lt;au::Pow&lt;B,-1&gt;,T&gt;' to 'int'\n        with\n        [\n            B=au::Seconds,\n            T=double\n        ]\n</code></pre></p> <p>Compiler error (MSVC 2022 x64) <pre><code>error_examples.cc(94): error C3535: cannot deduce type for 'auto &amp;&amp;' from 'initializer list'\nerror_examples.cc(94): error C2440: 'initializing': cannot convert from 'initializer list' to 'std::initializer_list&lt;int&gt; &amp;&amp;'\nerror_examples.cc(94): note: Reason: cannot convert from 'initializer list' to 'std::initializer_list&lt;int&gt;'\nerror_examples.cc(94): note: Element '1': no conversion from 'au::Quantity&lt;au::Hertz,double&gt;' to 'int'\nerror_examples.cc(94): note: Element '2': no conversion from 'au::Quantity&lt;au::Pow&lt;B,-1&gt;,T&gt;' to 'int'\n        with\n        [\n            B=au::Seconds,\n            T=double\n        ]\n</code></pre></p>"},{"location":"troubleshooting/#broken-strict-total-ordering","title":"Broken strict total ordering","text":"<p>Meaning:  This means you performed an operation that needs to put unit types into a parameter pack \u2014 say, a common unit, or a unit product \u2014 but the library couldn\u2019t figure out how to order the units inside that pack.</p> <p>If that sounds obscure, it is: ordering units inside packs is a deep library implementation detail, and we try to avoid letting end users encounter this.  To reach this error, you need two distinct units that have the same Dimension, Magnitude, and Origin.  That\u2019s a necessary but not sufficient condition: for example, even <code>UnitInverseT&lt;Seconds&gt;</code> and <code>Hertz</code> won\u2019t trigger this!</p> More background info on why this error exists <p>In case you want to understand more, here is the gist.</p> <p>Au is heavily based on parameter packs.  Some of these packs, such as <code>UnitProduct&lt;...&gt;</code> and <code>CommonUnit&lt;...&gt;</code>, take units as their arguments.</p> <p>Every parameter pack needs an unambiguous canonical ordering for any possible set of input arguments.  Therefore, we need to create a strict total ordering for the (infinitely many!) unit types that could appear in these packs.  This ordering needs to be known at compile time. The ordering itself doesn\u2019t matter so much, but if we don\u2019t strictly adhere to some ordering, it\u2019s undefined behaviour.</p> <p>Our strategy is to construct a \u201cgauntlet\u201d of properties which we can measure for any unit (e.g., Dimension, Magnitude, \u2026), and define some arbitrary ordering for each property.  We then compare the units on each property in turn.  The first one where they differ \u201cwins\u201d.  If we get through all the properties, and they\u2019re still tied, then we have two distinct unit types which compare as equal.  This would be undefined behaviour!  Rather than silently ignoring this, we manifest this as a compiler error.</p> <p>That is what \u201cbroken strict total ordering\u201d means.</p> <p>Solution:  If you have two distinct units, and the library can\u2019t figure out how to order them, you can force a particular ordering.  Choose one of the units and give it a high \u201cunit avoidance\u201d score (see example below).  This will break the tie.</p> <p>Again, this is pretty unusual.  For most normal ways of forming units, the library should automatically be able to define an ordering for them.  If you do hit this error, it may be worth pausing to double-check that you\u2019re using the library correctly.  If you\u2019ve checked, and it still seems like something the library should be able to handle, feel free to file an issue \u2014 maybe there\u2019s a way we can improve our ordering!</p> <p>Tip</p> <p>If you hit this error, you might be annoyed by its obscurity.  Instead, try feeling relieved! After all, the alternative is not \u201ccorrectly working program\u201d, but \u201csilent undefined behaviour\u201d. A compiler error with a searchable error message is infinitely preferable to the latter.</p> <p>Example</p> <p>Code</p> <p>Note that this example is somewhat convoluted, but again, that\u2019s to be expected because this error is pretty hard to hit in practice.</p> BrokenFixed <pre><code>struct Quarterfeet : decltype(Feet{} / mag&lt;4&gt;()) {};\nconstexpr auto quarterfeet = QuantityMaker&lt;Quarterfeet&gt;{};\n\nstruct Trinches : decltype(Inches{} * mag&lt;3&gt;()) {};\nconstexpr auto trinches = QuantityMaker&lt;Trinches&gt;{};\n\n// (BROKEN): Can't tell how to order Quarterfeet and Trinches when forming common type\nif (quarterfeet(10) == trinches(10)) {\n    // ...\n}\n</code></pre> <pre><code>struct Quarterfeet : decltype(Feet{} / mag&lt;4&gt;()) {};\nconstexpr auto quarterfeet = QuantityMaker&lt;Quarterfeet&gt;{};\n\nstruct Trinches : decltype(Inches{} * mag&lt;3&gt;()) {};\nconstexpr auto trinches = QuantityMaker&lt;Trinches&gt;{};\n\nnamespace au { namespace detail {\ntemplate &lt;&gt;\nstruct UnitAvoidance&lt;::Trinches&gt; : std::integral_constant&lt;int, 100&gt; {};\n}}\n\n// (FIXED): Trinches has high \"unit avoidance\", so it goes after Quarterfeet\nif (quarterfeet(10) == trinches(10)) {\n    // ...\n}\n</code></pre> <p>Compiler error (clang 14) <pre><code>In file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:20:\nIn file included from au/code/au/prefix.hh:18:\nIn file included from au/code/au/quantity.hh:19:\nIn file included from au/code/au/apply_magnitude.hh:17:\nIn file included from au/code/au/apply_rational_magnitude_to_integral.hh:19:\nIn file included from au/code/au/magnitude.hh:21:\nau/code/au/packs.hh:287:5: error: static_assert failed due to requirement 'std::is_same&lt;au::Quarterfeet, au::Trinches&gt;::value' \"Broken strict total ordering: distinct input types compare equal\"\n    static_assert(std::is_same&lt;A, B&gt;::value,\n    ^             ~~~~~~~~~~~~~~~~~~~~~~~~~\nau/code/au/packs.hh:303:5: note: in instantiation of template class 'au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches&gt;' requested here\n    std::conditional_t&lt;\n    ^\nau/code/au/packs.hh:303:5: note: in instantiation of template class 'au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches, au::detail::OrderAsUnitProduct&gt;' requested here\nau/code/au/packs.hh:303:5: note: in instantiation of template class 'au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct&gt;' requested here\nau/code/au/packs.hh:303:5: note: in instantiation of template class 'au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct&gt;' requested here\nau/code/au/packs.hh:303:5: note: in instantiation of template class 'au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct&gt;' requested here\nau/code/au/unit_of_measure.hh:920:40: note: (skipping 8 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)\nstruct InOrderFor&lt;UnitProduct, A, B&gt; : LexicographicTotalOrdering&lt;A,\n                                       ^\nau/code/au/quantity.hh:762:7: note: in instantiation of template class 'au::CommonQuantity&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;&gt;' requested here\n    : au::CommonQuantity&lt;au::Quantity&lt;U1, R1&gt;, au::Quantity&lt;U2, R2&gt;&gt; {};\n      ^\nexternal/llvm_14_toolchain_llvm/bin/../include/c++/v1/type_traits:2388:25: note: in instantiation of template class 'std::common_type&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;&gt;' requested here\ntemplate &lt;class ..._Tp&gt; using common_type_t = typename common_type&lt;_Tp...&gt;::type;\n                        ^\nau/code/au/quantity.hh:625:20: note: in instantiation of template type alias 'common_type_t' requested here\n    using C = std::common_type_t&lt;T, U&gt;;\n                   ^\nau/code/au/quantity.hh:637:20: note: in instantiation of function template specialization 'au::detail::using_common_type&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;, au::detail::Equal&gt;' requested here\n    return detail::using_common_type(q1, q2, detail::equal);\n                   ^\nau/error_examples.cc:112:25: note: in instantiation of function template specialization 'au::operator==&lt;au::Quarterfeet, au::Trinches, int, int&gt;' requested here\n    if (quarterfeet(10) == trinches(10)) {\n                        ^\n</code></pre></p> <p>Compiler error (clang 11) <pre><code>In file included from au/error_examples.cc:15:\nIn file included from au/code/au/au.hh:17:\nIn file included from au/code/au/chrono_interop.hh:20:\nIn file included from au/code/au/prefix.hh:18:\nIn file included from au/code/au/quantity.hh:19:\nIn file included from au/code/au/apply_magnitude.hh:17:\nIn file included from au/code/au/apply_rational_magnitude_to_integral.hh:19:\nIn file included from au/code/au/magnitude.hh:21:\nau/code/au/packs.hh:287:5: error: static_assert failed due to requirement 'std::is_same&lt;au::Quarterfeet, au::Trinches&gt;::value' \"Broken strict total ordering: distinct input types compare equal\"\n    static_assert(std::is_same&lt;A, B&gt;::value,\n    ^             ~~~~~~~~~~~~~~~~~~~~~~~~~\nau/code/au/packs.hh:303:5: note: in instantiation of template class 'au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches&gt;' requested here\n    std::conditional_t&lt;\n    ^\nau/code/au/packs.hh:303:5: note: in instantiation of template class 'au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches, OrderAsUnitProduct&gt;' requested here\nau/code/au/packs.hh:303:5: note: in instantiation of template class 'au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches, OrderByOrigin, OrderAsUnitProduct&gt;' requested here\nau/code/au/packs.hh:303:5: note: in instantiation of template class 'au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches, OrderByMag, OrderByOrigin, OrderAsUnitProduct&gt;' requested here\nau/code/au/packs.hh:303:5: note: in instantiation of template class 'au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches, OrderByDim, OrderByMag, OrderByOrigin, OrderAsUnitProduct&gt;' requested here\nau/code/au/unit_of_measure.hh:920:40: note: (skipping 8 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)\nstruct InOrderFor&lt;UnitProduct, A, B&gt; : LexicographicTotalOrdering&lt;A,\n                                       ^\nau/code/au/quantity.hh:762:7: note: in instantiation of template class 'au::CommonQuantity&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;, void&gt;' requested here\n    : au::CommonQuantity&lt;au::Quantity&lt;U1, R1&gt;, au::Quantity&lt;U2, R2&gt;&gt; {};\n      ^\nexternal/llvm_11_toolchain_llvm/bin/../include/c++/v1/type_traits:2462:25: note: in instantiation of template class 'std::__1::common_type&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;&gt;' requested here\ntemplate &lt;class ..._Tp&gt; using common_type_t = typename common_type&lt;_Tp...&gt;::type;\n                        ^\nau/code/au/quantity.hh:625:20: note: in instantiation of template type alias 'common_type_t' requested here\n    using C = std::common_type_t&lt;T, U&gt;;\n                   ^\nau/code/au/quantity.hh:637:20: note: in instantiation of function template specialization 'au::detail::using_common_type&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;, au::detail::Equal&gt;' requested here\n    return detail::using_common_type(q1, q2, detail::equal);\n                   ^\nau/error_examples.cc:112:25: note: in instantiation of function template specialization 'au::operator==&lt;au::Quarterfeet, au::Trinches, int, int&gt;' requested here\n    if (quarterfeet(10) == trinches(10)) {\n                        ^\n</code></pre></p> <p>Compiler error (gcc 10) <pre><code>In file included from au/code/au/magnitude.hh:21,\n                 from au/code/au/apply_rational_magnitude_to_integral.hh:19,\n                 from au/code/au/apply_magnitude.hh:17,\n                 from au/code/au/quantity.hh:19,\n                 from au/code/au/prefix.hh:18,\n                 from au/code/au/chrono_interop.hh:20,\n                 from au/code/au/au.hh:17,\n                 from au/error_examples.cc:15:\nau/code/au/packs.hh: In instantiation of 'struct au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches&gt;':\nau/code/au/packs.hh:298:8:   recursively required from 'struct au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct&gt;'\nau/code/au/packs.hh:298:8:   required from 'struct au::LexicographicTotalOrdering&lt;au::Quarterfeet, au::Trinches, au::detail::OrderByUnitAvoidance, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct&gt;'\nau/code/au/unit_of_measure.hh:920:8:   required from 'struct au::InOrderFor&lt;au::UnitProduct, au::Quarterfeet, au::Trinches&gt;'\nau/code/au/unit_of_measure.hh:505:8:   required from 'struct au::InOrderFor&lt;au::CommonUnit, au::Quarterfeet, au::Trinches&gt;'\nau/code/au/packs.hh:383:8:   required from 'struct au::FlatDedupedTypeList&lt;au::CommonUnit, au::CommonUnit&lt;au::Quarterfeet&gt;, au::CommonUnit&lt;au::Trinches&gt; &gt;'\nau/code/au/unit_of_measure.hh:592:8:   required from 'struct au::ComputeCommonUnit&lt;au::Quarterfeet, au::Trinches&gt;'\nau/code/au/quantity.hh:748:8:   required from 'struct au::CommonQuantity&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;, void&gt;'\nau/code/au/quantity.hh:761:8:   required from 'struct std::common_type&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt; &gt;'\nexternal/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11:   required by substitution of 'template&lt;class ... _Tp&gt; using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;}]'\nau/code/au/quantity.hh:625:11:   required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity&lt;au::Quarterfeet, int&gt;; U = au::Quantity&lt;au::Trinches, int&gt;; Func = au::detail::Equal]'\nau/code/au/quantity.hh:637:37:   required from 'constexpr bool au::operator==(au::Quantity&lt;U1, R1&gt;, au::Quantity&lt;U2, R2&gt;) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]'\nau/error_examples.cc:112:39:   required from here\nau/code/au/packs.hh:287:39: error: static assertion failed: Broken strict total ordering: distinct input types compare equal\n  287 |     static_assert(std::is_same&lt;A, B&gt;::value,\n      |                                       ^~~~~\nau/code/au/packs.hh: In instantiation of 'struct au::LexicographicTotalOrdering&lt;au::Trinches, au::Quarterfeet&gt;':\nau/code/au/packs.hh:298:8:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]\nau/code/au/unit_of_measure.hh:505:8:   required from 'struct au::InOrderFor&lt;au::CommonUnit, au::Trinches, au::Quarterfeet&gt;'\nau/code/au/unit_of_measure.hh:554:8:   required from 'struct au::detail::IsFirstUnitRedundant&lt;au::CommonUnit, au::Quarterfeet, au::Trinches&gt;'\nau/code/au/unit_of_measure.hh:564:8:   required from 'struct au::detail::EliminateRedundantUnitsImpl&lt;au::CommonUnit&lt;au::Trinches, au::Quarterfeet&gt; &gt;'\nau/code/au/unit_of_measure.hh:592:8:   required from 'struct au::ComputeCommonUnit&lt;au::Quarterfeet, au::Trinches&gt;'\nau/code/au/quantity.hh:748:8:   required from 'struct au::CommonQuantity&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;, void&gt;'\nau/code/au/quantity.hh:761:8:   required from 'struct std::common_type&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt; &gt;'\nexternal/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11:   required by substitution of 'template&lt;class ... _Tp&gt; using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;}]'\nau/code/au/quantity.hh:625:11:   required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity&lt;au::Quarterfeet, int&gt;; U = au::Quantity&lt;au::Trinches, int&gt;; Func = au::detail::Equal]'\nau/code/au/quantity.hh:637:37:   required from 'constexpr bool au::operator==(au::Quantity&lt;U1, R1&gt;, au::Quantity&lt;U2, R2&gt;) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]'\nau/error_examples.cc:112:39:   required from here\nau/code/au/packs.hh:287:39: error: static assertion failed: Broken strict total ordering: distinct input types compare equal\nIn file included from au/code/au/conversion_policy.hh:22,\n                 from au/code/au/quantity.hh:20,\n                 from au/code/au/prefix.hh:18,\n                 from au/code/au/chrono_interop.hh:20,\n                 from au/code/au/au.hh:17,\n                 from au/error_examples.cc:15:\nau/code/au/unit_of_measure.hh: In instantiation of 'struct au::CommonUnit&lt;au::Trinches, au::Quarterfeet&gt;':\nau/code/au/packs.hh:203:7:   required by substitution of 'template&lt;class U&gt; using DimMemberT = typename U::Dim [with U = au::CommonUnit&lt;au::Trinches, au::Quarterfeet&gt;]'\nau/code/au/packs.hh:205:8:   required from 'struct au::detail::DimImpl&lt;au::CommonUnit&lt;au::Trinches, au::Quarterfeet&gt; &gt;'\nau/code/au/unit_of_measure.hh:455:8:   required from 'struct au::HasSameDimension&lt;au::CommonUnit&lt;au::Trinches, au::Quarterfeet&gt;, au::Trinches&gt;'\nau/code/au/stdx/type_traits.hh:38:59:   required from 'struct au::stdx::conjunction&lt;au::HasSameDimension&lt;au::CommonUnit&lt;au::Trinches, au::Quarterfeet&gt;, au::Trinches&gt;, au::detail::HasSameMagnitude&lt;au::CommonUnit&lt;au::Trinches, au::Quarterfeet&gt;, au::Trinches&gt; &gt;'\nau/code/au/unit_of_measure.hh:470:8:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]\nau/code/au/unit_of_measure.hh:592:8:   required from 'struct au::ComputeCommonUnit&lt;au::Quarterfeet, au::Trinches&gt;'\nau/code/au/quantity.hh:748:8:   required from 'struct au::CommonQuantity&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;, void&gt;'\nau/code/au/quantity.hh:761:8:   required from 'struct std::common_type&lt;au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt; &gt;'\nexternal/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11:   required by substitution of 'template&lt;class ... _Tp&gt; using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity&lt;au::Quarterfeet, int&gt;, au::Quantity&lt;au::Trinches, int&gt;}]'\nau/code/au/quantity.hh:625:11:   required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity&lt;au::Quarterfeet, int&gt;; U = au::Quantity&lt;au::Trinches, int&gt;; Func = au::detail::Equal]'\nau/code/au/quantity.hh:637:37:   required from 'constexpr bool au::operator==(au::Quantity&lt;U1, R1&gt;, au::Quantity&lt;U2, R2&gt;) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]'\nau/error_examples.cc:112:39:   required from here\nau/code/au/unit_of_measure.hh:495:70: error: static assertion failed: Elements must be listed in ascending order\n  495 |     static_assert(AreElementsInOrder&lt;CommonUnit, CommonUnit&lt;Us...&gt;&gt;::value,\n      |                                                                      ^~~~~\n</code></pre></p> <p>Compiler error (MSVC 2019 x64) <pre><code>D:\\a\\au\\au\\au.hh(1392): error C2338: Broken strict total ordering: distinct input types compare equal\nD:\\a\\au\\au\\au.hh(1423): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1423): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B,au::detail::OrderAsUnitProduct&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1423): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B,au::detail::OrderByOrigin,au::detail::OrderAsUnitProduct&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1423): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B,au::detail::OrderByMag,au::detail::OrderByOrigin,au::detail::OrderAsUnitProduct&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1423): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B,au::detail::OrderByDim,au::detail::OrderByMag,au::detail::OrderByOrigin,au::detail::OrderAsUnitProduct&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3563): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B,au::detail::OrderByUnitAvoidance,au::detail::OrderByDim,au::detail::OrderByMag,au::detail::OrderByOrigin,au::detail::OrderAsUnitProduct&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3142): note: see reference to class template instantiation 'au::InOrderFor&lt;au::UnitProduct,A,B&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1502): note: see reference to class template instantiation 'au::InOrderFor&lt;List,T,H&gt;' being compiled\n        with\n        [\n            List=au::CommonUnit,\n            T=au::Quarterfeet,\n            H=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3226): note: see reference to class template instantiation 'au::FlatDedupedTypeList&lt;au::CommonUnit,au::CommonUnit&lt;T&gt;,au::CommonUnit&lt;au::Trinches&gt;&gt;' being compiled\n        with\n        [\n            T=au::Quarterfeet\n        ]\nD:\\a\\au\\au\\au.hh(3226): note: see reference to alias template instantiation 'au::FlatDedupedTypeListT&lt;au::CommonUnit,au::Quarterfeet,au::Trinches&gt;' being compiled\nD:\\a\\au\\au\\au.hh(3230): note: see reference to alias template instantiation 'au::ComputeCommonUnitImpl&lt;au::Quarterfeet,au::Trinches&gt;' being compiled\nD:\\a\\au\\au\\au.hh(4619): note: see reference to class template instantiation 'au::ComputeCommonUnit&lt;U1,U2&gt;' being compiled\n        with\n        [\n            U1=au::Quarterfeet,\n            U2=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(4619): note: see reference to alias template instantiation 'au::CommonUnitT&lt;au::Quarterfeet,au::Trinches&gt;' being compiled\nD:\\a\\au\\au\\au.hh(4630): note: see reference to class template instantiation 'au::CommonQuantity&lt;au::Quantity&lt;au::Quarterfeet,int&gt;,au::Quantity&lt;au::Trinches,int&gt;,void&gt;' being compiled\nD:\\a\\au\\au\\au.hh(4493): note: see reference to class template instantiation 'std::common_type&lt;T,U&gt;' being compiled\n        with\n        [\n            T=au::Quantity&lt;au::Quarterfeet,int&gt;,\n            U=au::Quantity&lt;au::Trinches,int&gt;\n        ]\nD:\\a\\au\\au\\au.hh(4493): note: see reference to alias template instantiation 'std::common_type_t&lt;au::Quantity&lt;au::Quarterfeet,int&gt;,U&gt;' being compiled\n        with\n        [\n            U=au::Quantity&lt;au::Trinches,int&gt;\n        ]\nD:\\a\\au\\au\\au.hh(4505): note: see reference to function template instantiation 'auto au::detail::using_common_type&lt;au::Quantity&lt;au::Quarterfeet,int&gt;,au::Quantity&lt;au::Trinches,int&gt;,au::detail::Equal&gt;(T,U,Func)' being compiled\n        with\n        [\n            T=au::Quantity&lt;au::Quarterfeet,int&gt;,\n            U=au::Quantity&lt;au::Trinches,int&gt;,\n            Func=au::detail::Equal\n        ]\nerror_examples.cc(113): note: see reference to function template instantiation 'bool au::operator ==&lt;au::Quarterfeet,au::Trinches,int,int&gt;(au::Quantity&lt;au::Quarterfeet,int&gt;,au::Quantity&lt;au::Trinches,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(3132): error C2338: Elements must be listed in ascending order\nD:\\a\\au\\au\\au.hh(1310): note: see reference to class template instantiation 'au::CommonUnit&lt;T,au::Quarterfeet&gt;' being compiled\n        with\n        [\n            T=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3133): note: see reference to alias template instantiation 'au::detail::DimMemberT&lt;au::CommonUnit&lt;T,au::Quarterfeet&gt;&gt;' being compiled\n        with\n        [\n            T=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3094): note: see reference to class template instantiation 'au::detail::DimImpl&lt;U1&gt;' being compiled\n        with\n        [\n            U1=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;\n        ]\nD:\\a\\au\\au\\au.hh(3093): note: see reference to alias template instantiation 'au::detail::DimT&lt;au::CommonUnit&lt;T,au::Quarterfeet&gt;&gt;' being compiled\n        with\n        [\n            T=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(210): note: see reference to class template instantiation 'au::HasSameDimension&lt;U1,U2&gt;' being compiled\n        with\n        [\n            U1=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;,\n            U2=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3108): note: see reference to class template instantiation 'au::stdx::conjunction&lt;au::HasSameDimension&lt;U1,U2&gt;,au::detail::HasSameMagnitude&lt;U1,U2&gt;&gt;' being compiled\n        with\n        [\n            U1=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;,\n            U2=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3172): note: see reference to class template instantiation 'au::AreUnitsQuantityEquivalent&lt;TargetUnit,H&gt;' being compiled\n        with\n        [\n            TargetUnit=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;,\n            H=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3230): note: see reference to class template instantiation 'au::detail::FirstMatchingUnit&lt;au::AreUnitsQuantityEquivalent,au::CommonUnit&lt;T,au::Quarterfeet&gt;,TargetUnit&gt;' being compiled\n        with\n        [\n            T=au::Trinches,\n            TargetUnit=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;\n        ]\n</code></pre></p> <p>Compiler error (MSVC 2022 x64) <pre><code>D:\\a\\au\\au\\au.hh(1392): error C2338: static_assert failed: 'Broken strict total ordering: distinct input types compare equal'\nD:\\a\\au\\au\\au.hh(1392): note: the template instantiation context (the oldest one first) is\nerror_examples.cc(113): note: see reference to function template instantiation 'bool au::operator ==&lt;au::Quarterfeet,au::Trinches,int,int&gt;(au::Quantity&lt;au::Quarterfeet,int&gt;,au::Quantity&lt;au::Trinches,int&gt;)' being compiled\nD:\\a\\au\\au\\au.hh(4505): note: see reference to function template instantiation 'auto au::detail::using_common_type&lt;au::Quantity&lt;au::Quarterfeet,int&gt;,au::Quantity&lt;au::Trinches,int&gt;,au::detail::Equal&gt;(T,U,Func)' being compiled\n        with\n        [\n            T=au::Quantity&lt;au::Quarterfeet,int&gt;,\n            U=au::Quantity&lt;au::Trinches,int&gt;,\n            Func=au::detail::Equal\n        ]\nD:\\a\\au\\au\\au.hh(4493): note: see reference to alias template instantiation 'std::common_type_t&lt;T,U&gt;' being compiled\n        with\n        [\n            T=au::Quantity&lt;au::Quarterfeet,int&gt;,\n            U=au::Quantity&lt;au::Trinches,int&gt;\n        ]\nC:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\VC\\Tools\\MSVC\\14.41.34120\\include\\type_traits(1334): note: see reference to class template instantiation 'std::common_type&lt;T,U&gt;' being compiled\n        with\n        [\n            T=au::Quantity&lt;au::Quarterfeet,int&gt;,\n            U=au::Quantity&lt;au::Trinches,int&gt;\n        ]\nD:\\a\\au\\au\\au.hh(4630): note: see reference to class template instantiation 'au::CommonQuantity&lt;au::Quantity&lt;au::Quarterfeet,int&gt;,au::Quantity&lt;au::Trinches,int&gt;,void&gt;' being compiled\nD:\\a\\au\\au\\au.hh(4619): note: see reference to alias template instantiation 'au::CommonUnitT&lt;U1,U2&gt;' being compiled\n        with\n        [\n            U1=au::Quarterfeet,\n            U2=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(2806): note: see reference to class template instantiation 'au::ComputeCommonUnit&lt;U1,U2&gt;' being compiled\n        with\n        [\n            U1=au::Quarterfeet,\n            U2=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3230): note: see reference to alias template instantiation 'au::ComputeCommonUnitImpl&lt;U1,U2&gt;' being compiled\n        with\n        [\n            U1=au::Quarterfeet,\n            U2=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3226): note: see reference to alias template instantiation 'au::FlatDedupedTypeListT&lt;au::CommonUnit,U1,U2&gt;' being compiled\n        with\n        [\n            U1=au::Quarterfeet,\n            U2=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1213): note: see reference to class template instantiation 'au::FlatDedupedTypeList&lt;au::CommonUnit,au::CommonUnit&lt;T&gt;,au::CommonUnit&lt;au::Trinches&gt;&gt;' being compiled\n        with\n        [\n            T=au::Quarterfeet\n        ]\nD:\\a\\au\\au\\au.hh(1496): note: see reference to class template instantiation 'au::InOrderFor&lt;List,T,H&gt;' being compiled\n        with\n        [\n            List=au::CommonUnit,\n            T=au::Quarterfeet,\n            H=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3142): note: see reference to class template instantiation 'au::InOrderFor&lt;au::UnitProduct,A,B&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3557): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B,au::detail::OrderByUnitAvoidance,au::detail::OrderByDim,au::detail::OrderByMag,au::detail::OrderByOrigin,au::detail::OrderAsUnitProduct&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1408): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B,au::detail::OrderByDim,au::detail::OrderByMag,au::detail::OrderByOrigin,au::detail::OrderAsUnitProduct&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1408): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B,au::detail::OrderByMag,au::detail::OrderByOrigin,au::detail::OrderAsUnitProduct&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1408): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B,au::detail::OrderByOrigin,au::detail::OrderAsUnitProduct&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1408): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B,au::detail::OrderAsUnitProduct&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(1408): note: see reference to class template instantiation 'au::LexicographicTotalOrdering&lt;A,B&gt;' being compiled\n        with\n        [\n            A=au::Quarterfeet,\n            B=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3132): error C2338: static_assert failed: 'Elements must be listed in ascending order'\nD:\\a\\au\\au\\au.hh(3132): note: the template instantiation context (the oldest one first) is\nD:\\a\\au\\au\\au.hh(3230): note: see reference to class template instantiation 'au::detail::FirstMatchingUnit&lt;au::AreUnitsQuantityEquivalent,au::CommonUnit&lt;T,au::Quarterfeet&gt;,TargetUnit&gt;' being compiled\n        with\n        [\n            T=au::Trinches,\n            TargetUnit=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;\n        ]\nD:\\a\\au\\au\\au.hh(3170): note: see reference to class template instantiation 'au::AreUnitsQuantityEquivalent&lt;TargetUnit,H&gt;' being compiled\n        with\n        [\n            TargetUnit=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;,\n            H=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3108): note: see reference to class template instantiation 'au::stdx::conjunction&lt;au::HasSameDimension&lt;U1,U2&gt;,au::detail::HasSameMagnitude&lt;U1,U2&gt;&gt;' being compiled\n        with\n        [\n            U1=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;,\n            U2=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(210): note: see reference to class template instantiation 'au::HasSameDimension&lt;U1,U2&gt;' being compiled\n        with\n        [\n            U1=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;,\n            U2=au::Trinches\n        ]\nD:\\a\\au\\au\\au.hh(3093): note: see reference to alias template instantiation 'au::detail::DimT&lt;U1&gt;' being compiled\n        with\n        [\n            U1=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;\n        ]\nD:\\a\\au\\au\\au.hh(1312): note: see reference to class template instantiation 'au::detail::DimImpl&lt;U1&gt;' being compiled\n        with\n        [\n            U1=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;\n        ]\nD:\\a\\au\\au\\au.hh(1310): note: see reference to alias template instantiation 'au::detail::DimMemberT&lt;U&gt;' being compiled\n        with\n        [\n            U=au::CommonUnit&lt;au::Trinches,au::Quarterfeet&gt;\n        ]\nD:\\a\\au\\au\\au.hh(1308): note: see reference to class template instantiation 'au::CommonUnit&lt;T,au::Quarterfeet&gt;' being compiled\n        with\n        [\n            T=au::Trinches\n        ]\n</code></pre></p>"},{"location":"alternatives/","title":"Comparison of Alternatives","text":"<p>There are plenty of other open source C++ units libraries, many quite well established.  However, the tradeoffs required to use these libraries can be so significant that many people can\u2019t or won\u2019t use them.  For example: the compiler errors may be inscrutable or overwhelming; the compilation process may become unacceptably slow; or, the required C++ standard may simply be too new for a user.</p> <p>Au is an accessible, production-tested alternative.  We provide a number of rare or outright novel features, with a small compile time footprint \u2014 and we\u2019re compatible with every C++ version back to the mature and widely available C++14 standard. Key features include:</p> <ul> <li>Fully unit-safe APIs, on both entry and exit.</li> <li>The \u201csafety surface\u201d: conversions that adapt to the overflow risk based on both conversion   magnitude, and storage type.</li> <li>Highly composable \u201cquantity maker\u201d APIs make it easy to both compose new units, and apply unit   prefixes, on the fly.</li> <li>Human-readable and concise compiler errors, via strong typenames for units.</li> <li>The <code>Zero</code> type: novel, fluent handling of construction, comparison, and sign handling for   quantities.</li> <li>Ease of migration (both to and from Au): with minimal setup, we support bidirectional implicit   conversions with equivalent types from any other units library.</li> <li>Support for single-header-file delivery, but with easy customization of units and features to   include.</li> <li>Proven track record supporting embedded applications as first class citizens, via such features as   our safe handling of integer Rep, treating all Reps on equal footing, and our easy ability to   exclude expensive <code>&lt;iostream&gt;</code> support.</li> <li>Intelligent, unit-aware functions for rounding and computing inverses.</li> <li>Minimal friction by using a single, short namespace: everything\u2019s in <code>au::</code>.</li> </ul>"},{"location":"alternatives/#alternatives-considered-here","title":"Alternatives considered here","text":"<p>We\u2019ll consider several of the most prominent alternatives in more detail.  While there are many more libraries, the ones we consider here are included for being especially pioneering or popular (or both).  Here, we list those libraries, indicate which version we considered, and say a few words about why we included it in the analysis.</p> <ul> <li>Boost Units (version:   1.82.0)<ul> <li>One of the longest-standing C++ unit libraries, and the most prominent pre-C++14 option.</li> </ul> </li> <li>nholthaus/units (version: 2.3.3)<ul> <li>Kicked off the revolution in modern (that is, post-C++11 watershed) units libraries.</li> <li>Its laser-sharp focus on accessibility and low friction have made it probably the most widely   used C++ units library to date.</li> </ul> </li> <li>bernedom/SI (version: 2.5.1)<ul> <li>A newer, C++17-compatible offering with a large number of GitHub stars.</li> </ul> </li> <li>mp-units (version: 2.0.0)<ul> <li>A library designed to take full advantage of ultra-modern (that is, post-C++20 watershed)   features, such as concepts and non-template type parameters (NTTPs).</li> <li>mp-units is leading the efforts towards a standard C++ units library, both by field testing   new API designs, and by coordinating with the authors of other leading units libraries.</li> </ul> </li> </ul>"},{"location":"alternatives/#detailed-comparison-matrices","title":"Detailed comparison matrices","text":"<p>Here\u2019s a more detailed comparison to the alternatives listed above.  We\u2019ll use the following legend<sup>1</sup>:</p> Legend Lacks feature / poor support Fair / basic support Good / solid support Best support (of libraries considered here)"},{"location":"alternatives/#obtaining-the-library","title":"Obtaining the library","text":"<p>These are the first criteria to consider.  They will tell you whether you can even use the library at all, and if so, how hard it will be to obtain.</p> Boost nholthaus bernedom/SI mp-units Au C++ Version Compatibility <p>The minimum C++ standard required to use the library.</p> C++98 C++14 C++17 C++20 C++14 Ease of Acquisition <p>Ease of including this library in projects using a wide variety of build environments</p> Part of boost Single, self-contained header Available on conan Available on conan and vcpkg <p>Supports single-header delivery, with features:             <ul> <li>Easy to customize units and I/O support</li> <li>Version-stamped for full reproducibility</li> </ul> <p>Note</p> <p>These ratings are written with all users and projects in mind.  Keep in mind that what matters for you is your project.</p> <p>For example: mp-units gets low accessibility ratings because of its steep C++20 minimum requirement, and its dependence on a package manager to make the installation easy.  However, if your project is already compatible with C++20, and already uses conan, then these \u201clow\u201d ratings would be completely irrelevant for you.</p>"},{"location":"alternatives/#generic-developer-experience","title":"Generic developer experience","text":"<p>Next: how will this library change the generic developer experience?  Leaving aside any library features, conventions, or implementation strategies, there are two main impacts to developer experience.</p> <ol> <li> <p>Your program will take longer to compile, because the compiler is doing more work to produce    essentially the same program.</p> </li> <li> <p>You will get more compiler errors that developers will need to understand and fix.</p> </li> </ol> <p>These costs can bring significant benefits, but we still want them to be as small as possible.</p> Boost nholthaus bernedom/SI mp-units Au Compilation Speed <p>The extra time the library adds to compiling a translation unit, compared to no units library.</p> <ul> <li>Poor: typically adds several seconds per translation unit</li> <li>Fair: enough that end users tend to notice</li> <li>Good: not \"subjectively noticeable\"</li> </ul> Very slow, but can be greatly improved by removing I/O support and most units <ul> <li>Includes `fwd.hh` headers</li> <li>Possibly \"best\" overall, but will need to assess all libraries on the same code</li> </ul> Compiler Error Readability <p>                     The ability to understand errors when the library catches a mistake it was                     designed to catch.                 </p> <ul> <li>Poor: Excessively long, nested types</li> <li>Fair: Short, but dimension names lacking</li> <li>Good: Brief typenames with user-facing unit names</li> </ul>                  Infamously challenging              Positional dimensions Alias for unit template <ul> <li>Pioneered strong typedefs for units</li> <li>Expression                 templates produce very readable errors                 </li> </ul> <ul> <li>Strong unit typenames appear in errors</li> <li>Short namespace minimizes clutter</li> <li>                     Detailed troubleshooting                     guide </li> </ul>"},{"location":"alternatives/#library-features","title":"Library features","text":"<p>At this point, you\u2019ve assessed:</p> <ul> <li>whether you can use each library at all;</li> <li>how hard it will be to add to your project;</li> <li>and, what costs you\u2019ll pay in developer experience if you do.</li> </ul> <p>Now we\u2019re ready to compare the libraries \u201cas units libraries\u201d \u2014 that is, in terms of their core features.</p> <p>Note</p> <p>The features are listed, very roughly, in order of importance.  Counting up the colors in each column won\u2019t give an accurate picture.  The rows near the top matter more \u2014 sometimes, much more \u2014 than the rows further down.</p> <p>Of course, what matters the most for you are your use cases and criteria!</p> Boost nholthaus bernedom/SI mp-units Au Conversion Safety <p>Guarding against unit conversions that are likely to produce large errors.</p> <p>                     (For example: we can convert an integer number of feet to inches, but not vice                     versa.)                 </p>              Integer Reps unsafe              Integer Reps unsafe              Policy consistent             with <code>std::chrono</code> library              Meets `std::chrono` baseline, plus:             <ul> <li>Automatically adapts to level of overflow risk</li> <li>Runtime conversion checkers</li> <li>Constants have perfect conversion policy</li> </ul> Unit Safety <p>                     The ability to judge the unit-correctness of every individual line of code                     by inspection, in isolation.                 </p> <ul> <li> Fair: can achieve indirectly, by casting to known type before                         retrieving value.                     </li> <li>Good: provide unit-safe interfaces.</li> </ul> Only contains unit-safe interfaces Only contains unit-safe interfaces Low Friction <p>How easy it is to develop with the library.  Criteria include:</p> <ul> <li>Headers: few, or easily guessable</li> <li>Simple namespace structure</li> <li>Reasonable, safe implicit conversions</li> </ul> <ul> <li>Generally high learning curve</li> <li>                     No (non-trivial)                     implicit conversions                 </li> <li>Many headers; hard to guess</li> </ul> <ul> <li>Single file is very easy</li> <li>User-friendly API typenames (<code>meter_t</code>, ...)</li> <li>                     Namespaces add verbosity, and friction (for example, <code>math::</code>                     namespace prevents ADL)                 </li> </ul> <ul> <li>Single, short namespace</li> <li>Implicit conversions</li> <li>Multiple headers, but easy to guess (one per dimension)</li> </ul> <ul> <li>Implicit conversions with good basic safety</li> <li> Multiple                     headers, one per system                 </li> <li>Longer and more nested namespaces</li> </ul> <ul> <li>Namespaces: just one, and it's short</li> <li>Includes: either single-header, or easily-guessable header per unit</li> </ul> Composability <p>                     The ability to fluently combine the abstractions for units and prefixes to form                     new units on the fly.                 </p> <ul> <li>                     Can compose units, prefixes, dimensions, and quantity (point) makers                 </li> <li>                     Type names clunky to compose: must write <code>decltype</code> </li> </ul> No No <ul> <li>Can compose units, prefixes, dimensions, and quantity types</li> <li>                     C++20's Non-type template parameters (NTTPs) enable composable type names </li> </ul> <ul> <li>                     Can compose units, prefixes, dimensions, and quantity (point) makers                 </li> <li>                     Type names clunky to compose: must write <code>decltype</code> or use traits                 </li> </ul> Unit-aware I/O <p>                     The ability to print quantities along with information about their units.                     Examples:                 </p> <ul> <li><code>&lt;iostream&gt;</code>, preferrably toggleable</li> <li>Unit labels available even without <code>&lt;iostream&gt;</code></li> <li><code>fmtlb</code> (<code>std::format</code> after C++20)</li> </ul> <ul> <li>Toggleable <code>&lt;iostream&gt;</code> support</li> <li>                     Impressively configurable output (<code>format_mode</code>,                     <code>autoprefix_mode</code>)                 </li> <li>No fmtlib support</li> </ul> <ul> <li>Toggleable <code>&lt;iostream&gt;</code> support</li> <li>No fmtlib support</li> </ul> <ul> <li>Toggleable <code>&lt;iostream&gt;</code> support</li> <li>Unit labels available even without <code>&lt;iostream&gt;</code></li> <li>No fmtlib support</li> </ul> <ul> <li>Supports <code>&lt;iostream&gt;</code></li> <li>Unit labels available even without <code>&lt;iostream&gt;</code></li> <li>Supports <code>std::format</code></li> </ul> <ul> <li>Toggleable <code>&lt;iostream&gt;</code> support</li> <li>Unit labels available even without <code>&lt;iostream&gt;</code></li> <li>                     Plan to add fmtlib support; see #149 </li> </ul> Mixed-Rep Support <p>The ease of freely mixing different storage types (\"Reps\") in the same program.</p> Possible, but user-facing types use a global \"preferred\" Rep. Unit-aware math <p>                     Unit-aware versions of common mathematical functions (`max`, `abs`, `sin`,                     `round`, and so on).                 </p> <ul> <li>Wide variety of functions</li> <li> <code>round</code>, <code>ceil</code>, and so on are not unit-safe                 </li> </ul> <ul> <li>Wide variety of functions</li> <li> <code>round</code>, <code>ceil</code>, and so on are not unit-safe                 </li> </ul> No <ul> <li>Wide variety of functions</li> <li>                     Unit-safe APIs for <code>round</code>, <code>ceil</code>, and so on                 </li> <li>                     Smart, unit-aware inverse functions                 </li> </ul> <ul> <li>Wide variety of functions</li> <li>                     Unit-safe APIs for <code>round</code>, <code>ceil</code>, and so on                 </li> <li>                     Smart, unit-aware inverse functions                 </li> </ul> Generic Dimensions <p>                     The ability to write (template) functions that operate on any dimensionally                     consistent inputs.                 </p> <p>                     (For example, a function that takes any length and time quantities, and returns                     the appropriate speed quantity.)                 </p> Generic             templates, constrained with traits Generic             templates, constrained with traits Generic templates, constrained with traits Concepts excel here              Currently clunky.  Could be better by adding concepts in extra             C++20-only file, without compromising C++14 support.          Extensibility <p>How easy it is to add new units, dimensions, or systems.</p> Can             add new units and dimensions <ul> <li>One-line macro defines new units</li> <li>Can't add dimensions</li> </ul> Can add new units and dimensions Can even handle, e.g., systems of \"natural\" units              Can add new units             and dimensions          Ease of Migration <p>                     Support for two migration use cases:                 </p> <ul> <li>From \"no units\" to this library</li> <li>Between this library and another units library (either direction)</li> </ul> No interop with other units libraries No interop with other units libraries No interop with other units libraries <ul> <li> <code>QuantityLike&lt;T&gt;</code> supports bidirectional conversions                      </li> <li>                     Can specify implicit or explicit                 </li> </ul> <ul> <li> <code>CorrespondingQuantity</code> supports bidirectional implicit conversions                      </li> <li>                     Supports \"two-hop\"                     conversions </li> </ul> Point Types <p>                     Support for \"point-like\" quantities, also known as                     \"affine space                     types\".                 </p> <code>absolute</code>             wrapper for unit                       Optional \"offset\" for units, but can't distinguish quantity from             point.          None; would be hard to add, since units conflated with quantity type              Custom origins really easy to use and compose          Magnitudes <p>                     The features of the representation for different units' sizes.  Key features                     include:                 </p> <ul> <li>Irrational numbers (such as \\(\\pi\\))</li> <li>Powers (robust against overflow)</li> <li>Roots (exact representations)</li> </ul>              Close: lacks only irrationals, basis, and instance arithmetic.  Ahead of its time!                       Uses ratio plus \"pi powers\": good angle handling, but vulnerable to overflow          `std::ratio` only, with no solution for pi              Full support for Magnitudes              Formerly, Au alone was best, but we shared Magnitudes with mp-units          Embedded Friendliness <p>                     Support common embedded use cases.  Key examples include:                 </p> <ul> <li>                         Flexibility in the Rep (usually a variety of integral types, and perhaps                         <code>float</code>, but rarely <code>double</code>).                     </li> <li>The easy ability to exclude <code>&lt;iostream&gt;</code>.</li> </ul> Assumed to be good, based on mixed-Rep support              Can trim by excluding <code>&lt;iostream&gt;</code>, but integer-Rep support is poor.          <ul> <li><code>&lt;iostream&gt;</code> not automatically included</li> <li>Supports integral rep</li> <li>Integral rep conversions unsafe</li> </ul> Assumed to be good, based on mixed-Rep support              Best choice of all:             <ul> <li>No \"preferred\" Rep.</li> <li><code>sizeof()</code>-friendly unit label representation</li> <li>Safe integer operations.</li> </ul> Abbreviated construction <p>                     The ability to construct a Quantity using the symbol for its unit.                 </p> <p>                     This is most commonly done with user-defined literals (UDLs), such as                     <code>3_m</code> for \"3 meters\", but there are other alternatives.                 </p> User-defined literals (UDLs) User-defined literals (UDLs)              Unit symbols                           Unit symbols              Linear algebra <p>                     Good interoperability with matrix and vector libraries, such as Eigen                 </p> <p>                     Most libraries can work with Eigen, but only if Eigen is patched: Quantity types                     break several of Eigen's deeply embedded assumptions.                 </p>              Experimental support for Quantity             Character; can use matrix types as Rep                       Planned to add: #70 Rep Variety <p>The range of different storage types (\"Reps\") permitted.</p> <ul> <li>Poor: only 1 or 2 types</li> <li>Fair: all built-in numeric types</li> <li>Good: also support custom numeric types</li> </ul> Supports custom numeric types              Effectively floating-point only (integer types unsafe)          <ul> <li>No \"default\" rep</li> <li>                     Integer reps unsafe </li> </ul>              Well defined             Representation             concept <ul> <li>Mature support for <code>is_arithmetic</code> Rep</li> <li>Experimental support for custom Rep</li> <li>No constraints yet (#52)</li> </ul> Zero <p>                     Quantity support for constructing from, and comparing with, <code>0</code>: the                     only number which is meaningful for every unit.  (Includes facilities for                     working with quantity signs.)                 </p>              Guidance:             use             default constructor to construct, but no special facility for comparison          Supports <code>copysign()</code>, but no special construction or comparison No special construction or comparison <li> Special comparison functions </li> <li><code>zero()</code> member</li>              Can use <code>ZERO</code>             to construct or compare any quantity          Angles <p>                     First-class support for angular quantities, including degrees and radians.                 </p>              Curiously imprecise             pi             value  <ul> <li>Supports degrees and radians</li> <li>pi represented as <code>std::ratio</code></li> </ul> Simultaneous support for both strongly-typed and \"pure SI\" angles Physical constants <ul> <li>How good is the core library support?</li> <li>Does the library include built-in constants?</li> </ul> Includes built-in constants as quantities Includes built-in constants as quantities \"Faster             than lightspeed\" constants <ul> <li>Constants as types</li> <li>Perfect conversion policy</li> <li>Implicit Quantity conversion</li> <li>                     No built-in values yet (see #90)                 </li> </ul> Non-linear scales (such as dB) <p>Support for logarithmic \"units\", such as decibels or nepers</p>              Plan to support someday; see             #41.          \"Kind\" Types <p>                     Any feature which supports robustly distinguishing between units that have the                     same dimension and magnitude.                 </p> <p>                     For example, \"hertz\" and \"becquerel\" both have the same dimension and magnitude                     as \"inverse seconds\", but some libraries may prevent users from mixing them.                 </p> No plans at present to support. Explicit Systems of Measurement <p>                     Support for different systems, each with their own (possibly incompatible)                     collection of dimensions.                 </p> Single, implicit global system              Single, implicit global system. (Intentional design tradeoff: reduces learning curve,             and makes compiler errors shorter.)          Abstract Units/Dimensions <p> <li>                         Types that represent abstract units (clearly distinct from quantities of                         that unit).                     </li> <li>Types that represent abstract dimensions.</li> <li>The ability to do arithmetic with instances of these types.</li> </p> Types exist, but conflated with quantity names No separate types for units <ul> <li>Types for units</li> <li>Types for dimensions</li> <li>                     Can do arithmetic (compound units on the fly; abstract dimensional analysis)                 </li> </ul> <ul> <li>Types for units</li> <li>Types for dimensions</li> <li>                     Can do arithmetic (compound units on the fly; abstract dimensional analysis)                 </li> </ul> Macro Usage <p>                     Avoidance of macros, especially in user-facing code.                 </p> Common in user-facing APIs Common in user-facing APIs Very few, and confined to implementation helpers <ul> <li>Very few, mostly implementation helpers</li> <li>Only one user-facing macro for C++20 backwards compatibility</li> </ul> No macros <ol> <li> <p>Users may have expected a \u201ctraffic light\u201d style, green/yellow/red color scheme.  However, these traditional color schemes have poor accessibility for colorblind readers.  The present color scheme was designed to be colorblind-friendly.\u00a0\u21a9</p> </li> </ol>"},{"location":"discussion/","title":"Discussion Docs","text":"<p>This section is for docs that illuminate Au\u2019s underpinnings.  The kinds of docs that go here include philosophy and principles, deep dives on design choices, explanations of core concepts, and more.</p> <p>In terms of the four categories of documentation \u2014 which we try to follow \u2014 this is also known as \u201cexplanation\u201d.  It\u2019s most useful when you\u2019re studying, rather than working, and it focuses on theoretical rather than practical knowledge.</p> <p>Here\u2019s a guide to the main categories.</p> <ul> <li> <p>Au Idioms.  Usage patterns that are more specific to Au, and can help you   get the most out of it.</p> </li> <li> <p>Generic concepts.  Ideas that can enhance your effectiveness in working   with any units library, or with quantities generally.</p> </li> <li> <p>Implementation details.  Concepts and design discussions that   help you understand how we made Au.  These are less likely to directly make you a more effective   user, but they may be of interest for the curious.</p> </li> </ul>"},{"location":"discussion/concepts/","title":"Generic Concepts","text":"<p>This section discusses concepts about units libraries generally. Some may be more precise formulations of principles that most users know intuitively, such as Arithmetic Operations.  Others may be novel innovations which originated with Au, but would enhance any units library, such as Zero.  From A to Z, all will sharpen your thinking and help you use units libraries more effectively.</p> <ul> <li> <p>Arithmetic Operations.  Find out about the two kinds of math you can do   with quantities, and learn a simple rule for reasoning about the results of products and   quotients.</p> </li> <li> <p>Common Units.  To compare, add, or subtract quantities expressed in   different units, the first step is to convert them to the same unit.  But which one?  This page   teaches you what choice we make, and what advantages it has.</p> </li> <li> <p>Dimensionless Units and Quantities.  \u201cDimensionless\u201d isn\u2019t the same   thing as \u201cunitless\u201d; we support dimensionless units, like <code>Percent</code>.  Here we explain how the   library handles these situations, and avoids common pitfalls.</p> </li> <li> <p>Overflow.  Unit conversions risk overflow.  The degree of risk depends on   both the conversion factor, and the range of values that fit in the destination type.  Learn how   different units libraries have approached this problem, including Au\u2019s novel contribution, the   \u201coverflow safety surface\u201d.</p> </li> <li> <p>Quantity Point.  An abstraction for \u201cpoint types\u201d that have units.   Most use cases don\u2019t need this, but for a few \u2014 including temperatures \u2014 it\u2019s indispensable.</p> </li> <li> <p>Zero.  Switching to a units library can make some easy computations hard.  Learn   how we make them easy again with a special constant, <code>ZERO</code>, that works with quantities of any   units.</p> </li> </ul>"},{"location":"discussion/concepts/arithmetic/","title":"Arithmetic Operations","text":"<p>Quantity arithmetic operations fall into two categories.</p> <ul> <li> <p>Arbitrary-unit operations work with any units \u2014 even if there are multiple input units with   different dimensions!  Examples include products, quotients, powers, and roots.</p> </li> <li> <p>Common-unit operations require the inputs to be expressed in the same unit.<sup>1</sup>  Examples include   addition, subtraction, and relational operators.</p> </li> </ul> <p>We\u2019ll explain how the library handles each category below.  First, a brief refresher.</p>"},{"location":"discussion/concepts/arithmetic/#quantities-values-and-units-101","title":"Quantities, values, and units 101","text":"<p>A quantity is an abstract concept: some physical property that can be measured.  To work with that quantity, we need to pick a unit of measure, or \u201cunit\u201d.  Once we\u2019ve done so, the quantity obtains a value with respect to that unit.</p> <p>Different choices of unit will lead to different values for the same quantity.  For example, suppose we have a rod that is one foot long.  The distance between its endpoints is <code>feet(1.0)</code>, where <code>feet</code> is the unit, and <code>1.0</code> is the value.  It\u2019s also equal to <code>inches(12.0)</code>, where <code>inches</code> is another unit we could have chosen, and <code>12.0</code> is the value we\u2019d obtain if we did.</p> <p>Note that <code>feet(1.0)</code> and <code>inches(12.0)</code> are the same quantity, conceptually!  But when we pick different units, we\u2019ll end up storing different values (i.e., <code>1.0</code> vs. <code>12.0</code>) in the bits and bytes of our computer program.</p>"},{"location":"discussion/concepts/arithmetic/#arbitrary-unit","title":"Arbitrary-unit operations","text":"<p>For arbitrary-unit operations (products, quotients, powers, and roots), there is a simple, golden rule: apply the operation (say, multiplication) independently to both the value and the unit. Consider this example:</p> (150 \\,\\,\\text{mi}) \\div (2 \\,\\,\\text{h}) = (75 \\,\\,\\text{mi} / \\text{h}) <p>Notice how the operation applies independently to the value and the unit:</p> <ul> <li>values: 150 \\div 2 = 75</li> <li>units: \\text{mi} \\div \\text{h} = \\text{mi} / \\text{h}</li> </ul> <p>Au works the same way.  Here\u2019s how that computation would look in our library:</p> <pre><code>miles(150.0) / hours(2.0) == (miles / hour)(75.0)\n</code></pre> <p>Here, <code>(miles / hour)</code> creates a new, compound unit on the fly, and calling it on <code>75.0</code> stores that value to create a quantity.</p>"},{"location":"discussion/concepts/arithmetic/#mixed-units-and-conversions","title":"Mixed Units and Conversions","text":"<p>Au makes it easy to do complicated, multi-step operations.  For example:</p> <p>How many \u201cg\u2019s\u201d of acceleration will a car experience, going from 0 to 60 MPH in 3 seconds?</p> <p>Assuming constant acceleration, we have:</p> <pre><code>QuantityD&lt;StandardGravity&gt; accel = (miles / hour)(60.0) / seconds(3.0);\n</code></pre> <p>It\u2019s worth breaking down the operations the library performs, and the order in which it performs them.  In particular, remember that division happens first, before the assignment.</p> <p>For the division, we know we can reason independently about the value; so, the value is <code>20.0</code>. Similarly, the unit is <code>miles / hour / second</code>.  Altogether, the division step yields 20 \\,\\,\\text{MPH} / \\text{s}.</p> <p>Next comes assignment.  Since standard gravity (g_0) and \\text{MPH}/\\text{s} both have the same dimension (namely, acceleration), then \\frac{g_0}{\\text{MPH}/\\text{s}} is some real number: namely, \\frac{980665}{44704}.  The library computes this number at compile time, and performs only a single multiplication or division at runtime.  The final printed result is roughly <code>0.911708 g_0</code>.</p> <p>And this makes sense!  We know intuitively that going from 0 to 60 MPH in 3 seconds \u201cfeels very fast\u201d.  We can see that in fact, it\u2019s pulling almost a full \u201cg\u201d.</p>"},{"location":"discussion/concepts/arithmetic/#common-unit","title":"Common unit operations","text":"<p>If two quantities have the same dimension, it\u2019s physically meaningful to add, subtract, or compare them.  Consider two lengths: we can physically add them by placing them in series and measuring the total distance, even if we had measured one in \u201cfeet\u201d, and the other in \u201cinches\u201d.</p> <p>Computationally, it\u2019s a different story: we need to express them in a common unit.  Once we do, it\u2019s easy to add/subtract/compare the quantities: we simply add/subtract/compare the values.</p> <p>The \u201ccommon unit\u201d of two units is the largest unit that evenly divides both<sup>2</sup>\u2014essentially, the greatest common divisor.  This convention has two benefits:</p> <ol> <li> <p>Converting each input quantity to the common unit involves multiplying the value by an integer.    This is really important for quantities with integral storage types!</p> </li> <li> <p>The value of that multiplier will be as small as possible (relative to other units that    evenly divide both input units).  This minimizes the risk of integer overflow.</p> </li> </ol> <p>Let\u2019s look at a few examples.</p> <ul> <li> <p><code>feet(1) + inches(6)</code>: This converts each input to their common unit, which is <code>inches</code>, resulting   in <code>inches(18)</code>.</p> </li> <li> <p><code>inches(100) &gt; centi(meters)(200)</code>: The common unit doesn\u2019t have a name, so let\u2019s call it   \\text{com}.  An inch is 127 \\,\\text{com}, and a centimeter is 50 \\,\\text{com}.  After   implicitly converting each argument, the input reduces to <code>coms(12700) &gt; coms(10000)</code>, which   clearly evaluates to <code>true</code>.</p> </li> </ul> <p>Check your understanding: what would we get if we added these last values instead of comparing them?</p> QuestionAnswer and discussion <pre><code>inches(100) + centi(meters)(200) // -&gt; ...?\n</code></pre> <pre><code>inches(100) + centi(meters)(200) // -&gt; coms(22700), using above notation\n</code></pre> <p>We know that addition is a \u201ccommon unit operation\u201d, which means we have to convert both inputs to the common unit before performing it.  As above, let\u2019s temporarily assume we\u2019ve given a name, <code>coms</code>, to this anonymous unit.  We already saw that these inputs convert to <code>coms(12700)</code> and <code>coms(10000)</code>, respectively, so all we have to do is add them together to get <code>coms(22700)</code>.</p> <p>Of course, in real code, this unit wouldn\u2019t have a name.  We\u2019d just have some <code>Quantity</code> of an anonymous length unit with this magnitude, storing the value <code>22700</code>.  So: what can we do with this result?  Well, we can\u2019t assign it to an integer Quantity of <code>inches</code> or <code>centi(meters)</code>, because it\u2019s not an integer in either of those units.  However, we can\u2026</p> <ul> <li>\u2026compare it to an integer Quantity of <code>inches</code> or <code>centi(meters)</code></li> <li>\u2026assign it to a floating point Quantity of <code>inches</code> or <code>centi(meters)</code></li> <li>\u2026assign it to an integer Quantity of some smaller divisor unit, such as     <code>micro(meters)</code></li> </ul> <p>So, for example, this would work:</p> <pre><code>QuantityI32&lt;Micro&lt;Meters&gt;&gt; x = inches(100) + centi(meters)(200)\n</code></pre> <p>The value of <code>x</code> would be <code>micro(meters)(4'540'000)</code>.</p> <ol> <li> <p>Note that this is only possible in the first place if the units have the same dimension.\u00a0\u21a9</p> </li> <li> <p>Of course, this definition only applies to units which have a common divisor.  This happens whenever their ratio (a dimensionless number) is an exact rational number.  This won\u2019t work for unit pairs such as <code>degrees</code> and <code>radians</code>, whose ratio is the irrational number (\\pi / 180).  For \u201cirrational ratios\u201d, no convention can provide the benefits in this section, so we make an arbitrary choice based on convenience of implementation.  For more details, see the common unit docs.\u00a0\u21a9</p> </li> </ol>"},{"location":"discussion/concepts/common_unit/","title":"Common Units","text":"<p>Some operations (multiplication, division, powers) work natively with arbitrary units.  Others (addition, subtraction, comparison) require converting to a \u201ccommon\u201d unit.  This page explains the concept, the requirements, and how we implement it.</p>"},{"location":"discussion/concepts/common_unit/#concepts","title":"Concepts","text":"<p>In this section, we\u2019ll use square bracket notation, [x], to refer to a unit.  Units can be multiplied by magnitudes (i.e., positive real numbers) to form new units: so, [12x] is a unit which is 12 times the size of the unit [x].</p> <p>A quantity is some property which can be measured.  A measurement result has two parts: the unit of measure, and the value of the quantity, which is the ratio of the quantity to that unit.  For example: suppose we had some physical length, and we found that if we placed four yardsticks end-to-end, they would exactly coincide with this length.  Then the measured quantity would be 4 [\\text{yd}]: 4 is the value, and [\\text{yd}] is the unit.</p> <p>We should be careful not to say that the quantity \u201cis\u201d the unit/value pair!  We can convert a quantity to any other unit of the same dimension by \u201ctrading off\u201d numeric factors between the value and the unit.  For example, using the fact that a yard is three feet, we can convert the above quantity to this new unit like so:</p>  \\begin{align} 4 [\\text{yd}] &amp;= 4 \\left[ \\text{yd} \\left(\\frac{3\\, \\text{ft}}{\\text{yd}}\\right) \\right] \\\\ &amp;= 4 [3\\, \\text{ft}] \\\\ &amp;= (4 \\cdot 3) [\\text{ft}] \\\\ &amp;= 12 [\\text{ft}] \\end{align}  <p>Notice that in going from line 2 to 3, we pulled the factor of 3 out of the unit, and applied it to the value.  This changes the unit, and the value, but the overall quantity is unchanged.  This is the key point: one quantity; many representations.</p>"},{"location":"discussion/concepts/common_unit/#the-need-for-common-units","title":"The need for common units","text":"<p>Physically, we can compare any two quantities of the same dimension.  It doesn\u2019t matter if one is measured in feet, and the other in yards; we can place the physical lengths next to each other, and see which one is longer.  Computationally, we need to express them in the same unit, so that our notion of <code>&lt;</code> for quantities can simply \u201cinherit\u201d from our notion of <code>&lt;</code> for their values.</p> <p>Tip</p> <p>This is exactly analogous to the need for common denominators when working with fractions. Each fraction can be expressed in many different denominators, and all of those representations represent the same number, the same element of the set \\mathbb{Q}.</p> <p>However, before we can add, subtract, or compare different fractions, we need to express them in the same, common denominator (analogous to units).  Once we do, we can simply apply these operations directly to the numerators (analogous to values).</p> <p>In principle, any unit of the same dimension can serve as the \u201ccommon unit\u201d.  However, just as we tend to prefer the lowest common denominator for fractions, there is also a preferred common unit for quantities.  The usual choice is the largest (i.e., greatest magnitude) unit which evenly divides both input units.  This has some very nice properties.</p> <ul> <li> <p>Since it evenly divides both units, each conversion will end up simply multiplying by an   integer (as in our example above).  This lets us stay in the integer domain if we started out   there.</p> </li> <li> <p>Since it\u2019s the largest such unit, we\u2019ll be multiplying by the smallest integers that still get   the job done.  Not only are smaller numbers easier to work with, but when we move to the   programming domain, they also reduce the risk of overflow.</p> </li> </ul> <p>Now, this isn\u2019t always possible: for example, no unit evenly divides both degrees and radians!  In those cases, our choice matters less, and it can be driven by convenience.</p>"},{"location":"discussion/concepts/common_unit/#c-considerations-quantity","title":"C++ considerations (<code>Quantity</code>)","text":"<p>Note</p> <p>This section only applies to <code>Quantity</code> types.  We follow a similar strategy for <code>QuantityPoint</code>, but with a few differences we\u2019ll explain at the end.</p> <p>The \u201ccommon unit\u201d is the unit of the common type of two or more <code>Quantity</code> instances, in the sense of <code>std::common_type</code>.  What properties should it have?</p>"},{"location":"discussion/concepts/common_unit/#requirements","title":"Requirements","text":"<ol> <li> <p>Symmetry.  The common unit of any collection of input units must be independent of their    ordering.</p> <ul> <li> <p>This flows directly from the requirements for specializing <code>std::common_type</code>, which   state:</p> <p>Additionally, <code>std::common_type&lt;T1, T2&gt;::type</code> and <code>std::common_type&lt;T2, T1&gt;::type</code> must denote the same type.</p> </li> </ul> </li> <li> <p>Deduplication.  Any given input unit can appear at most once in the resulting unit type.</p> <ul> <li>This is to keep compiler errors as concise and readable as possible.</li> </ul> </li> <li>Flattening.  If an input unit is a <code>CommonUnit&lt;...&gt;</code> type, \u201cunpack\u201d it and replace it with    its constituent Units.<ul> <li>To see why, let <code>c(...)</code> be \u201cthe common unit\u201d, and <code>x</code>, <code>y</code>, and <code>z</code> be units.  We wouldn\u2019t   want <code>c(x, c(y, z))</code> to be different from <code>c(x, y, z)</code>!</li> </ul> </li> <li>Semantic.  Prefer user-meaningful units, because they show up in compiler errors. Thus, if    any input unit is equivalent to the \u201ccommon unit\u201d, we\u2019ll prefer that input unit.<ul> <li>The common unit of <code>Inches</code> and <code>Feet</code> is just <code>Inches</code>, not <code>CommonUnit&lt;Inches, Feet&gt;</code>!</li> </ul> </li> </ol>"},{"location":"discussion/concepts/common_unit/#user-facing-types","title":"User-facing types","text":"<p>There are two main abstractions for common units which users might encounter.</p> <ul> <li><code>CommonUnit&lt;...&gt;</code>.  This is a template that defines new units from old ones, just like   <code>UnitProduct&lt;...&gt;</code> or <code>ScaledUnit&lt;...&gt;</code>.<ul> <li>This should rarely, if ever be named in code.<ul> <li>In implementations, we need to do this, for example, for defining the unit label of   a <code>CommonUnit&lt;...&gt;</code>, or defining its ordering relative to other units.</li> <li>In end user code, this should probably never be named.</li> <li>In either case: never write <code>CommonUnit&lt;...&gt;</code> with specific template arguments!   Only use it for matching.</li> </ul> </li> <li>Remember: <code>CommonUnit&lt;...&gt;</code> can arise only as the result of some type computation.</li> </ul> </li> <li><code>CommonUnitT&lt;...&gt;</code>.  This computes the common unit of the provided units.</li> </ul> <p>Let\u2019s clarify this relationship with an example.  Suppose you\u2019re writing a function based on two arbitrary (but same-dimension) units, <code>U1</code> and <code>U2</code>, and you need their \u201ccommon unit\u201d.</p> <ul> <li>What you would write is <code>CommonUnitT&lt;U1, U2&gt;</code>, not <code>CommonUnit&lt;U1, U2&gt;</code>.<ul> <li><code>CommonUnitT&lt;...&gt;</code> says \u201cplease calculate the common unit\u201d.</li> <li><code>CommonUnit&lt;...&gt;</code> says \u201cthis is the result of calculating the common unit\u201d.</li> </ul> </li> <li>What you get depends on the specific units.<ul> <li>For <code>CommonUnitT&lt;Inches, Meters&gt;</code>, the result might be <code>CommonUnit&lt;Inches, Meters&gt;</code>.<sup>1</sup>  This   is because the greatest common divisor for <code>Inches</code> and <code>Meters</code> is smaller than both of them.</li> <li>For <code>CommonUnitT&lt;Inches, Feet&gt;</code>, the result would simply be <code>Inches</code>, because <code>Inches</code> is   quantity-equivalent to this common unit (it evenly divides both <code>Inches</code> and <code>Feet</code>).</li> </ul> </li> </ul> Implementation approach details (deep in the weeds) <p>There are two main tools we use to implement <code>CommonUnitT</code>.</p> <ol> <li> <p><code>FlatDedupedTypeList</code>.  For a given variadic pack <code>List&lt;...&gt;</code> (which, for us, will be    <code>CommonUnit&lt;...&gt;</code>), <code>FlatDedupedTypeList&lt;List, Ts...&gt;</code> will produce a <code>List&lt;...&gt;</code>, whose    elements are <code>Ts...</code>, but sorted according to <code>InOrderFor&lt;List, ...&gt;</code>, and with duplicates    removed.</p> <ul> <li>If any of the <code>Ts</code> are already <code>List&lt;Us...&gt;</code>, we effectively \u201cunpack\u201d it, replacing it with   <code>Us...</code>.  This is the \u201cflat\u201d part in <code>FlatDedupedTypeList</code>.</li> </ul> </li> <li> <p><code>FirstQuantityEquivalentUnit</code>.  The above step produces a <code>CommonUnit&lt;...&gt;</code> specialization, which    itself meets the definition of a unit.  But is it the unit we    really want to provide?  Not if there\u2019s a simpler one!    <code>FirstQuantityEquivalentUnit&lt;CommonUnit&lt;Us...&gt;&gt;</code> searches through the unit list <code>Us...</code>, and    returns the first quantity-equivalent one it finds. If no such unit is available, then we    fall back to returning <code>CommonUnit&lt;Us...&gt;</code>.</p> </li> </ol>"},{"location":"discussion/concepts/common_unit/#common-quantity-point","title":"Changes for <code>QuantityPoint</code>","text":"<p>The common unit for <code>QuantityPoint</code> operations is different from the common unit for <code>Quantity</code>.  To see why a single notion of \u201ccommon unit\u201d isn\u2019t enough, consider <code>Celsius</code> and <code>Kelvins</code>.</p> <ul> <li> <p>For a <code>Quantity</code>, these two units are identical.  The \u201ccommon unit\u201d will be   (quantity-)equivalent to both of them.</p> </li> <li> <p>For a <code>QuantityPoint</code>, these units are very different.  A \u201ctemperature point\u201d of 0 degrees   <code>Celsius</code> is (point-)equivalent to a temperature point of 273.15 <code>Kelvins</code>.  This additive offset   means that we\u2019ll need to convert both to <code>Centi&lt;Kelvins&gt;</code> before we can subtract and/or compare   them!</p> </li> </ul> <p>Thus, what we\u2019ve been calling <code>CommonUnitT</code> is really more like <code>CommonQuantityUnitT</code> (although we\u2019ve kept the name short because <code>Quantity</code> is by far the typical use case).  For <code>QuantityPoint</code> operations, we have the <code>CommonPointUnitT&lt;Us...&gt;</code> alias, which typically creates some instance of <code>CommonPointUnit&lt;Us...&gt;</code> with the <code>Us...</code> in their canonical ordering.</p> <p>So: what is the \u201ccommon quantity point unit\u201d?  Well, we can start with the \u201ccommon quantity unit,\u201d but the origin adds a new complication.  We\u2019ll need to choose a convention.</p> <ul> <li> <p>With \u201ccommon quantity units,\u201d our convention ensured that conversions could only multiply by   a positive integer.  This keeps us within the domain of the integers whenever we start there.   And we chose the smallest such number to minimize overflow risk.</p> </li> <li> <p>Similarly, with \u201ccommon quantity point units,\u201d we should choose its origin such that we only   add a non-negative integer.  This convention preserves and extends the previous one: not   only are we keeping integers as integers, but we support unsigned integers as best we can.</p> </li> </ul> <ol> <li> <p>It might also be <code>CommonUnit&lt;Meters, Inches&gt;</code>.  The ordering is deterministic, but unspecified.\u00a0\u21a9</p> </li> </ol>"},{"location":"discussion/concepts/dimensionless/","title":"Dimensionless Units and Quantities","text":"<p>Every dimension has a variety of units available to measure its quantities.  This is no less true for the \u201cnull\u201d dimension!  Example units include \u201cdozen\u201d, \u201cscore\u201d, \u201cpercent\u201d, and others.  We call these units (and their quantities) \u201cdimensionless\u201d.</p> <p>One big difference (compared to units of other dimensions) is that the magnitudes of dimensionless units are objectively meaningful.  Recall that for, say, length-dimensioned units, there is no such thing as \u201cthe\u201d magnitude of <code>Feet</code>.  We can choose any number we like, as long as it\u2019s 12 times the magnitude of <code>Inches</code>.  By contrast, <code>Percent</code> has a definite magnitude: it\u2019s 1/100.</p>"},{"location":"discussion/concepts/dimensionless/#unos-the-unit-1","title":"<code>Unos</code>: the \u201cunit 1\u201d","text":"<p>Dimensionless units are special, but one is more special still.  Literally, one \u2014 the dimensionless unit whose magnitude is 1.  It is the only unit equal to its own square, and the only unit whose quantities are completely and unambiguously interchangeable with raw numbers.</p> <p>In our library, we named this unit \u201cunos\u201d, after an SI proposal from the 1990s.  Although the proposal failed, the concept turns out to suit software libraries much better than scientific prose. It is short, greppable, and reasonably intuitive.  It also lets us enter and exit the library boundaries in just the same way as for other units: <code>q = unos(x)</code> turns a numeric value <code>x</code> into a Quantity <code>q</code>, and <code>q.in(unos)</code> retrieves the raw number.</p> <p>This is particularly useful when working with non-<code>unos</code> dimensionless units.  For example: say we wanted to \u201cexpress <code>0.75</code> as a quantity of <code>percent</code>\u201d. Instead of trying to remember whether to multiply or divide by 100, we can simply write <code>x = unos(0.75).as(percent)</code>.  And if we have something that\u2019s already a <code>percent</code>, but we want its \u201ctrue\u201d value, we can simply write <code>x.in(unos)</code>.</p>"},{"location":"discussion/concepts/dimensionless/#exact-cancellation","title":"Exact cancellation and types","text":"<p>Sometimes a computation exactly cancels all units (like the ratio of two lengths, each measured in <code>Feet</code>).  As a units library, we have two options: return a Quantity of <code>Unos</code>, or a raw number. Presently, we opt for the latter; here is why.</p> <p>Users generally tend to expect the result of a perfectly unit-cancelling expression to behave exactly like a raw number, in every respect.  Although a <code>Quantity&lt;Unos, T&gt;</code> implicitly converts to <code>T</code>, this conversion turns out to get triggered in only a subset of use cases; many edge cases remain.  The only way to perfectly mimic a raw number is to return one.</p> <p>The downside is that this incurs some complexity.  This mainly impacts generic code, where we can\u2019t know whether a product or quotient of Quantities is a Quantity, or a raw number.  People writing generic code are generally more advanced users, and thus better able to work around this inconsistency.  For example, one could write an <code>ensure_quantity(T x)</code> function template, which returns <code>unos(x)</code> in the generic case, but has an overload for when <code>T</code> matches <code>Quantity&lt;U, R&gt;</code> that simply returns <code>x</code>.</p> <p>We may someday be able to improve the ergonomics of <code>Quantity&lt;Unos, T&gt;</code> to the point that we\u2019d feel comfortable returning it, thus making the library more consistent.  However, returning a raw number feels like the right compromise solution for us to start with.</p> <p>Note</p> <p>For results that are dimensionless but not \u201cunitless\u201d, we always return a Quantity.</p> <p>For example, <code>milli(seconds)(50) * hertz(10)</code> produces a numeric value of <code>50 * 10 -&gt; 500</code>, in a dimensionless unit whose magnitude is 1 / 1000.  This is equivalent to a raw numeric value of 1 / 2 \u2014 but it\u2019s not the library\u2019s place to decide how or when to perform the lossy conversion of this integral Quantity.  Rather, the library\u2019s job is to safely hold the obtained numeric value of <code>500</code>.  The Magnitude attached to the Quantity is what lets us do so.</p>"},{"location":"discussion/concepts/dimensionless/#implicit-conversions","title":"Other dimensionless units and implicit conversions","text":"<p>A common choice among units libraries is to support implicit conversions with dimensionless units. This is intuitively appealing: after all, a Quantity like <code>percent(75.0)</code> represents the value <code>0.75</code>.  Shouldn\u2019t we handle that conversion automatically, just as happily as we turn <code>feet(3)</code> into <code>inches(36)</code>?</p> <p>While the appeal is obvious, we believe this does more harm than good.  The reason is that a Quantity has two different notions of value, and for dimensionless units specifically, these become ambiguous.  Consider something like <code>inches(24)</code>.  By \u201cvalue\u201d, we might mean:</p> <ul> <li>the numeric variable <code>24</code>, stored safely within the Quantity object, as if in a container.</li> <li>the quantity value itself \u2014 in this case, the extent of the physical length, which is identical   with <code>feet(2)</code>.</li> </ul> <p>With dimensioned quantities, the library prevents confusion: we can\u2019t use either in contexts where the other belongs.  But dimensionless quantities lack this safeguard.  This opens the door to decisions which are individually reasonable, but which interact badly together.  For instance, a <code>Quantity&lt;Percent, T&gt;</code> may be implicitly constructible and convertible with <code>T</code>, but could pick up stray factors of 100 in the round trip!</p> <p>It is safer (and not much less convenient!) to use separate, unambiguous idioms for these two notions of \u201cvalue\u201d.</p>"},{"location":"discussion/concepts/overflow/","title":"Overflow","text":"<p>To convert a quantity in a program to different units, we need to multiply or divide by a conversion factor.  Sometimes, the result is too big to fit in the type: a problem known as overflow.</p> <p>Units libraries generate these conversion factors automatically when the program is built, and apply them invisibly.  This amazing convenience comes with a risk: since users don\u2019t see the conversion factors, it\u2019s easy to overlook the multiplication that\u2019s taking place under the hood.  This is even more true in certain \u201chidden\u201d conversions, where most users don\u2019t even realize that a conversion is taking place!</p>"},{"location":"discussion/concepts/overflow/#hidden-overflow-risks","title":"Hidden overflow risks","text":"<p>Consider this comparison:</p> <pre><code>constexpr bool result = (meters(11) &gt; yards(12));\n</code></pre> <p>Even though the quantities have different units, this code compiles and produces a correct result. It turns out that <code>meters(11)</code> is roughly 0.2% larger than <code>yards(12)</code>, so <code>result</code> is <code>true</code>.  But how exactly do we compute that result from these starting numeric values of <code>11</code> and <code>12</code>?</p> <p>The key is to understand that comparison is a common unit operation.  Before we can carry it out, we must convert both inputs to their common unit \u2014 that is, the largest unit that evenly divides both <code>meters</code> and <code>yards</code>.  In this case, the size of that unit is 800 micrometers, giving a conversion factor of 1250 for <code>meters</code>, and 1143 for <code>yards</code>.  The library multiplies the underlying values 11 and 12 by these respective factors, and then simply compares the results.</p> <p>Now that we have a fuller understanding of what\u2019s going on under the hood, let\u2019s take another look at the code.  When we see something like <code>meters(11) &gt; yards(12)</code>, it\u2019s certainly not obvious at a glance that this will multiply each underlying value by a factor of over 1,000!  Whatever approach we take to mitigating overflow risk, it will need to handle these kinds of \u201chidden\u201d cases as well.</p>"},{"location":"discussion/concepts/overflow/#mitigation-strategies","title":"Mitigation Strategies","text":"<p>Over the decades that people have been writing units libraries, several approaches have emerged for dealing with this category of risk.  That said, there isn\u2019t a consensus about the best approach to take \u2014 in fact, at the time of writing, new strategies are still being developed and tested!</p> <p>It\u2019s also worth noting that this problem mainly applies to integral types.  Floating point types can overflow too, but it happens far less often in practice.  Even the smallest, <code>float</code>, has a range of 10^{38}, while the diameter of the observable universe measured in atomic diameters is \u201conly\u201d about 10^{37}!<sup>1</sup></p> <p>Of course, many domains prefer the simplicity and interpretability of integral types.  This avoids some of the more counterintuitive aspects of floating point arithmetic \u2014 for example, did you know that the difference between consecutive representable <code>double</code> values can be greater than 10^{292}?  With integers, we can bypass all this complexity, but the price we pay is the need to handle overflow.  Here are the main strategies we\u2019ve seen for doing so.</p>"},{"location":"discussion/concepts/overflow/#do-nothing","title":"Do nothing","text":"<p>This is the simplest approach, and probably also the most popular: make the users responsible for avoiding overflow.  The documentation may simply warn them to check their values ahead of time, as in this example from the bernedom/SI library.</p> <p>While this approach is perfectly valid, it does put a lot of responsibility onto the end users, many of whom may not realize that they have incurred it.  Even for those who do, we\u2019ve seen above that many unit conversions are hard to spot.  It\u2019s reasonable to assume that this approach leads to the highest incidence of overflow bugs.</p>"},{"location":"discussion/concepts/overflow/#curate-user-facing-types","title":"Curate user-facing types","text":"<p>The <code>std::chrono</code> library, a time-only units library, takes a different approach.  It uses intimate knowledge of the domain to craft its user-facing types such that they all cover the same (very generous) range of values. Specifically, every <code>std::chrono::duration</code> type shorter than a day \u2014 everything from <code>std::chrono::hours</code>, all the way down to <code>std::chrono::nanoseconds</code> \u2014 is guaranteed to be able to represent at least \u00b1292 years.</p> <p>As long as users\u2019 durations are within this range \u2014 and, as long as they stick to these primary user-facing types \u2014 they can be confident that their values won\u2019t overflow.</p> <p>This approach works very well in practice for the (great many) users who can meet both of these conditions.  However, it doesn\u2019t translate well to a multi-dimensional units library: since there are many dimensions, and new ones can be created on the fly, it\u2019s infeasible to try to define a \u201cpractical range\u201d for all of them.  Besides, users can still form arbitrary <code>std::chrono::duration</code> types, and they may not realize the safety they have given up in doing so.</p>"},{"location":"discussion/concepts/overflow/#adapt-to-risk","title":"Adapt to risk","text":"<p>Fundamentally, there are two contributions to the level of overflow risk:</p> <ol> <li> <p>The size of the conversion factor: bigger factors mean more risk.<sup>2</sup></p> </li> <li> <p>The largest representable value in the destination type: larger max values mean less    risk.</p> </li> </ol> <p>Therefore, we should be able to create an adaptive policy that takes these factors into account. The key concept is the \u201csmallest overflowing value\u201d.  For every combination of \u201cconversion factor\u201d and \u201ctype,\u201d there is some smallest starting-value that will overflow.  The simplest adaptive policy is to forbid conversions when that smallest value is \u201csmall enough to be scary\u201d.</p> <p>How small is \u201cscary\u201d?  Here are some considerations.</p> <ul> <li> <p>Once our values get over 1,000, we can consider switching to a larger SI-prefixed version of the   unit.  (For example, lengths over 1000\\,\\text{m} can be more concisely expressed in   \\text{km}.)  This means that if a value as small as 1,000 would overflow \u2014 so small that we   haven\u2019t even reached the next unit \u2014 we should definitely forbid the conversion.</p> </li> <li> <p>On the other hand, we\u2019ve found it useful to initialize, say, <code>QuantityI32&lt;Hertz&gt;</code> variables with   something like <code>mega(hertz)(500)</code>.  Thus, we\u2019d like this operation to succeed (although it should   probably be near the border of what\u2019s allowed).</p> </li> </ul> <p>Putting it all together, we settled on a value threshold of 2\u2018147.  If we can convert this value without overflow, then we permit the operation; otherwise, we don\u2019t.  We picked this value because it satisfies our above criteria nicely.  It will prevent operations that can\u2019t handle values of 1,000, but it still lets us use \\text{MHz} freely when storing \\text{Hz} quantities in <code>int32_t</code>.</p>"},{"location":"discussion/concepts/overflow/#plot-the-overflow-safety-surface","title":"Plot: the Overflow Safety Surface","text":"<p>This policy lends itself well to visualization.  For each integral type, there is some highest permitted conversion factor under this policy.  We can plot these factors for each of the common integral types (<code>int8_t</code>, <code>uint32_t</code>, and so on).  If we then \u201cconnect the dots\u201d, we get a boundary that separates allowed conversions from forbidden ones, permitting bigger conversions for bigger types. We call this abstract boundary the \u201coverflow safety surface\u201d, and it\u2019s the secret ingredient that lets Au users use a wide variety of integral types with confidence.</p> <p></p>"},{"location":"discussion/concepts/overflow/#check-every-conversion-at-runtime","title":"Check every conversion at runtime","text":"<p>While the overflow safety surface is a leap forward in safety and flexibility, it\u2019s still only a heuristic.  There will always be valid conversions which it forbids, and invalid ones which it permits.  On the latter point, note that adding an intermediate conversion can defeat the safety check: the overflow in <code>meters(10u).as(nano(meters))</code> would be caught, but the overflow in <code>meters(10u).as(milli(meters)).as(nano(meters))</code> would not.</p> <p>One way to guarantee doing better is to check every conversion at runtime.  Some users may recoil at the idea of doing runtime work in a units library, but it\u2019s easy to show that this use case is innocuous. Consider: it\u2019s very hard to imagine a valid use case for needing to perform unit conversions in a \u201chot loop\u201d.  Therefore, the extra runtime cost \u2014 merely a few cycles at most \u2014 won\u2019t meaningfully affect the performance of the program: it\u2019s a bargain price to pay for the added safety.</p> <p>Of course, in order to check every conversion at runtime, you need to decide what to do when a conversion doesn\u2019t work.  This is hard in general, because there is no \u201cone true error handling strategy\u201d.  Exceptions, C++17\u2019s <code>std::optional</code>, C++23\u2019s <code>std::expected</code>, and other strategies each have their place.  For a library that aims to support a wide variety of projects, it\u2019s an impossible choice.</p> <p>Fortunately, the problem decomposes favorably into two steps.</p> <ol> <li> <p>Figure out which specific conversions are lossy.  This is the hard part, but Au can do it!</p> </li> <li> <p>Write a generic checked conversion function using the preferred error handling mechanism.    The owners of a project will have to do this, but this is easy if Au provides the first part.</p> </li> </ol> <p>Here\u2019s a complete worked example of how you would do this in a codebase using C++17\u2019s <code>std::optional</code>.</p> <pre><code>template &lt;typename U, typename R, typename TargetUnitSlot&gt;\nconstexpr auto try_converting(au::Quantity&lt;U, R&gt; q, TargetUnitSlot target) {\n    return is_conversion_lossy(q, target)\n        ? std::nullopt\n        : std::make_optional(q.coerce_as(target));\n}\n</code></pre> <p>The goal of <code>is_conversion_lossy</code> is to produce an implementation for each individual conversion (based on both the numeric type, and the conversion factor) that is as accurate and efficient as an expertly hand-written implementation.  If it passes those checks, then it\u2019s safe and correct to call <code>.coerce_as</code> instead of simply <code>.as</code>: we can override the approximate safety checks of the latter because we\u2019ve performed an exact safety check.</p> An example of the kind of details we take care of <p>When we say \u201cexpertly hand-written\u201d, we mean it.  We even handle obscure C++ minutae such as integer promotion!</p> <p>Consider the conversion from <code>yards(int16_t{1250})</code> to <code>meters</code>.  Under the hood, this conversion first multiplies by <code>int16_t{1143}</code>, and then divides by <code>int16_t{1250}</code>.  The multiplication produces 1,428,750 \u2014 but the maximum <code>int16_t</code> value is only 32,767.  Looks like a pretty clear case of overflow.</p> <p>However, the product of two <code>int16_t</code> values is not (usually) an <code>int16_t</code> value!  On most architectures, it gets converted to <code>int32_t</code>, due to integer promotion.  This intermediate type can hold the result of the multiplication.  What\u2019s more, the subsequent division by <code>int16_t{1250}</code> brings the final result back into the range of <code>int16_t</code>.</p> <p>Au\u2019s implementation of <code>is_conversion_lossy</code> will correctly return <code>false</code> on architectures where this promotion happens, and <code>true</code> on architectures where it doesn\u2019t.  If this sounds like the kind of detail you\u2019d rather not worry about, go ahead and use Au\u2019s utilities!</p> <p>At the time of writing, Au is the only units library we know that provides conversion checkers to do this heavy lifting.  We\u2019d like to see other units libraries try it out as well!  Meanwhile, even on our end, there\u2019s still more work to do \u2014 such as adding \u201cexplicit rep\u201d versions of these utilities, and supporting <code>QuantityPoint</code>.  You can track our progress on this feature in issue #110.</p>"},{"location":"discussion/concepts/overflow/#summary","title":"Summary","text":"<p>The hazard of overflow lurks behind every unit conversion \u2014 even the \u201chidden\u201d conversions that are hard to spot. To maximize safety, we need a strategy to mitigate this risk.  Au\u2019s novel overflow safety surface is a big step forward, adapting to the level of risk actually present in each specific conversion.  But the most robust solution of all is to make it as easy as possible to check every conversion as it happens, and be prepared for it to fail.</p> <ol> <li> <p>Here, we take the radius of the observable universe as 46.6 billion light years, and the   diameter of a hydrogen atom as 0.1 nanometers.\u00a0\u21a9</p> </li> <li> <p>Note that we\u2019re implicitly assuming that the conversion factor is simply an integer.  This is always true for the cases discussed in this section, because we\u2019re talking about converting quantity types with integral rep.  If the conversion factor were not an integer, then we would already forbid this conversion due to truncation, so we wouldn\u2019t need to bother considering overflow.\u00a0\u21a9</p> </li> </ol>"},{"location":"discussion/concepts/quantity_point/","title":"Quantity Point","text":"<p>While <code>Quantity</code> works well for most units library operations, there are some situations where it struggles.  The most important example is temperature: as we\u2019ll soon see in detail, <code>Quantity</code> alone could never handle all temperature use cases simultaneously.  The tool that solves this problem, <code>QuantityPoint</code>, also helps similar use cases, such as atmospheric pressure.  It even improves seemingly unrelated use cases as well, such as along-path positions (\u201cmile markers\u201d).</p> <p>Overall, <code>QuantityPoint</code> is a subtle but critically important tool in a units library toolbox. Let\u2019s dive into the main motivating problem, and then learn about the properties of its solution.</p>"},{"location":"discussion/concepts/quantity_point/#temperatures-are-error-prone","title":"Temperatures are error prone","text":"<p>Let\u2019s look at a use case where <code>Quantity</code> struggles: temperature.  Consider: is 20 degrees Celsius the same as 20 Kelvins?</p> <p>Answer: it depends.</p> <ul> <li> <p>If we\u2019re talking about a change in temperature, they\u2019re completely equivalent.  If the   temperature increased by 20 degrees Celsius, then it increased by 20 Kelvins.</p> </li> <li> <p>If we\u2019re asking what the temperature is, they\u2019re very different.  If the temperature is 20   degrees Celsius, then it\u2019s not 20 Kelvins \u2014 it\u2019s 293.15 Kelvins!</p> </li> </ul> <p>What\u2019s going on is that the Celsius scale has shifted the origin, that is, the temperature which we consider to be \u201czero\u201d.  This shift helps humans: it labels the temperatures we encounter in the environment with numbers that are easier to work with.  That\u2019s an important property of a well-chosen system of units for a given domain.</p> <p>Note</p> <p>Note especially that this origin shift is not an option for temperature changes!  There could never be a unit that assigns \u201czero\u201d to any amount other than \u201cno change\u201d.</p> <p>Let\u2019s ponder the implications for a C++ units library.  Assume that <code>Quantity</code> is all we have, and consider: how should this library convert from degrees Celsius, to Kelvins?  We have two choices for our policy: we can either take the origin offset into account, or not.  But it\u2019s a no-win situation: either choice produces wrong answers for perfectly legitimate use cases!  We can\u2019t possibly handle both temperatures and temperature changes \u2014 at least, not if <code>Quantity</code> is our only tool.</p>"},{"location":"discussion/concepts/quantity_point/#mile-marker-math","title":"Mile marker math","text":"<p>Viewing temperatures as points, rather than \u201camounts\u201d, changes the set of operations that make sense for them.  To grasp this, let\u2019s consider another kind of labeled points: mile markers. (These will make it easier to understand, because the terminology is less confusing than for temperatures.)</p> <p>Mile markers label the points along a linear path using distance units.  The choice of which point is \u201cmile zero\u201d is completely arbitrary, but once we make that choice, the labels for the rest of the points are determined.</p> <p>Here are some examples showing how \u201cmile marker math\u201d works.  Let\u2019s imagine we have a function, <code>mile_marker()</code>.  Say it produces some type that models \u201cpoints\u201d, which we\u2019ll call <code>QuantityPoint</code> (as opposed to the \u201cdisplacements\u201d or \u201camounts\u201d which <code>Quantity</code> models).  Here are some examples showing how we should expect it to behave:</p> Example: <code>mile_marker(8) - mile_marker(5)</code> <p>Result: <code>miles(3)</code></p> <p>General Principle: Subtracting two points is meaningful, but it produces a quantity, not a point.</p> Example: <code>mile_marker(8) + mile_marker(5)</code> <p>Result:  Nonsense: no result. </p> <p>General Principle: Adding two points is meaningless.</p> Example: <code>mile_marker(8) + miles(5)</code> <ul> <li> <p>Result: <code>mile_marker(13)</code></p> </li> <li> <p>General Principle: Adding a quantity to a point is meaningful, and it produces another   point.</p> </li> </ul> Example: <code>mile_marker(8) - miles(5)</code> <ul> <li> <p>Result: <code>mile_marker(3)</code></p> </li> <li> <p>General Principle: Subtracting a quantity from a point is meaningful, and it produces   another point.</p> </li> </ul> <p>These examples show the symbiotic relationship between <code>Quantity</code> and <code>QuantityPoint</code>.  A <code>Quantity</code> is just the displacement between two <code>QuantityPoint</code> instances.  And we can add or subtract such a <code>Quantity</code>, to go from one <code>QuantityPoint</code> to another.</p> <p>Tip</p> <p>The technical term for <code>QuantityPoint</code> is \u201caffine space type\u201d.  If you\u2019re interested to learn more, check out this accessible introduction to Affine Space Types.</p>"},{"location":"discussion/concepts/quantity_point/#temperatures-revisited","title":"Temperatures revisited","text":"<p>Armed with <code>QuantityPoint</code>, our formerly confusing temperature use cases have become a breeze.  If we always use <code>QuantityPoint</code> for temperatures, and <code>Quantity</code> for temperature changes, we can express ourselves with effortless clarity.</p> <p>In Au, we use the <code>_pt</code> suffix for functions that make <code>QuantityPoint</code>, and the <code>_qty</code> suffix (or, more commonly, no suffix<sup>1</sup>) for those that produce <code>Quantity</code>.  Let\u2019s rephrase our challenge cases using these new tools.</p> <ul> <li> <p>Temperature changes: <code>celsius_qty(20) == kelvins_qty(20)</code>.  (Result: <code>true</code>)</p> </li> <li> <p>Temperatures: <code>celsius_pt(20) == kelvins_pt(20)</code>.  (Result: <code>false</code>)</p> </li> </ul> <p>These tools are so clear and reliable that we can even mix and match different temperature scales at will!  For example: if we started the day at -40 degrees Fahrenheit, and it warmed up by 60 degrees Celsius, would it be hotter than 300 Kelvins?  Doing this by hand, we might make use of a few facts:</p> <ul> <li>-40 degrees Fahrenheit happens to be the same temperature as -40 degrees Celsius, so the final   temperature is equivalent to 20 degrees Celsius.</li> <li>The offset between Kelvins and Celsius is 273.15 K, so the final temperature of 20 degrees Celsius   is 293.15 K.</li> <li>Therefore, the answer is \u201cno\u201d: it\u2019s not hotter than 300 Kelvins.</li> </ul> <p>Now we can see whether Au comes to the same conclusion.  Note how easy it is to express the question with clarity, despite mixing three different temperature scales:</p> <pre><code>EXPECT_LT(fahrenheit_pt(-40) + celsius_qty(60), kelvins_pt(300));\n</code></pre> <p>As hoped, this test passes.</p> <p>Fun fact</p> <p>Au would perform the above calculation without ever leaving the integer domain, even though the offset between Kelvins and Fahrenheit (or Celsius) is not an integer!  As an exercise, ponder how we might do that.</p>"},{"location":"discussion/concepts/quantity_point/#quantitypoint-and-stdchronotime_point","title":"<code>QuantityPoint</code> and <code>std::chrono::time_point</code>","text":"<p>Readers familiar with the <code>std::chrono</code> library may recognize this kind of interface: it\u2019s similar to <code>std::chrono::time_point</code>.  This class has the same relationship to <code>std::chrono::duration</code> as <code>QuantityPoint</code> has to <code>Quantity</code>. In each case, we have a \u201cpoint\u201d type and a \u201cdisplacement\u201d type. And the allowed operations are similar, for example:</p> <ul> <li>You can subtract two points to get a displacement.</li> <li>You can add (or subtract) a displacement to (or from) a point.</li> <li>You can\u2019t add two points; that\u2019s a meaningless operation.</li> </ul> <p>These similarities may tempt the reader to reach for a time-units <code>QuantityPoint</code> to replace <code>std::chrono::time_point</code>, just as a time-units <code>Quantity</code> makes a very capable replacement for <code>std::chrono::duration</code>.  However, experience doesn\u2019t support this choice.</p> <p>There\u2019s much more to <code>std::chrono::time_point</code> than just providing arithmetic operations with point semantics.  It also models different kinds of clocks, preventing unintended inter-conversion between them.  And it handles real-world clock subtleties, such as modeling whether a clock can ever produce an earlier value at a later time (think: daylight saving time).  By contrast, <code>QuantityPoint</code> can only handle measurement scales that are identical up to a constant offset \u2014 and that offset must be known at compile time.</p> <p>Bottom line: when you need to track timestamps, you\u2019re better off using a special purpose library like <code>std::chrono</code>.  But once you subtract two <code>time_point</code> instances to get a <code>duration</code>, it\u2019s often useful to convert it to Au\u2019s <code>Quantity</code> \u2014 whether implicitly, or explicitly \u2014 so that it can participate in equations with other units (such as speeds and distances).</p>"},{"location":"discussion/concepts/quantity_point/#summary","title":"Summary","text":"<p><code>QuantityPoint</code> is largely a refinement for C++ units libraries.  Most use cases don\u2019t need it, and we don\u2019t even bother to define it for almost all units.  However, it is useful in a few use cases, such as mile markers or atmospheric pressure.  And for some use cases, such as temperatures or atmospheric pressure, it\u2019s absolutely essential.</p> <ol> <li> <p>In practice, <code>Quantity</code> is overwhelmingly more common, so we prefer to omit the suffix: we write <code>meters(2)</code> instead of <code>meters_qty(2)</code>, for example.  However, this policy would fail for temperatures: if we wrote <code>celsius(20)</code>, should it refer to the temperature, or temperature change?  Clearly, this would be far too error prone.  Therefore, for temperatures, we always include the <code>_qty</code> suffix for <code>Quantity</code> makers.\u00a0\u21a9</p> </li> </ol>"},{"location":"discussion/concepts/zero/","title":"Zero","text":"<p>Au contains a special type, <code>Zero</code>, which represents the number <code>0</code>.  We also provide a built-in constant, <code>ZERO</code>, which is an instance of that type.  The goal of <code>ZERO</code> is to represent a value of <code>0</code> for any type where this is unambiguous \u2014 and to do so at compile time.</p> <p>It may seem counterintuitive to create a type which can only ever hold one value, <code>0</code>.  However, it turns out that it reduces friction in several different use cases, especially initialization and sign comparison.  Before we can appreciate these benefits, we\u2019ll need to understand where that friction comes from in the first place.</p>"},{"location":"discussion/concepts/zero/#motivation","title":"Motivation","text":"<p>Let\u2019s imagine we have some computation which produces a squared speed.  Perhaps it\u2019s based on this elementary kinematic equation:</p> v^2 = v_0^2 + 2a\\Delta x <p>Now, it\u2019s possible to provide values for v_0, a, and \\Delta x that give a negative result.  If this happens, we know we\u2019ve been provided erroneous values, and we\u2019ll have to handle that condition. Let\u2019s look at how we would do that at different stages of our project.</p>"},{"location":"discussion/concepts/zero/#pre-units-library","title":"Pre-units library","text":"<p>If we wrote the first version of our code without a units library, we probably stored our variables in raw <code>double</code>, and used variable name suffixes to keep track of the units.  For example, our code might look like this:</p> <pre><code>const auto v_squared_mmpss = (v_mps * v_mps) + 2 * a_mpss * delta_x_m;\n\nif (v_squared_mmpss &lt; 0.0) {\n    // Handle error condition\n}\n</code></pre>"},{"location":"discussion/concepts/zero/#pitfalls-in-switching-to-a-units-library","title":"Pitfalls in switching to a units library","text":"<p>Now suppose we want to switch to a units library.  The first line is great \u2014 the library really cleans it up!  But the comparison in the second line presents a problem.  Let\u2019s look at both.</p> <pre><code>const auto v_squared = (v * v) + 2 * a * delta_x;\n\nif (v_squared &lt; 0.0) {  // &lt;--- Compiler error!\n    // Handle error condition\n}\n</code></pre> <p>Getting rid of the unit suffixes is nice, but now our comparison won\u2019t compile.  And for good reason: we know we can\u2019t compare a dimensioned quantity to a raw number!  So, we roll up our sleeves, and make sure to use the right kind of <code>0</code>:</p> <pre><code>const auto v_squared = (v * v) + 2 * a * delta_x;\n\nif (v_squared &lt; squared(meters / second)(0.0)) {\n    // Handle error condition\n}\n</code></pre> <p>This works, but we couldn\u2019t really call it satisfying.  Specifying these units adds a lot of clutter.</p>"},{"location":"discussion/concepts/zero/#zero-to-the-rescue","title":"<code>ZERO</code> to the rescue","text":"<p>Fortunately, there\u2019s a better way.  To see why, notice that <code>0</code> is the one and only number where the results of this comparison are completely independent of the choice of units.  Simply put, zero of anything is just zero!</p> <p>This fact is the key to reducing friction.  We created a type, <code>Zero</code>, which always represents the value <code>0</code>.  We also made a built-in constant of that type, <code>ZERO</code>, for convenience. Our <code>Quantity</code> types are implicitly constructible from <code>ZERO</code>.  That means when we compare to it, we always get zero in the same units as the variable we\u2019re comparing to.</p> <p>Armed with this new tool, our code becomes:</p> <pre><code>const auto v_squared = (v * v) + 2 * a * delta_x;\n\nif (v_squared &lt; ZERO) {\n    // Handle error condition\n}\n</code></pre> <p>Now we have the best of both worlds!</p>"},{"location":"discussion/concepts/zero/#example-use-cases","title":"Example use cases","text":"<p>Use <code>ZERO</code> liberally whenever you need a <code>Quantity</code> of <code>0</code>!  Key use cases include:</p> <ul> <li>initialization or assignment</li> <li>sign comparison</li> </ul> <p>Here\u2019s a code comparison for a couple examples.  (Once you click on a tab below, you can use the left and right arrow keys to flip back and forth.)</p> Without <code>ZERO</code>With <code>ZERO</code> <pre><code>// Initialization\nQuantityD&lt;UnitQuotientT&lt;Radians, Meters&gt;&gt; curvature = (radians / meter)(0);\n\n// Checking for negative numbers\nif (v_squared &lt; squared(meters / second)(0)) { /* ... */ }\n</code></pre> <pre><code>// Initialization\nQuantityD&lt;UnitQuotientT&lt;Radians, Meters&gt;&gt; curvature = ZERO;\n\n// Checking for negative numbers\nif (v_squared &lt; ZERO) { /* ... */ }\n</code></pre>"},{"location":"discussion/concepts/zero/#one-non-use-case","title":"One non-use case","text":"<p>It\u2019s tempting to enable <code>ZERO</code> to construct <code>QuantityPoint</code> too, not just <code>Quantity</code>, enabling us to write something like this:</p> <pre><code>QuantityPointD&lt;Celsius&gt; freezing_temp = ZERO;\n// Warning: will not compile!\n</code></pre> <p>However, we forbid this, because it would do more harm than good.  The reason <code>ZERO</code> works so well for <code>Quantity</code> is that its meaning is completely unambiguous, independent of any units.  But the whole point of <code>QuantityPoint</code> is that different scales can apply the label of \u201czero\u201d to different points!  Imagine we refactored our codebase to use <code>Fahrenheit</code> or <code>Kelvins</code> instead of <code>Celsius</code>.  It would be easy to miss this line (and many others like it).  If we did, it would completely change the meaning of our program!</p>"},{"location":"discussion/concepts/zero/#conclusion","title":"Conclusion","text":"<p>With a quantity of <code>0</code>, the units don\u2019t matter!  So reach for <code>ZERO</code>, and make your code easier to write and read.</p> <p>And if you have another type where <code>0</code> is similarly completely unambiguous \u2014 say, a linear algebra vector class \u2014 feel free to add a constructor that takes <code>Zero</code> to give it that same expressibility!</p>"},{"location":"discussion/idioms/","title":"Au Idioms","text":"<p>This section covers common idioms and usage patterns you\u2019ll encounter in using Au.  These concepts can make you more effective with this library, but may not help with other units libraries.</p> <ul> <li>Unit slots.  Many Au APIs have parameters that accept an explicitly named   unit.  We call these paremeters \u201cunit slots\u201d.  This page will explain what kinds of things can go   in that slot, and which ones to prefer in different situations.</li> </ul>"},{"location":"discussion/idioms/unit-slots/","title":"Unit slots","text":"<p>Many APIs in the library have a parameter for you to name the desired units.  We call these parameters \u201cunit slots\u201d.</p> <p>Let\u2019s look at some common examples.  In what follows, assume <code>q</code> is some <code>Quantity</code> type, and <code>T</code> is some arithmetic type.  Then <code>u</code> will be what goes in the unit slot:</p> <ul> <li><code>q.as(u)</code></li> <li><code>round_as(u, q)</code></li> <li><code>inverse_as(u, q)</code></li> <li>\u201cExplicit-Rep\u201d versions of the above (such as <code>q.as&lt;T&gt;(u)</code>)</li> <li>\u201c<code>in</code>\u201d versions of the above, which exit the library (<code>q.in(u)</code>, <code>round_in(u, q)</code>, etc.)</li> </ul> <p>This page will explain what kinds of things \u201cfit\u201d in the slot, and which styles to prefer in different situations.</p>"},{"location":"discussion/idioms/unit-slots/#what-fits-in-a-unit-slot","title":"What \u201cfits\u201d in a unit slot?","text":"<p>The golden rule \u2014 the reason these slots exist \u2014 is that you should be naming your units at the callsite, concisely but explicitly.  This makes the code easier to read and understand at a glance.</p> <p>It turns out that there are multiple styles for explicitly naming units.  For example, if our target unit is <code>Meters</code>, then we could either pass <code>Meters{}</code> or <code>meters</code> in the unit slot, and get the same result.  While they both fulfill the main goal \u2014 namely, they name the unit explicitly \u2014 they are two different kinds of objects.</p> <ul> <li><code>Meters{}</code> is a unit expression.</li> <li><code>meters</code> is a quantity maker expression.</li> </ul> <p>Let\u2019s explore these concepts in more detail.</p>"},{"location":"discussion/idioms/unit-slots/#unit-expression","title":"Unit expression","text":"<p>A unit expression is simply an instance of a unit type.  This could be something as simple as <code>Meters{}</code>, an instance of the unit type <code>Meters</code>.</p> <p>It could also be the result of combining several such instances, via arithmetic.  For example, <code>Meters{} / squared(Seconds{})</code> is also a unit expression.  It\u2019s an instance of the type <code>UnitQuotientT&lt;Meters, UnitPowerT&lt;Seconds, 2&gt;&gt;</code>.  However, the unit expression is much easier to write and to read than the <code>UnitQuotientT&lt;...&gt;</code> version!  That\u2019s why we recommend using them to create new units.</p>"},{"location":"discussion/idioms/unit-slots/#quantity-maker-expression","title":"Quantity maker expression","text":"<p>A quantity maker expression is similar to the unit expression defined just above, except that it combines instances of <code>QuantityMaker</code> (such as <code>meters</code>) and, optionally, <code>SingularNameFor</code> (such as <code>meter</code>).  The result of this expression will be an instance of a <code>QuantityMaker</code>.</p> <p>Quantity maker expressions support all of the same arithmetic operations as unit expressions, but they have two advantages that make them easier to read:</p> <ol> <li> <p>You don\u2019t need to add the <code>{}</code>, since the participating elements are already instances rather    than types.</p> </li> <li> <p>You can use grammatically correct names, such as <code>meters / squared(second)</code> (note: <code>second</code> is    singular), rather than <code>Meters{} / squared(Seconds{})</code>.</p> </li> </ol>"},{"location":"discussion/idioms/unit-slots/#other-expressions","title":"Other expressions","text":"<p>There are other monovalue types that would feel right at home in a unit slot.  We typically support those too!  Key examples include unit symbols and constants.  Expand the block below to see a worked example.</p> Example: using unit symbols and constants in unit slots <p>Suppose we have the following preamble, simply to set everything up.</p> <pre><code>struct SpeedOfLight : decltype(Meters{} / Seconds{} * mag&lt;299'792'458&gt;()) {\n    static constexpr const char label[] = \"c\";\n};\nconstexpr const char SpeedOfLight::label[];\nconstexpr auto c = make_constant(SpeedOfLight{});\n\n// These using declarations should be in a `.cc` file, not `.hh`,\n// to avoid namespace pollution!\nusing symbols::m;\nusing symbols::s;\n</code></pre> <p>Then we can pass either the unit symbols, or the constants, to our unit slot APIs:</p> <pre><code>constexpr auto v = (miles / hour)(65.0);\n\nstd::cout &lt;&lt; v.as(m / s) &lt;&lt; std::endl;\n//                ^^^^^\n// Passing a unit symbol to the unit slot.  Output:\n// \"29.0576 m / s\"\n\nstd::cout &lt;&lt; v.as(c) &lt;&lt; std::endl;\n//                ^\n// Passing a constant to the unit slot.  Output:\n// \"9.69257e-08 c\"\n</code></pre>"},{"location":"discussion/idioms/unit-slots/#notes-for-quantitypoint","title":"Notes for <code>QuantityPoint</code>","text":"<p><code>QuantityPoint</code> doesn\u2019t use quantity makers: it uses quantity point makers.  For example, instead of the quantity maker <code>meters</code>, it uses the quantity point maker <code>meters_pt</code>.</p> <p>The implications are straightforward.  If you have a <code>QuantityPoint</code> instead of a <code>Quantity</code>, then use the quantity point maker instead of the quantity maker.  The library will enforce this automatically: for example, you can\u2019t pass <code>meters</code> to a <code>QuantityPoint</code>\u2019s unit slot, and you can\u2019t pass <code>meters_pt</code> to a <code>Quantity</code>\u2019s unit slot.</p> <p>To get the associated unit for a type, use the <code>AssociatedUnitT</code> trait when you\u2019re dealing with <code>Quantity</code>, and use the <code>AssociatedUnitForPointsT</code> trait when dealing with <code>QuantityPoint</code>.</p>"},{"location":"discussion/idioms/unit-slots/#examples-rounding-to-rpm","title":"Examples: rounding to RPM","text":"<p>Let\u2019s look at some examples, using this quantity variable:</p> <pre><code>constexpr auto angular_velocity = (radians / second)(10.0);\n</code></pre> <p>Our goal will be to round it to the nearest value in revolutions per minute (RPM).  Let\u2019s look at our options for doing that.</p>"},{"location":"discussion/idioms/unit-slots/#best-choice-quantity-maker-expression","title":"Best choice: quantity maker expression","text":"<p><code>QuantityMaker</code> instances have the name of the unit, so they meet our core criterion (which is, again, to name the units explicitly at the callsite).  They also compose just as naturally as unit instances.  In fact, they also work nicely with <code>SingularNameFor</code> instances \u2014 such as <code>minute</code>, for the unit <code>Minutes</code> \u2014 to further enhance readability.</p> <p>Here\u2019s how it looks to pass a <code>QuantityMaker</code> \u2014 fluently composed, on the fly \u2014 to this unit expression API.</p> <pre><code>constexpr auto rpm = round_as(revolutions / minute, angular_velocity);\n//                            ^^^^^^^^^^^^^^^^^^^^\n//                          Quantity maker expression\n</code></pre>"},{"location":"discussion/idioms/unit-slots/#also-acceptable-unit-expression","title":"Also acceptable: unit expression","text":"<p>We could, of course, also pass a unit expression to the unit expression slot.</p> <pre><code>// Usual unit-expression approach (doing arithmetic on *instances*):\nconstexpr auto rpm = round_as(Revolutions{} / Minutes{}, angular_velocity);\n//                            ^^^^^^^^^^^^^^^^^^^^^^^^^\n//                                 unit expression\n\n// Alternative, clunkier unit-expression approach (doing arithmetic on *types*):\nconstexpr auto rpm = round_as(\n   UnitQuotientT&lt;Revolutions, Minutes&gt;{}, angular_velocity);\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//            unit expression\n</code></pre> <p>These are OK, but they have a couple of drawbacks compared to the quantity maker approach.</p> <ol> <li> <p>They\u2019re grammatically incorrect: \u201crevolutions per minutes\u201d, instead of \u201crevolutions per    minute\u201d.</p> </li> <li> <p>You need to sprinkle extra <code>{}</code> throughout to turn the unit types into instances.</p> </li> </ol> <p>The main reason to use this method is for generic code.  In these cases, you don\u2019t usually have a quantity maker handy, but you do know the unit type.</p>"},{"location":"discussion/idioms/unit-slots/#poor-choice-manually-constructed-quantitymaker","title":"Poor choice: manually constructed <code>QuantityMaker</code>","text":"<p>This may look counterintuitive, but we mention it because we\u2019ve seen a few instances of this approach in the wild!  Here is an example:</p> <pre><code>//\n// !!   Do not do this!   !!\n//\nconstexpr auto rpm = round_as(\n    QuantityMaker&lt;UnitQuotientT&lt;Revolutions, Minutes&gt;&gt;{}, angular_velocity);\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//           manual QuantityMaker instance\n</code></pre> <p>Presumably, this mistake comes from reading the signatures in the source code without understanding their core design goal: namely, to provide a place to specify the units, concisely and explicitly, at a callsite.</p> <p>This provides no benefit at all.  We could replace the <code>QuantityMaker&lt;UnitQuotientT&lt;Revolutions, Minutes&gt;&gt;</code> with its contents (<code>UnitQuotientT&lt;Revolutions, Minutes&gt;</code>) and it would be strictly better.</p> <p>The reason we endorse the <code>QuantityMaker</code> overloads is because of the convention to provide \u201ccanned\u201d <code>QuantityMaker</code> instances which are named after their corresponding units.  If you have to construct a new <code>QuantityMaker</code> on the fly, then this benefit vanishes.  (This is why unit expressions are preferred for generic code.)</p>"},{"location":"discussion/idioms/unit-slots/#summary","title":"Summary","text":"<p>Many Au APIs have a \u201cunit slot\u201d.  These are designed for you to name the units explicitly at the callsite.  Pass whatever is the simplest construct that meets that goal \u2014 usually, this will be a pre-existing <code>QuantityMaker</code>, or several of them composed together.</p>"},{"location":"discussion/implementation/","title":"Implementation Details","text":"<p>This section provides in-depth discussion about core implementation details of Au.  If you want to understand how the library works, this is a good place to go.  Here\u2019s a rough guide.</p> <ul> <li> <p>Applying Magnitudes.  A conversion factor is a magnitude:   a positive real number.  The best way to apply it to a value of type <code>T</code> depends on what kind of   number it is (integer, rational, and so on), the runtime performance, and whether we can get exact   answers.</p> </li> <li> <p>Vector Space Representations.  We\u2019re not talking about position vectors   or velocity vectors!  There\u2019s a different kind of vector at the heart of every units library.   This is the core foundational concept on which we built Au\u2019s implementation.</p> </li> </ul>"},{"location":"discussion/implementation/applying_magnitudes/","title":"Applying Magnitudes","text":"<p>Every unit conversion factor is a magnitude \u2014 a positive real number.  When we apply it to a value, conceptually, we\u2019re just multiplying the value by that number. However, that doesn\u2019t mean that multiplying by a number is the best implementation!  Consider these examples.</p> <ul> <li>Factor: \\frac{5}{8}; value: <code>12</code> (type: <code>int</code>).<ul> <li>Computationally, we don\u2019t want to leave the integral domain.  But of course, \\frac{5}{8}   can\u2019t be represented as an integer!  This suggests we should perform two operations: first   multiply by <code>5</code>, and then divide by <code>8</code>, yielding <code>7</code>.</li> </ul> </li> <li>Factor: \\frac{1}{13}; value: <code>91.0f</code> (type: <code>float</code>).<ul> <li>Conceptually, this has an exactly representable answer: 91\\left(\\frac{1}{13}\\right) = 7.   However, if we multiply by the single number <code>(1.0f / 13.0f)</code>, we obtain the approximation   <code>7.0000004768371582</code>!  This suggests that for \\frac{1}{13}, at least, it would be better to   divide by <code>13.0f</code>.</li> </ul> </li> </ul> <p>Au is thoughtful about how we apply conversion factors.  We first compute a category for the factor, which dictates the best strategy for applying it.  We may also take into account whether we\u2019re dealing with an integral or floating point type.</p>"},{"location":"discussion/implementation/applying_magnitudes/#magnitude-categories","title":"Magnitude categories","text":"<p>We represent conversion factors with magnitudes.  These representations support exact symbolic math for products and rational powers.  They also support querying for numeric properties of the number, such as whether it is an integer, whether it\u2019s irrational, and so on.</p> <p>For purposes of applying to a value, we find four useful categories of magnitude.</p> <ol> <li>Integers.</li> <li>Reciprocal integers.</li> <li>Rational numbers (other than the first two categories).</li> <li>Irrational numbers.</li> </ol> <p>These categories are mutually exclusive and exhaustive.  Below, we\u2019ll explain the best strategy for each one.</p>"},{"location":"discussion/implementation/applying_magnitudes/#integers","title":"Integers","text":"<p>Applying an integer magnitude to a type <code>T</code> is simple: we multiply by that integer\u2019s representation in <code>T</code>.</p> <p>This always compiles to a single instruction, and always produces exact answers whenever they are representable in the type <code>T</code>.</p>"},{"location":"discussion/implementation/applying_magnitudes/#reciprocal-integers","title":"Reciprocal integers","text":"<p>If a magnitude is not an integer, but its reciprocal is, then we divide by its reciprocal.  For example, in converting a value from <code>inches</code> to <code>feet</code>, we will divide by 12, instead of multiplying by the representation of \\frac{1}{12}, which would be inexact.</p> <p>As with integers, this always compiles to a single instruction, and always produces exact answers whenever they are representable in the type <code>T</code>.</p>"},{"location":"discussion/implementation/applying_magnitudes/#rational-numbers","title":"Rational numbers","text":"<p>Again, to be clear, this category only includes rationals that are neither integers nor reciprocal integers.  So, for example, neither 2 nor \\frac{1}{5} falls in this category, but \\frac{2}{5} does.</p> <p>This category is interesting, because it\u2019s the first instance where our strategy depends on the type <code>T</code> to which we\u2019re applying the factor.  The best approach differs between integral and non-integral types.</p>"},{"location":"discussion/implementation/applying_magnitudes/#integral-types","title":"Integral types","text":"<p>Here, we multiply by the numerator, then divide by the denominator.  This compiles to two operations instead of one, but it\u2019s the only way to get reasonable accuracy.</p> <p>There\u2019s another issue: the multiplication operation can overflow.  This means we can produce wrong answers in some instances, even when the correct answer is representable in the type!  For example, let\u2019s say our value is <code>std::numeric_limits&lt;uint64_t&gt;::max()</code>, and we apply the magnitude \\frac{2}{3}: by the time we divide by 3, the multiplication by 2 has already lost our value to overflow.</p> <p>We might be tempted to prevent this by doing the division first.  In the above example, this would certainly give us a much closer result!  However, the cost would be reduced accuracy for smaller values, which are far more common.  Consider applying \\frac{2}{3} to a smaller number, such as <code>5</code>.  The exact rational answer is \\frac{10}{3}, which truncates to <code>3</code>.  If we perform the multiplication first, this is what we get, but doing the division first would give <code>2</code>.</p> <p>If you know that your final answer is representable, and you have an integer type with more bits than your type <code>T</code>, then you can work around this issue manually by casting to the wider type, applying the magnitude, and casting back to <code>T</code>. However, if you don\u2019t have a wider integer types, we know of no general \u201csolution\u201d that wouldn\u2019t do more harm then good.</p>"},{"location":"discussion/implementation/applying_magnitudes/#floating-point-types","title":"Floating point types","text":"<p>Applying a rational magnitude \\frac{N}{D} to a value of floating point type <code>T</code> presents a genuine tradeoff. On the one hand, we could take the same approach as for the integers, and perform two operations: multiplying by N, then dividing by D.  On the other hand, we could simply multiply by the single number which best represents \\frac{N}{D}.  Here\u2019s a summary of the tradeoffs:</p> Criterion Weighting Multiply-and-divide: <code>(val * N) / D</code> Single number: <code>val * (N / D)</code> Instructions medium 2 1 Overflow low More vulnerable Less vulnerable Exact answers for multiples of D low Guaranteed Not guaranteed <p>Overall, we aren\u2019t worried much about missing out on exact answers.  Users of floating point know they need to handle the possibility that a calculation\u2019s result can be one or two representable values away from the best possible result.  (This is commonly called the \u201cusual floating point error\u201d.)</p> <p>We also aren\u2019t very worried about overflow.  Even float has a range of 10^{38}, while going from femtometers to Astronomical Units (AU) spans a range of \u201conly\u201d about 10^{26}.</p> <p>Going from 1 instruction to 2 is a moderate concern, which means that it outweighs the other two considerations.  It represents a runtime penalty relative to the usual approach people take without a units library, which is to compute a single conversion factor.  We always strive to avoid runtime penalties in units libraries! The reason we don\u2019t consider this even more serious is that unit conversions should never occur in the \u201chot loop\u201d for a program; thus, this performance hit isn\u2019t really meaningful.</p> <p>Outcome: we represent a rational conversion factor \\frac{N}{D} with a single number when applying it to a floating point variable.</p>"},{"location":"discussion/implementation/applying_magnitudes/#irrational-numbers","title":"Irrational numbers","text":"<p>There is no reason to try splitting an irrational number into parts to get an exact answer.  Since we\u2019re multiplying our variable by an irrational number, we know the result won\u2019t be exactly representable.  Therefore, we always simply multiply by the closest representation of this conversion factor.</p> <p>The one difference is that we forbid this operation for integral types, because it makes no sense.</p>"},{"location":"discussion/implementation/applying_magnitudes/#summary-and-conclusion","title":"Summary and conclusion","text":"<p>Applying a conversion factor to a numeric variable of type <code>T</code> can be a tricky and subtle business. Au takes a thoughtful, tailored approach, which can be summarized as follows:</p> <ul> <li>If the conversion factor multiplies \u2014 or divides \u2014 by an exact integer, then we do that.</li> <li>Otherwise, if it\u2019s a rational number \\frac{N}{D}, and <code>T</code> is integral, then we multiply by N   and divide by D (each represented in <code>T</code>).</li> <li>Otherwise, we simply multiply by the nearest representation of the conversion factor in <code>T</code> \u2014   with the exception that if <code>T</code> is integral, we raise a compiler error for irrational factors.</li> </ul>"},{"location":"discussion/implementation/vector_space/","title":"Vector Space Representations","text":"<p>To understand why vector space representations are so important for units libraries, we\u2019ll dig into the most fundamental example.  After that, we\u2019ll look at some other instances of vector space representations in our library.</p> <p>Consider Dimensions.  How can we teach the library to recognize that, say, the product of the Dimensions <code>Speed</code> and <code>Time</code> is the Dimension <code>Length</code>?  If these three Dimensions are all primitive, irreducible objects, this is very challenging.  However, if <code>Speed</code> is just an alias for <code>(Length / Time)</code>, then it\u2019s easy to see that <code>(Length / Time) * Time</code> reduces to <code>Length</code>.</p> <p>This is what we do: we single out certain Dimensions and call them \u201cBase Dimensions\u201d.  Any valid choice must fulfill these conditions:</p> <ol> <li> <p>Independence: no product of rational powers of Base Dimensions is dimensionless, unless all    exponents are 0.</p> </li> <li> <p>Completeness: every Dimension of interest can be represented as some product of rational    powers of Base Dimensions.</p> </li> </ol> <p>The reader may recognize these properties of Base Dimensions as analogous to the defining properties of Basis Vectors in a vector space, but with these differences:</p> <ul> <li>instead of adding vectors, we multiply Base Dimensions</li> <li>instead of multiplying vectors by a scalar, we raise them to a power</li> </ul> <p>In fact, we can bridge this gap if we consider the exponents of the dimensions to be the scalars of the vector space.  In a sense, the \u201clogarithms\u201d of the dimensions form a vector space; in this case, over the rationals.</p> <p>This is the \u201cvector space representation\u201d for Dimensions.</p>"},{"location":"discussion/implementation/vector_space/#fleshing-out-the-analogy","title":"Fleshing out the analogy","text":"<p>How do the defining properties of vector spaces manifest themselves here?  Let the space of all Dimensions be \\mathscr{D}.  For any dimensions D, D_1, D_2, D_3 \\in \\mathscr{D}, and any rational numbers a, b \\in \\mathbb{Q}, we have:</p> <ul> <li>Associativity: D_1 \\cdot (D_2 \\cdot D_3) = (D_1 \\cdot D_2) \\cdot D_3</li> <li>Commutativity: D_1 \\cdot D_2 = D_2 \\cdot D_1</li> <li>Identity (Vector): \\exists \\pmb1 \\in \\mathscr{D}: \\,\\, \\pmb1 \\cdot D = D \\cdot \\pmb1 = D,   \\,\\, \\forall D</li> <li>Inverse: \\forall D \\in \\mathscr{D}, \\exists D^{-1} \\in \\mathscr{D}: \\,\\, D \\cdot D^{-1}   = D^{-1} \\cdot D = 1</li> <li>Scalar/Field Multiplication Compatibility: (D^a)^b = D^{(ab)}<ul> <li>(Recall that \u201cscalar multiplication\u201d in \u201cordinary\u201d vector spaces corresponds to     exponentiation in our vector space.)</li> </ul> </li> <li>Identity (Scalar): \\exists 1 \\in \\mathbb{Q}: \\,\\, D^1 = D</li> <li>Distributivity (Vectors): (D_1 \\cdot D_2)^a = D_1^a \\cdot D_2^a</li> <li>Distributivity (Scalars): D^{(a + b)} = D^a \\cdot D^b</li> </ul>"},{"location":"discussion/implementation/vector_space/#c-implementation-strategies","title":"C++ Implementation Strategies","text":"<p>The abstract concepts above form the core of basically every C++ units library.  When it comes to implementation, there are a variety of choices.</p>"},{"location":"discussion/implementation/vector_space/#naive-approach-positional-arguments","title":"Naive approach: positional arguments","text":"<p>The simplest implementation of a vector space is to use positional template parameters to represent the coefficients (exponents) of each basis vector (base dimension).  For example:</p> <pre><code>// Basic approach (not used in this library)\ntemplate&lt;typename LengthExp, typename TimeExp&gt;\nstruct Dimension;\n\nusing Length = Dimension&lt;std::ratio&lt;1&gt;, std::ratio&lt;0&gt;&gt;;\nusing Time   = Dimension&lt;std::ratio&lt;0&gt;, std::ratio&lt;1&gt;&gt;;\nusing Speed  = DimQuotientT&lt;Length, Time&gt;;\n</code></pre> <p>This approach is easy to implement, but its simplicity comes at a cost.</p> <ul> <li> <p>Compiler errors are inscrutable.  (What exactly does   <code>Dimension&lt;std::ratio&lt;1, 1&gt;, std::ratio&lt;-1, 1&gt;&gt;</code> represent?)</p> </li> <li> <p>If we need to add a new basis vector, it will affect an immense number of callsites.</p> </li> <li> <p>Some applications need infinitely many basis vectors!  This approach is a complete non-starter.</p> </li> </ul>"},{"location":"discussion/implementation/vector_space/#advanced-approach-variadic-templates","title":"Advanced approach: variadic templates","text":"<p>We can solve all of these problems by making <code>Dimension</code> a variadic template.</p> <pre><code>// Advanced approach (the one we use, although simplified here)\ntemplate&lt;typename... BaseDimPowers&gt;\nstruct Dimension;\n\nusing Length = Dimension&lt;base_dim::Length&gt;;\nusing Time   = Dimension&lt;base_dim::Time&gt;;\nusing Speed  = DimQuotientT&lt;Length, Time&gt;;  // As before.\n</code></pre> <p>Compiler errors are now easy (or at least possible) to read: when we see something like <code>Dimension&lt;base_dim::Length, Pow&lt;base_dim::Time, -1&gt;&gt;</code>, we can recognize it as \u201cSpeed\u201d.  And adding new basis vectors\u2014even arbitrarily many new ones\u2014doesn\u2019t affect any existing callsites.</p> <p>The downside is that the added complexity incurs new risk.  Now we have to care about the order of the template parameters; otherwise, we could have different types representing the same conceptual Dimension.  Fortunately, that\u2019s exactly why we built the <code>//au:packs</code> target: to handle these subtleties robustly.</p>"},{"location":"discussion/implementation/vector_space/#other-vector-space-representations","title":"Other vector space representations","text":"<p>Above, we focused on Dimensions as an example use case for the vector space representation.  Though by far the most common in units libraries, it\u2019s not the only one that adds value.  Here are some others worth recognizing.</p>"},{"location":"discussion/implementation/vector_space/#magnitude","title":"Magnitude","text":"<p>The ratio between two Units of the same Dimension is a positive real number: a \u201cMagnitude\u201d.  We use a vector space representation for Magnitudes, because then it will naturally support all the same operations which Dimensions support.  But then, what are the basis vectors?  What numbers can we use that are \u201cindependent\u201d, in the sense that every Magnitude gets a unique representation?</p> <p>Prime numbers are a great start!  Given any collection of primes, \\{p_1, \\ldots, p_N\\}, and corresponding rational exponents \\{a_1, \\ldots, a_N\\}, the product p_1^{a_1} \\cdot (\\ldots) \\cdot p_N^{a_N} is unique: no other collection \\{a_1, \\ldots, a_N\\} can produce the same number<sup>1</sup>.</p> <p>This already lets us represent anything we could get with <code>std::ratio</code>.  And, unlike a <code>(num, denom)</code> representation, we\u2019re always automatically in lowest terms: any common factors cancel out automatically when we represent it via its prime factorization!</p> <p>In fact, we have surpassed <code>std::ratio</code>\u2019s functionality, too.  We can handle very large numbers with negligible risk of overflow: <code>yotta</code> (10^{24}) doesn\u2019t even fit in <code>std::intmax_t</code>, but <code>pow&lt;24&gt;(mag&lt;10&gt;())</code><sup>2</sup> handles it with ease.  We can even handle radicals: something unthinkable for <code>std::ratio</code>, like \\sqrt{2}, is as easy as <code>root&lt;2&gt;(mag&lt;2&gt;())</code><sup>3</sup>.</p> <p>Finally, we can incorporate other irrational numbers, too.  No units library is complete without robust support for \\pi, but <code>std::ratio</code> isn\u2019t up to the task.  For vector space magnitude representations, though, its difficulty becomes a strength.  We know there is no collection of exponents \\{a_i\\} such that \\pi = \\prod\\limits_{i=1}^N p_i^{a_i}, for any collection of primes \\{p_i\\}.  This means that \\pi is independent, and we can add it as a new basis vector.  Then the ratio of, say, <code>Degrees</code> to <code>Radians</code> (i.e., \\pi / 180) could be expressed as <code>Magnitude&lt;Pi&gt;{} / mag&lt;180&gt;()</code><sup>4</sup>.</p>"},{"location":"discussion/implementation/vector_space/#units","title":"Units","text":"<p>If we form a Unit by combining other units\u2014say, <code>Miles{} / Hours{}</code>\u2014it\u2019s useful to retain the identities of the units that went into it.  There are several reasons to prefer this to, say, converting everything to a coherent combination of preferred \u201cbase units\u201d, and some Magnitude for scaling.</p> <ul> <li> <p>It will be easy to generate a compound label, by combining the primitive labels for <code>Miles</code> and   <code>Hours</code>.</p> </li> <li> <p>Compiler errors will mention only familiar, recognizable Units.</p> </li> <li> <p>It promotes cancellation where appropriate: <code>Miles{} / Hours{}</code> times <code>Hours{}</code> will give simply   <code>Miles{}</code>.</p> </li> </ul> <p>Our treatment of Units differs from other vector space instances, because we prefer not to use the container type (in this case, <code>UnitProduct&lt;...&gt;</code>) unless we have to: after all, <code>Meters</code> is more user-friendly than <code>UnitProduct&lt;Meters&gt;</code>, let alone something awful like <code>UnitProduct&lt;RatioPow&lt;Meters, 1, 0&gt;&gt;</code>!  We support this use case with the following strategy:</p> <ul> <li> <p>wrap-if-necessary on the way in (via <code>AsPackT</code>)</p> </li> <li> <p>unwrap-if-possible on the way out (via <code>UnpackIfSoloT</code>)</p> </li> </ul> <p>This was the only machinery we needed to add: apart from that, we were able to leverage our pre-existing packs support to provide a fluent experience for compound units.</p> <ol> <li> <p>Technically, this is only true for a finite collection of primes, though the collection can be arbitrarily large.  If we took an infinite collection of primes, it wouldn\u2019t just give some numbers multiple representations \u2014 it would give every number uncountably infinitely many distinct representations!  In practice, this distinction is largely academic, because our library currently only targets computers with finite amounts of memory.\u00a0\u21a9</p> </li> <li> <p><code>pow&lt;24&gt;(mag&lt;10&gt;())</code> expands to <code>Magnitude&lt;Pow&lt;Prime&lt;2&gt;, 24&gt;, Pow&lt;Prime&lt;5&gt;, 24&gt;&gt;</code>.\u00a0\u21a9</p> </li> <li> <p><code>root&lt;2&gt;(mag&lt;2&gt;())</code> expands to <code>Magnitude&lt;RatioPow&lt;Prime&lt;2&gt;, 1, 2&gt;&gt;</code>.\u00a0\u21a9</p> </li> <li> <p><code>Magnitude&lt;Pi&gt;{} / mag&lt;180&gt;()</code> expands to <code>Magnitude&lt;Pow&lt;Prime&lt;2&gt;, -2&gt;, Pow&lt;Prime&lt;3&gt;, -2&gt;, Pi, Pow&lt;Prime&lt;5&gt;, -1&gt;&gt;</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"howto/","title":"How-to guides","text":"<p>This section provides detailed instructions for various common tasks that come up in the course of using the library.  Here\u2019s a summary of what you\u2019ll find.</p> <ul> <li> <p>New units.  How to add a new unit of measure that the library doesn\u2019t   include.</p> </li> <li> <p>New dimensions.  How to add a new, independent base dimension.</p> </li> <li> <p>Inter-library Interoperation.  How to set up automatic correspondence   between equivalent types in Au and any other units library.</p> <ul> <li>nholthaus/units.  How to use the ready-made interoperability   with the nholthaus/units library.</li> </ul> </li> </ul>"},{"location":"howto/new-dimensions/","title":"Defining new dimensions","text":"<p>This page explains how to define a new base dimension.</p> <p>Recall that dimensions form a vector space.  In plain terms, this means you don\u2019t need to add any new dimension that can be formed as a combination of existing dimensions.  (For example, the \u201cforce\u201d dimension can be composed of the base dimensions \u201clength\u201d, \u201ctime\u201d, and \u201cmass\u201d, so you don\u2019t need to define it explicitly.)</p> <p>Recall, too, that in Au, dimensions are an implementation detail.  This means that although they are important for making the library work, end users rarely name them directly in their code, and they rarely appear in compiler errors.</p> <p>Thus, defining a new base dimension is a much less common operation than defining a new unit.  That said, it\u2019s still sometimes useful, and it is supported by the library, so we\u2019ll explain how to do it.</p>"},{"location":"howto/new-dimensions/#definition-features","title":"Definition features","text":"<p>Your definition will contain two \u201clayers\u201d.</p> <ol> <li>A new type representing the \u201cbase dimension\u201d.</li> <li>A unit of this new dimension.</li> </ol> <p>Your end users will typically only see the latter.  In Au, it\u2019s more idiomatic to work with units, instead of naming dimensions explicitly.</p> <p>To give a concrete example, we\u2019ll suppose we\u2019re defining a new base dimension for \u201cpixels\u201d.</p> <p>Note</p> <p>This doesn\u2019t imply anything about whether or not this would be a good use case for a new base dimension; it\u2019s purely for illustration purposes.</p>"},{"location":"howto/new-dimensions/#base-dimension-type","title":"Base dimension type","text":"<p>In Au, a base dimension is a type with a static <code>int64_t</code> member, <code>base_dim_index</code>.  This index must be unique among all other base dimensions in a program.  The easiest way to make this struct is to inherit from <code>au::base_dim::BaseDimension&lt;N&gt;</code>, where <code>N</code> is the index.</p> <p>To keep the index unique among all base dimensions in your program, we recommend using some integral identifier that is unlikely to be duplicated.  This might be a GitHub issue number for your project, or a current timestamp in seconds using the Unix epoch.</p> <p>Negative indices are reserved for the Au library.</p> <p>Here\u2019s how we\u2019d define the new base dimension for our example of \u201cpixels\u201d.  (We\u2019ve used the Unix epoch approach to ensure uniqueness.)</p> <pre><code>struct PixelBaseDim : au::base_dim::BaseDimension&lt;1690384951&gt; {};\n</code></pre>"},{"location":"howto/new-dimensions/#unit-of-new-dimension","title":"Unit of new dimension","text":"<p>The unit of your dimension is what you\u2019ll provide to end users.  They\u2019ll combine it with other units via the usual operations.</p> <p>The definition mostly follows the standard instructions for defining new units, with one exception: instead of inheriting from a unit expression, you\u2019ll inherit from <code>au::UnitImpl</code>.  This defines a new unit with the dimension that you pass it.</p> A note on the \"magnitude\" of this unit <p>The magnitude of this unit will default to 1, because this is the simplest choice.  (Recall that only magnitude ratios are meaningful, and only for the same dimension.  Since there are no other units of this new dimension, we can assign whatever value we please.)</p> <p>Here is how to create that new unit.  We\u2019ll show a relatively full-featured definition, including unit label, quantity maker, and singular name.</p> C++14C++17 or later <pre><code>// In .hh file:\nstruct Pixels : au::UnitImpl&lt;au::Dimension&lt;PixelBaseDim&gt;&gt; {\n    static constexpr const char label[] = \"px\";\n};\nconstexpr auto pixel  = SingularNameFor&lt;Pixels&gt;{};\nconstexpr auto pixels = QuantityMaker&lt;Pixels&gt;{};\n\n// In .cc file:\nconstexpr const char Pixels::label[];\n</code></pre> <pre><code>// In .hh file:\nstruct Pixels : au::UnitImpl&lt;au::Dimension&lt;PixelBaseDim&gt;&gt; {\n    static constexpr inline const char label[] = \"px\";\n};\nconstexpr auto pixel  = SingularNameFor&lt;Pixels&gt;{};\nconstexpr auto pixels = QuantityMaker&lt;Pixels&gt;{};\n</code></pre>"},{"location":"howto/new-dimensions/#usage-example","title":"Usage example","text":"<p>This new unit will compose with other units in all of the usual ways.</p> <p>Here\u2019s an example test case:</p> <pre><code>constexpr auto resolution = (pixels / inch)(300);\nEXPECT_THAT(resolution * inches(6), SameTypeAndValue(pixels(1800)));\n</code></pre> <p>If we followed the instructions in the previous section, this test should pass \u2014 and you can use the <code>pixels</code> unit in your project on the same footing as any other unit.</p>"},{"location":"howto/new-units/","title":"Defining new units","text":"<p>This page explains how to define new units that aren\u2019t included in the library.</p> <p>Tip</p> <p>If it\u2019s a common unit\u2014one which should be in the library, but isn\u2019t\u2014go ahead and file an issue!  We should be able to turn it around pretty quickly (either adding it to the library, or explaining why we won\u2019t).</p>"},{"location":"howto/new-units/#definition-features","title":"Definition features","text":"<p>Many libraries provide \u201cconvenience\u201d macros for creating new units, but ours tries to avoid macros completely.<sup>1</sup>  Instead, you define new units by just writing regular C++ code.</p> <p>There are several pieces you can add, each of which provides some particular feature. Here is a complete sample definition of a new Unit, with these features annotated and explained.</p> C++14C++17 or later <pre><code>// Example custom unit definition below.\n//\n// Items labeled with `*` are _required_; everything else is optional.\n\n// In .hh file:\nstruct Fathoms : decltype(Inches{} * mag&lt;72&gt;()) {           // *[1]\n    static constexpr const char label[] = \"ftm\";            //  [2a]\n};\nconstexpr auto fathom  = SingularNameFor&lt;Fathoms&gt;{};        //  [3]\nconstexpr auto fathoms = QuantityMaker&lt;Fathoms&gt;{};          // *[4]\nconstexpr auto fathoms_pt = QuantityPointMaker&lt;Fathoms&gt;{};  //  [5; less common]\n\nnamespace symbols {\nconstexpr auto ftm = SymbolFor&lt;Fathoms&gt;{};                  //  [6]\n}\n\n// In .cc file:\nconstexpr const char Fathoms::label[];                      //  [2b]\n</code></pre> <pre><code>// Example custom unit definition below.\n//\n// Items labeled with `*` are _required_; everything else is optional.\n\n// In .hh file:\nstruct Fathoms : decltype(Inches{} * mag&lt;72&gt;()) {           // *[1]\n    static constexpr inline const char label[] = \"ftm\";     //  [2]\n};\nconstexpr auto fathom  = SingularNameFor&lt;Fathoms&gt;{};        //  [3]\nconstexpr auto fathoms = QuantityMaker&lt;Fathoms&gt;{};          // *[4]\nconstexpr auto fathoms_pt = QuantityPointMaker&lt;Fathoms&gt;{};  //  [5; less common]\n\nnamespace symbols {\nconstexpr auto ftm = SymbolFor&lt;Fathoms&gt;{};                  //  [6]\n}\n</code></pre> <p>Note</p> <p>If you\u2019ve seen the unit definitions included in our library, you may notice they look a little different from the above.  That\u2019s because the library has different goals and constraints than end user projects have.</p> <p>For example, the library needs to be both C++14-compatible and header-only.  This forces us to define our labels in a more complicated way.  By contrast, your project is unlikely to have both these constraints.</p> <p>Prefer the simpler approach outlined in this page, instead of treating our library\u2019s source code definitions as examples to follow.</p> <p>Here are the features.</p> <ol> <li> <p>Strong type definition.</p> <ul> <li>Required.  Make a <code>struct</code> with the name you want, and inherit from <code>decltype(u)</code>, where   <code>u</code> is some unit expression which gives   it the right Dimension and Magnitude.  (We\u2019ll explain unit expressions in the next section.)</li> </ul> </li> <li> <p>Label.</p> <ul> <li>A <code>sizeof()</code>-compatible label which is useful for printing the Unit.</li> <li>Note that if your project needs C++14 compatibility, then besides the label itself (<code>[2a]</code>),   you\u2019ll need to provide a definition (<code>[2b]</code>) in the <code>.cc</code> file.  By contrast, if you use   C++17 or later, you can just use an inline variable, and you won\u2019t need a <code>.cc</code> file.</li> <li>If omitted:  Everything will still work; your Quantity will just be labeled as   <code>[UNLABELED UNIT]</code> in printing contexts.</li> </ul> </li> <li> <p>Singular name.</p> <ul> <li>An object whose name is the singular name for your unit.  Useful in certain contexts: for   example, the traditional unit for torque is \u201cnewton meters\u201d, not \u201cnewtons meters\u201d.</li> <li>If omitted: you\u2019ll sacrifice some readability flow: the grammar becomes strange.  You\u2019ll   end up with constructs like <code>speed.in(miles / hours)</code>, rather than <code>speed.in(miles / hour)</code>.</li> </ul> </li> <li> <p>Quantity maker.</p> <ul> <li>Required.  This gives you a <code>snake_case</code> version of your unit which acts like a function.   If you call this \u201cfunction\u201d and pass it any numeric type, it creates a <code>Quantity</code> of your   unit, whose Rep is that type.  Of course, a quantity maker is much more than a function: it   composes nicely with prefixes, and with other quantity makers.</li> </ul> </li> <li> <p>Quantity point maker.</p> <ul> <li>Just like the quantity maker, but conventionally with a <code>_pt</code> suffix to indicate that it makes   <code>QuantityPoint</code> instead.  You can call this like a function on arbitrary numeric types.  You   can also compose it with prefixes, or scale it with Magnitudes.</li> <li>If omitted: this is usually fine to omit: most Units are only used with <code>Quantity</code>, not   <code>QuantityPoint</code>.</li> </ul> </li> <li> <p>Unit symbol.</p> <ul> <li>This lets you create quantities of this unit by simply multiplying or dividing raw numbers.   You can also change the units of existing quantities in the same way.  See the docs for unit   symbols.</li> <li>If omitted: Users will either need to create their own symbols on the fly, or else spell   out the full name of the unit.</li> </ul> </li> </ol> <p>Note</p> <p>Not shown here: adding an <code>origin</code> member.  We skipped this because it is very rare.  It only has any effect at all for Units you plan to use with <code>QuantityPoint</code>, which is not the usual case.  Even among those units, only a small subset have a non-default origin.  The main examples are <code>Celsius</code> and <code>Fahrenheit</code>, and the library will provide those out of the box.</p>"},{"location":"howto/new-units/#unit-expressions","title":"Unit expressions","text":"<p>Above, we said to inherit your unit\u2019s strong type from the <code>decltype</code> of a unit expression. Recall the line from above:</p> <pre><code>struct Fathoms : decltype(Inches{} * mag&lt;72&gt;()) {\n//        Unit Expression ^^^^^^^^^^^^^^^^^^^^\n</code></pre> <p>Some users may be surprised that we recommend using <code>decltype</code> and instances, instead of just naming the type directly.  The reason we do is that in C++ code generally, instances are easier to compose than types.  This is especially true for units, which support a variety of operations: multiplying and dividing by other units, scaling by magnitudes, and even raising to rational powers.</p> <p>If we used types directly, users would need to learn obscure new traits, like <code>UnitProductT</code> for unit-unit products, and <code>ScaledUnit</code> for unit-magnitude products.  With instances, we can simply write <code>*</code> as we would for any other kind of instances \u2014 and this <code>*</code> covers both use cases! Wrapping the result in <code>decltype(...)</code> is a small price to pay for this familiarity and flexibility.</p> <p>Here are some example unit expressions we might reach for to define various common units:</p> <ul> <li>Newtons: <code>Kilo&lt;Grams&gt;{} * Meters{} / squared(Seconds{})</code></li> <li>Miles: <code>Feet{} * mag&lt;5280&gt;()</code></li> <li>Degrees: <code>Radians{} * Magnitude&lt;Pi&gt;{} / mag&lt;180&gt;()</code></li> </ul>"},{"location":"howto/new-units/#aliases-vs-strong-types-best-practices","title":"Aliases vs. strong types: best practices","text":"<p>A shorter method of defining units is as aliases for a compound unit.  For example:</p> <pre><code>using MilesPerHour = decltype(Miles{} / Hours{});\nconstexpr auto miles_per_hour = miles / hour;\n</code></pre> <p>We can use the alias, <code>MilesPerHour</code>, anywhere we\u2019d use a unit type.  And we can call the QuantityMaker, <code>miles_per_hour</code>, just as we would call <code>miles</code>.<sup>2</sup>    We even get an automatically generated unit label: <code>mi / h</code>.</p> <p>Despite this convenience, aliases aren\u2019t always the best choice.  Here\u2019s the best practices guidance to follow.</p> <ol> <li> <p>Use strong types for named units.</p> <ul> <li>Example: <code>Newtons</code>; <code>Fathoms</code></li> <li>Rationale: Strong types show up in compiler errors, making them easier to read.<ul> <li>Counterpoint: as seen below, this will reduce the ability to cancel out units.  For   example, <code>Meters{} * Hertz{}</code> will not be the same as <code>Meters{} / Seconds{}</code>; instead,   it will be a different-but-equivalent Unit.  Given the way we handle quantity-equivalent   Units, this will usually not be a problem, and we believe the value of seeing shorter,   more familiar names in the compiler errors outweighs this cost.</li> </ul> </li> </ul> </li> <li> <p>Use aliases for compound units with no special name.</p> <ul> <li>Example: <code>NewtonMeters</code>; <code>MilesPerHour</code>.  Both of these are better implemented as aliases   rather than strong types.</li> <li>Rationale: Keeping these as aliases increases support for cancellation: it enables the   library to notice that <code>MetersPerSecond{} * Seconds{}</code> is identical to <code>Meters{}</code>, not   merely quantity-equivalent.  This doesn\u2019t usually matter, but it can reduce exposure to   compiler errors in the (rare) situations where exact-type-equality matters (e.g., initializer   lists).</li> </ul> </li> </ol> <ol> <li> <p>Macros have long been considered contrary to C++ best practices.  If we\u2019re going to use one, especially in user-facing code, it needs to meet a very high bar.  Unit definition macros don\u2019t meet this bar.  They mostly exist to save typing.  But code is read far more often than written, and macros actually make the definitions harder to read and understand (because they use positional arguments, so the meaning of the parameters is unclear at the callsite).\u00a0\u21a9</p> </li> <li> <p>Note that we don\u2019t \u201cneed\u201d to define this.  We could write <code>(miles / hour)(65)</code>, and get exactly the same result as <code>miles_per_hour(65)</code>.  However, some users may prefer the latter syntax.\u00a0\u21a9</p> </li> </ol>"},{"location":"howto/interop/","title":"Inter-library Interoperation","text":"<p>This guide explains how to use Au\u2019s corresponding quantity machinery to set up minimum-friction interoperation between Au and some other C++ units library.  The main use case is for migrating either to or from Au.  Once you set this up, you will be able to pass Au\u2019s quantity types to APIs expecting equivalent types from the other library, and vice versa.  This flexibility will make that migration much easier, because it will let you migrate individual build targets without forcing you to upgrade all of their callers at the same time.</p> <p>Here are the steps involved.</p> <ol> <li>Define the equivalences.</li> <li>(Optional) Create a shim file.</li> </ol> <p>Warning</p> <p>In this generic guide, the details for each step will strongly depend on the details of the library you\u2019re using.  In each step, we will explain the abstract goals to achieve, and we\u2019ll show a concrete example of achieving them with one specific units library.</p> <p>We chose the nholthaus library for all our examples because it\u2019s very popular, and it illustrates the concepts nicely.  However, if you\u2019re actually using the nholthaus library, you do not need to follow this guide!  That\u2019s because we already did all of the hard work for you, and included nholthaus-specific migration machinery in the repository.  We have a separate, more specific how-to guide which shows you how to use it.</p>"},{"location":"howto/interop/#define-the-equivalences","title":"Define the equivalences","text":"<p>\u201cDefine the equivalences\u201d means to specify which types in the other units library are equivalent to which Au quantity types.  To do so, you\u2019ll create a new file where these definitions will live. We strongly recommend also creating a test file, and we\u2019ll assume for the rest of this guide that you have done so.</p> <p>If you\u2019re defining equivalence with an individual concrete type, the reference documentation will likely be sufficient.  However, establishing correspondence with another units library is more complicated, because you\u2019ll be defining equivalencies with a family of type templates.  This section explains how to manage that complexity effectively.</p>"},{"location":"howto/interop/#write-tests","title":"Write tests","text":"<p>The tests in the test file will be phrased directly in terms of the features we\u2019re trying to achieve.  In particular, our goal is for all of the following statements to be true:</p> <ol> <li> <p>An <code>as_quantity()</code> mapping exists for    the other library\u2019s type, and it returns the right kind of Au quantity.</p> </li> <li> <p>We can pass the other library\u2019s type to an API expecting the corresponding Au type.</p> </li> <li> <p>We can pass the Au type to an API expecting the other library\u2019s type.</p> <ul> <li>If we got the Au type from step 2, then this \u201cround trip\u201d conversion must be the identity.</li> </ul> </li> </ol> <p>You will probably be writing a lot of these test cases, so it\u2019s worth making a small utility that tests all three.  The precise format will depend on the details of the other library, but here\u2019s an example for the <code>nholthaus/units</code> library:</p> Example: testing nholthaus/units equivalencies <p>The Au repo includes ready-made equivalence definitions for the nholthaus/units library, as demonstrated in detail in our how-to guide for using them.  Those definitions include tests.  Here\u2019s how we wrote them.</p> <p>First, we make a templated utility that tests all three properties listed above:</p> <pre><code>template &lt;typename NholthausType, typename AuUnit&gt;\nvoid expect_equivalent(QuantityMaker&lt;AuUnit&gt; expected_au_unit) {\n    const auto original = NholthausType{1.2};\n    const auto equivalent_to_expected_au_unit = QuantityEquivalent(expected_au_unit(1.2));\n\n    // Check that an `as_quantity` mapping _exists_ for this nholthaus type, and that its result\n    // is quantity-equivalent to the given QuantityMaker applied to the same underlying value.\n    const auto converted_to_quantity = as_quantity(original);\n    EXPECT_THAT(converted_to_quantity, equivalent_to_expected_au_unit);\n\n    // Check that this nholthaus type is _implicitly_ convertible to its equivalent type, and\n    // that again, the result is quantity-equivalent to the given QuantityMaker applied to the\n    // same underlying value.\n    const decltype(converted_to_quantity) implicitly_converted_to_quantity = original;\n    EXPECT_THAT(implicitly_converted_to_quantity, equivalent_to_expected_au_unit);\n\n    // Check that the equivalent Quantity type can be _implicitly_ converted back to the\n    // original nholthaus type, and that this round trip is the identity.\n    const NholthausType round_trip = implicitly_converted_to_quantity;\n    EXPECT_EQ(round_trip, original);\n}\n</code></pre> <p>(In the above, note that <code>QuantityEquivalent</code> is a utility from the Au library.  It\u2019s found in <code>\"au/testing.hh\"</code>, which is available in our full installation but not in our single-file installation.  This matcher tests an object against the value in its constructor (here, <code>expected_au_unit(1.2)</code>).  It makes sure that their types are quantity-equivalent, and their values are equal.)</p> <p>Next, we write test cases which take advantage of this utility, such as this group.</p> <pre><code>TEST(NholthausTypes, MapsBaseUnitsOntoCorrectAuQuantityTypes) {\n    expect_equivalent&lt;::units::length::meter_t&gt;(meters);\n    expect_equivalent&lt;::units::mass::kilogram_t&gt;(kilo(grams));\n    expect_equivalent&lt;::units::time::second_t&gt;(seconds);\n    expect_equivalent&lt;::units::angle::radian_t&gt;(radians);\n    expect_equivalent&lt;::units::current::ampere_t&gt;(amperes);\n    expect_equivalent&lt;::units::temperature::kelvin_t&gt;(kelvins);\n    expect_equivalent&lt;::units::data::byte_t&gt;(bytes);\n}\n</code></pre> <p>Note how the utility makes these very easy to read.</p>"},{"location":"howto/interop/#implement-the-definitions","title":"Implement the definitions","text":"<p>Generally, writing an implementation that passes these unit tests includes:</p> <ol> <li> <p>Figuring out which template parameters are most relevant for the other library\u2019s types.</p> </li> <li> <p>Writing helpers that can extract the <code>Unit</code> and <code>Rep</code> information from these template parameters.</p> </li> <li> <p>Writing a partial specialization of <code>au::CorrespondingQuantity</code> using the template parameters    from the first step.</p> </li> </ol> <p>Again, the details will depend strongly on the details of the library you\u2019re working with, but here\u2019s an example using the nholthaus library:</p> Step 1: determine template parameters <p>The main user-facing types in the nholthaus library are based on the three-parameter <code>units::unit_t&lt;U, R, S&gt;</code> template.</p> <ul> <li><code>U</code> is the unit, a specialization of <code>units::unit&lt;...&gt;</code> (more on this later).</li> <li><code>R</code> is the Rep, just as in Au.</li> <li><code>S</code> is the \u201cscale\u201d.</li> </ul> <p>The point of <code>S</code> is to support non-linear \u201cunits\u201d, such as decibels.  Since Au doesn\u2019t support these as of the time of writing this guide (see #41), we don\u2019t need to let this vary: we can hardcode it as <code>units::linear_scale</code>.</p> <p><code>U</code> is based on the four-parameter <code>units::unit&lt;RationalScale, BaseUnit, PiPower, Offset&gt;</code> template.</p> <ul> <li><code>RationalScale</code> is a rational scale factor (say, 1000 for <code>kilometer_t</code>).</li> <li><code>BaseUnit</code> is the \u201cbase unit\u201d: it\u2019s the coherent (that is, unscaled) unit of the dimension we   want to represent.</li> <li><code>PiPower</code> is the \u201cpi power\u201d.  The overall unit is further rescaled by \\pi^\\text{PiPower} \u2014 an   ingenious solution that enables maximally accurate handling of degrees and radians, despite   the lack of full-fledged magnitudes.</li> <li><code>Offset</code> is the linear offset of this unit, which enables certain affine space   type use cases such as temperatures (although   with less expressivity than a full quantity point   solution).</li> </ul> <p>If <code>Offset</code> is anything other than zero, there\u2019s a good chance our use case needs quantity point, not just quantity.  This makes automatic conversions risky, so we\u2019ll opt out of them in these use cases, by hardcoding the <code>Offset</code> parameter to <code>std::ratio&lt;0&gt;</code> (that is, \u201cno offset\u201d).</p> <p>The other template parameters are all necessary.  <code>RationalScale</code> and <code>PiPower</code> combine together to represent the magnitude of the Au unit type.  <code>BaseUnit</code> is what tells us which dimension to use, and which unit of that dimension corresponds to a scale factor of 1.</p> <p>Thus, our final set of template parameters includes <code>R</code>, <code>RationalScale</code>, <code>BaseUnit</code>, and <code>PiPower</code>.</p> Step 2: write utilities to compute <code>Unit</code> and <code>Rep</code> <p>The template parameters in the previous section \u2014 namely, <code>R</code>, <code>RationalScale</code>, <code>BaseUnit</code>, and <code>PiPower</code> \u2014 will be the inputs for these utilities.  The ultimate outputs will be <code>Unit</code> and <code>Rep</code>.  (Of course, we\u2019ll often want to write intermediate utilities that facilitate these final answers.)</p> <p>In our case, <code>Rep</code> is very easy: it\u2019s exactly equivalent to <code>R</code>.</p> <p><code>Unit</code> is much more involved, but we can break it into two main steps:</p> <ol> <li>Find the Au unit corresponding to <code>BaseUnit</code>.</li> <li>Find the Au magnitude corresponding to <code>RationalScale</code> and <code>PiPower</code>.</li> </ol> <p>Once we have these, we can simply multiply this Au unit by this Au magnitude.</p> <p>Let\u2019s call our top-level utility <code>AuUnit</code>.  If <code>NholthausUnit</code> is some specialization of <code>units::unit&lt;...&gt;</code>, then our goal is to be able to write:</p> <pre><code>using Unit = typename AuUnit&lt;NholthausUnit&gt;::type;\n</code></pre> <p>To save space, we\u2019ll simply describe any utilities more low-level than <code>AuUnit</code>, omitting their implementations.  Of course, full implementations can be found in our ready-made nholthaus conversion file.</p> <p>For the base unit, we know that nholthaus represents it as a set of rational exponents of units of base dimensions. These are the seven base SI units \u2014 meters, kilograms, and so on \u2014 plus radians and bytes. Therefore, let\u2019s assume we have one \u201cextractor\u201d utility for each of these.  For example, <code>MeterExpT&lt;NholthausUnit&gt;</code> gives the exponent (as a <code>std::ratio</code> specialization) for <code>Meters</code> in <code>NholthausUnit</code>.  If we write a similar utility for each base dimension, we can fully compute the base unit.</p> <p>For the magnitude, we can write a utility, <code>NholthausUnitMag&lt;NholthausUnit&gt;</code>.  This will make a separate magnitude for the <code>RationalScale</code> and <code>PiPower</code> that went into <code>NholthausUnit</code>, and simply multiply them.</p> <p>With these in hand, we can complete our <code>AuUnit</code> definition:</p> <pre><code>template &lt;class NholthausUnit&gt;\nstruct AuUnit {\n    using NU = NholthausUnit;\n\n    using type = decltype(\n        UnitPowerT&lt;Meters, MeterExpT&lt;NU&gt;::num, MeterExpT&lt;NU&gt;::den&gt;{} *\n        UnitPowerT&lt;Kilo&lt;Grams&gt;, KilogramExpT&lt;NU&gt;::num, KilogramExpT&lt;NU&gt;::den&gt;{} *\n        UnitPowerT&lt;Seconds, SecondExpT&lt;NU&gt;::num, SecondExpT&lt;NU&gt;::den&gt;{} *\n        UnitPowerT&lt;Radians, RadianExpT&lt;NU&gt;::num, RadianExpT&lt;NU&gt;::den&gt;{} *\n        UnitPowerT&lt;Amperes, AmpExpT&lt;NU&gt;::num, AmpExpT&lt;NU&gt;::den&gt;{} *\n        UnitPowerT&lt;Kelvins, KelvinExpT&lt;NU&gt;::num, KelvinExpT&lt;NU&gt;::den&gt;{} *\n        UnitPowerT&lt;Bytes, ByteExpT&lt;NU&gt;::num, ByteExpT&lt;NU&gt;::den&gt;{} *\n        UnitPowerT&lt;Candelas, CandelaExpT&lt;NU&gt;::num, CandelaExpT&lt;NU&gt;::den&gt;{} *\n        UnitPowerT&lt;Moles, MoleExpT&lt;NU&gt;::num, MoleExpT&lt;NU&gt;::den&gt;{} *\n        NholthausUnitMagT&lt;NU&gt;{});\n};\n</code></pre> <p>This will make it very easy to compute <code>Unit</code>, and we\u2019re ready to define the equivalences.</p> Step 3: specialize <code>au::CorrespondingQuantity</code> <p>At this point, we are ready to assemble our <code>CorrespondingQuantity</code> specialization.  This is what will enable the bidirectional conversions.  Here are the steps.</p> <ol> <li>Use the same template parameters you determined in step 1.</li> <li>Fill in <code>Unit</code> and <code>Rep</code> using the utilities from step 2.</li> <li>Define <code>extract_value()</code> and <code>construct_from_value()</code> to enable conversions.</li> </ol> <p>Here is a fully working version using our nholthaus example.</p> <pre><code>namespace au {\n\ntemplate &lt;class R, class RationalScale, class BaseUnit, class PiPower&gt;\nstruct CorrespondingQuantity&lt;\n    units::unit_t&lt;units::unit&lt;RationalScale, BaseUnit, PiPower, std::ratio&lt;0&gt;&gt;,\n                  R,\n                  units::linear_scale&gt;&gt; {\n    // NOTE: our \"real\" implementation has a few utilities to avoid this repetition.\n    using NholthausUnit = units::unit&lt;RationalScale, BaseUnit, PiPower, std::ratio&lt;0&gt;&gt;;\n    using NholthausType = units::unit_t&lt;NholthausUnit, R, units::linear_scale&gt;;\n\n    using Unit = typename AuUnit&lt;NholthausUnit&gt;::type;\n    using Rep = R;\n\n    static constexpr Rep extract_value(NholthausType d) { return d.template to&lt;Rep&gt;(); }\n    static constexpr NholthausType construct_from_value(Rep x) { return NholthausType{x}; }\n};\n\n}  // namespace au\n</code></pre> <p>If this definition is visible, you will be able to pass, say, <code>units::length::meter_t</code> instances to any API expecting <code>au::QuantityD&lt;au::Meters&gt;</code>, and vice versa!</p>"},{"location":"howto/interop/#optional-create-a-shim-file","title":"(Optional) Create a shim file","text":"<p>A migration involves two libraries.  Let\u2019s say the \u201coriginal\u201d library is the one you\u2019re migrating from, and the \u201ctarget\u201d library is the one you\u2019re migrating to.  If your original library has a single-file delivery, you can make your migration even easier.  You can make it so that anyone who includes the original automatically gets the relevant part of the target library, and all of the conversion machinery described on this page!</p> <p>Let\u2019s suppose that the single file which holds the original library is called <code>\"third_party/orig/units.hh\"</code>.  This is the file that all of your users include.  Let\u2019s also suppose that your definitions from the previous section live in the file <code>\"third_party/orig/au_interop.hh\"</code>. To give your users automatic access to these interoperability definitions, here are the steps.</p> <ol> <li>Rename <code>\"third_party/orig/units.hh\"</code> to <code>\"third_party/orig/units_impl.hh\"</code>.</li> <li>Update the include inside of <code>au_interop.hh</code> to point to <code>units_impl.hh</code>.</li> <li>Make a new <code>\"third_party/orig/units.hh\"</code> file, with the following contents:</li> </ol> <pre><code>#pragma once\n\n#include \"third_party/orig/au_interop.hh\"\n#include \"third_party/orig/units_impl.hh\"\n</code></pre> <p>If your original library doesn\u2019t use single-file delivery, there is no single place to put this shim.  In that case, you could consider making an individual shim for every include file, which defines only the conversion machinery that\u2019s relevant for that file, although this would be labor intensive.  The alternative is of course to tell users to include this machinery directly, instead of using shims.</p>"},{"location":"howto/interop/nholthaus/","title":"<code>nholthaus/units</code> Interoperation","text":"<p>The Au repository includes ready-made conversion machinery for the nholthaus/units library.  If you\u2019re migrating to or from this library, you don\u2019t need to use our more general guide.  Instead, you can follow this guide, which is both more specific and less labor-intensive.</p> <p>Once you\u2019re finished with this guide, you\u2019ll be able to pass any nholthaus type to an API expecting an equivalent Au quantity type, and vice versa!</p>"},{"location":"howto/interop/nholthaus/#step-1-add-the-file-to-your-project","title":"Step 1: Add the file to your project","text":"<p>The goal of this step is to make sure the file with the conversion machinery is available in your project, and to know its include path.</p> <p>This will depend on which installation method you used: single-file, or full install.</p> <ul> <li> <p>Full Install:  In this case, the file is already available.  Assuming <code>au/</code> is the root of   your Au includes, the include path will be <code>\"au/compatibility/nholthaus_units.hh\"</code>.</p> </li> <li> <p>Single-file Install:  Copy the file <code>compatibility/nholthaus_units.hh</code> from the Au repository   into a suitable location in your project.  Make a note of the include path.</p> </li> </ul>"},{"location":"howto/interop/nholthaus/#step-2-create-a-shim","title":"Step 2: Create a shim","text":"<p>The file we provide, <code>compatibility/nholthaus_units.hh</code>, is written in a particular and unusual way: it doesn\u2019t have any explicit dependencies on either Au or nholthaus units.  This is because we can\u2019t know how you\u2019ve included either library in your project.</p> <p>One consequence of this is that include order matters: this file must be included after both the Au and nholthaus libraries.  In general, include order dependence is very fragile and should be avoided.  However, it can be done safely if we confine this dependence to a single file \u2014 the shim \u2014 and provide only that file to our end users.  This shim must do the following three things, in this order.</p> <ol> <li>Include the nholthaus-relevant parts of Au (in whatever manner is appropriate for your project).</li> <li>Include the nholthaus units library (in whatever manner is appropriate for your project).</li> <li>Include your copy of <code>compatibility/nholthaus_units.hh</code>, after every other file.<ul> <li>(The include path comes from Step 1 above.)</li> </ul> </li> </ol> <p>We have provided a self-explaining example shim to illustrate this procedure.  Note that it includes examples of comments to disable and re-enable clang-format support, because without them, some projects that use clang-format might automatically reorder the headers.</p> <p>Tip</p> <p>Any users who include this file will get the full nholthaus library for free, along with the conversion machinery.  If you\u2019re migrating from nholthaus to Au, you may want to consider renaming your original nholthaus file, and giving this shim its original name!  That way, it will be as easy as possible for your nholthaus users to start using the new Au constructs.</p>"},{"location":"howto/interop/nholthaus/#outcome-and-limitations","title":"Outcome and limitations","text":"<p>Any user who includes the shim created in Step 2 will have low-friction interoperability between Au and the nholthaus library, for a wide variety of units.  Each library\u2019s types will safely and automatically convert to their counterparts in the other library, even across API boundaries!</p> <p>Here are the main known limitations.</p> <ol> <li> <p>We don\u2019t support automatic conversion with any nholthaus type with a nonzero \u201clinear offset\u201d.    This mainly affects temperatures in Celsius and Fahrenheit.  The reason is that the nholthaus    types for these units act like a mosaic of <code>au::Quantity</code> and <code>au::QuantityPoint</code> features, and    we can\u2019t guess which one we should convert to.  (Even if we could, Au does not currently provide    conversion machinery for <code>au::QuantityPoint</code>.)</p> </li> <li> <p>We don\u2019t support converting non-linear units, such as decibels, because we haven\u2019t yet figured    out how to implement them in Au (see #41).    Thus, there\u2019s nothing in Au to convert them to.</p> </li> </ol>"},{"location":"reference/","title":"Reference Docs","text":"<p>This section contains detailed reference documentation on <code>Quantity</code>, <code>QuantityPoint</code>, units, dimensions, magnitudes, and other core library abstractions.  The main folder is reserved for things that end users will routinely interact with.  Implementation details will be documented in a <code>detail</code> sub-folder.</p> <p>Here\u2019s a guide to the main reference pages.</p> <ul> <li> <p><code>Quantity</code>.  This is the main type you\u2019ll use to replace raw numeric types.   It acts like a numeric type, but it keeps track of its units.</p> <ul> <li><code>QuantityPoint</code>.  Similar to <code>Quantity</code>, but for modeling affine   space types.  This means you can subtract two   <code>QuantityPoint</code>s, and you\u2019ll get a <code>Quantity</code> (just like subtracting two points gives   a displacement).  Practically speaking, this is essential for dealing with temperatures,   and useful for a couple other dimensions such as pressures and distances.</li> </ul> </li> <li> <p><code>Constant</code>.  A constant quantity which is known at compile time, and   represented by a symbol.  Supports exact symbolic arithmetic at compile time, and a perfect   conversion policy to <code>Quantity</code> types.</p> </li> <li> <p><code>Unit</code>.  A type which represents a unit of measure.</p> </li> <li> <p><code>Magnitude</code>.  A special kind of compile-time number, which we use to   represent ratios between pairs of units.  Can handle many challenging use cases which <code>std::ratio</code>   can\u2019t, and which are necessary for units libraries \u2014 such as irrational numbers, or extremely   large or small numbers.</p> </li> <li> <p><code>Prefix</code>.  A term that can be applied to the beginning of a unit, to make a new   unit with a specified relative size.  For example, <code>centi</code> is a prefix whose relative magnitude   is 1/100, and a <code>centi(meter)</code> is a new unit which is one one-hundredth of a <code>meter</code>.</p> </li> <li> <p><code>Math functions</code>.  We provide many common mathematical functions out of the box.</p> </li> </ul> <p>See the sidebar for the complete list of pages.</p>"},{"location":"reference/constant/","title":"Constant","text":"<p><code>Constant</code> is a family of template types, each of which represents a single specific quantity value.</p> <p>Recall that the usual way to represent quantity values is with a <code>Quantity&lt;Unit, Rep&gt;</code> type. This holds a numeric variable of type <code>Rep</code> inside, letting it represent many possible quantity values. By contrast, <code>Constant</code> is an empty class and has no \u201crep\u201d: the single value it can represent is fully encoded in its type.  This makes it an example of a monovalue type.</p> <p>Because the value is always fully known at compile time, we do not need to use a heuristic like the overflow safety surface to determine which conversions are allowed.  Instead, we can achieve a perfect conversion policy: we allow converting to any <code>Quantity</code> that can represent the value exactly, and disallow all other conversions.</p> <p>The main use of <code>Constant</code> is to multiply and divide raw numbers or <code>Quantity</code> values.  When we do this, the constant is applied symbolically, and affects the units of the resulting quantity. For example, multiplying a duration in seconds by a constant representing the speed of light produces a length, measured in units of light-seconds.  Notably, the underlying stored numeric value does not change: whether a duration of <code>5</code> seconds, or a length of <code>5</code> light-seconds, we still store <code>5</code> under the hood.</p> <p>This approach means that if subsequent operations cancel out the constant, this cancellation is both exact and has zero runtime cost.</p>"},{"location":"reference/constant/#constructing-constant","title":"Constructing <code>Constant</code>","text":"<p><code>Constant</code> encodes all information about the value in its type.  Moreover, it has only a single template parameter, which is a unit.  Therefore, the first step is to encode your quantity as a unit \u2014 that is, to define the unit \u201cU\u201d such that your quantity has a value of \u201c1 U\u201d.</p> <p>To do this, follow the usual instructions for creating new units.  Note that you can use a much simpler definition that omits most of the optional features.  The only important ones are those labeled <code>[1]</code> (the strong type definition) and <code>[2]</code> (the unit label).</p> <p>Having defined your unit, you can pass an instance to the <code>make_constant</code> function.  If the unit you defined above is called <code>YourUnits</code>, and the constant is called <code>YOUR_CONSTANT</code>, then the constant definition will look like this:</p> <pre><code>constexpr auto YOUR_CONSTANT = make_constant(YourUnits{});\n</code></pre> <p>Finally, note that the argument to <code>make_constant()</code> is a unit slot, so you can pass \u201cunit-like\u201d alternatives such as <code>QuantityMaker</code> or <code>SymbolFor</code> instances as well.</p> Full worked example: speed of light <p>Let\u2019s look at an example of defining a constant for the speed of light.  Both the name of the instance and the label will be <code>c</code>.</p> C++14C++17 or later <pre><code>// In .hh file:\nstruct SpeedOfLight : decltype(Meters{} / Seconds{} * mag&lt;299'792'458&gt;()) {\n    static constexpr const char label[] = \"c\";\n};\n\nconstexpr auto c = make_constant(SpeedOfLight{});\n</code></pre> <pre><code>// In .cc file:\nconstexpr const char SpeedOfLight::label[];\n</code></pre> <pre><code>// In .hh file:\nstruct SpeedOfLight : decltype(Meters{} / Seconds{} * mag&lt;299'792'458&gt;()) {\n    static constexpr inline const char label[] = \"c\";\n};\n\nconstexpr auto c = make_constant(SpeedOfLight{});\n</code></pre>"},{"location":"reference/constant/#ad-hoc-constants","title":"Ad hoc constants","text":"<p>You can obtain many of the benefits of <code>Constant</code> even if you don\u2019t formally define a new unit. Because <code>make_constant</code> has a unit slot API, you can pass an ad hoc expression to it.  For example:</p> <pre><code>constexpr auto c = make_constant(meters / second * mag&lt;299'792'458&gt;());\n</code></pre> <p>The main advantage of doing this is its conciseness: the constant definition is a single, readable line.  The built constant also has all of the multiplication and division operators types that <code>Constant</code> supports, as well as its perfect conversion policy to any <code>Quantity</code> type.</p> <p>The only disadvantage is the missing label, which will make printed quantities hard to understand because the constant will be represented as <code>[UNLABELED_UNIT]</code> in the compound label.</p> <p>If the constant is used in multiple translation units, or if it leads to values that are printed out, we believe this disadvantage outweighs the benefits, and we recommend a full definition with a new unit. Otherwise, the ad hoc constant approach may be called for.</p>"},{"location":"reference/constant/#constant-and-unit-slots","title":"<code>Constant</code> and unit slots","text":"<p><code>Constant</code> can be passed to any API that takes a unit slot.</p>"},{"location":"reference/constant/#converting-to-quantity","title":"Converting to <code>Quantity</code>","text":"<p><code>Constant</code> can be converted to any <code>Quantity</code> type of the same dimension.</p> <p>By default, this conversion policy is perfect.  This means that it permits converting to any <code>Quantity</code> that can represent the value exactly, and disallows all other conversions.  Users can also override this policy by choosing the \u201ccoerce\u201d variant of any API (say, using <code>.coerce_as()</code> instead of <code>.as()</code>).</p> <p>Finally, it\u2019s important to appreciate that <code>Constant</code> has no rep, no underlying numeric type. Therefore, every <code>Quantity</code> conversion API requires an explicit template parameter to specify the desired rep.</p>"},{"location":"reference/constant/#ast","title":"<code>.as&lt;T&gt;()</code>","text":"<p>This function expresses the constant as a <code>Quantity</code> in \u201cunits of this constant\u201d.  Therefore, the underlying stored value will be <code>T{1}</code>, and the rep will be <code>T</code>.</p>"},{"location":"reference/constant/#as-T-unit","title":"<code>.as&lt;T&gt;(unit)</code>","text":"<p>This function expresses the constant as a <code>Quantity</code> in the requested unit, using a rep of <code>T</code>.  It has a perfect conversion policy, which means that it compiles if and only if the constant\u2019s value in the requested unit can be exactly represented in the type <code>T</code>.</p> <p>The argument <code>unit</code> is a unit slot API, so it accepts a unit instance, quantity maker instance, or any other instance compatible with a unit slot.</p>"},{"location":"reference/constant/#coerce_astunit","title":"<code>.coerce_as&lt;T&gt;(unit)</code>","text":"<p>This function expresses the constant as a <code>Quantity</code> in the requested unit, using a rep of <code>T</code>.  It is similar to <code>.as&lt;T&gt;(unit)</code>, except that it will ignore the safety checks that prevent truncation and overflow.</p> <p>Warning</p> <p>Because <code>.as&lt;T&gt;(unit)</code> has a perfect conversion policy, we know that this function either produces the exact same result (in which case you could simply call <code>.as&lt;T&gt;(unit)</code>), or it produces a result which is guaranteed to be lossy.  Therefore, be very judicious in using this function.</p>"},{"location":"reference/constant/#in-T-unit","title":"<code>.in&lt;T&gt;(unit)</code>","text":"<p>This function produces a raw numeric value, of type <code>T</code>, holding the value of the constant in the requested unit.  It has a perfect conversion policy, which means that it compiles if and only if the constant\u2019s value in the requested unit can be exactly represented in the type <code>T</code>.</p> <p>The argument <code>unit</code> is a unit slot API, so it accepts a unit instance, quantity maker instance, or any other instance compatible with a unit slot.</p>"},{"location":"reference/constant/#coerce_intunit","title":"<code>.coerce_in&lt;T&gt;(unit)</code>","text":"<p>This function produces a raw numeric value, of type <code>T</code>, holding the value of the constant in the requested unit.  It is similar to <code>.in&lt;T&gt;(unit)</code>, except that it will ignore the safety checks that prevent truncation and overflow.</p> <p>Warning</p> <p>Because <code>.in&lt;T&gt;(unit)</code> has a perfect conversion policy, we know that this function either produces the exact same result (in which case you could simply call <code>.in&lt;T&gt;(unit)</code>), or it produces a result which is guaranteed to be lossy.  Therefore, be very judicious in using this function.</p>"},{"location":"reference/constant/#implicit-quantity-conversion","title":"Implicit <code>Quantity</code> conversion","text":"<p><code>Constant</code> will implicitly convert to any <code>Quantity</code> type which passes the safety checks on truncation and overflow.  Essentially: any time <code>.as&lt;T&gt;(unit)</code> produces a result, that same result can be obtained via implicit conversion.</p> <p>This provides great flexibility and confidence in passing <code>Constant</code> values to APIs that take <code>Quantity</code>.</p> <p>Note</p> <p>The fact that <code>Constant</code> has a perfect conversion policy means that we can use it with APIs where the corresponding <code>Quantity</code> would not work, because <code>Quantity</code> is forced to use the overflow safety surface, which is a more conservative heuristic.</p> <p>For example, suppose you have an API accepting <code>Quantity&lt;UnitQuotientT&lt;Meters, Seconds&gt;, int&gt;</code>, and a constant <code>c</code> representing the speed of light.</p> <p>You will be able to pass <code>c</code> to this API, because the constant-to-quantity conversion operation knows the exact value at compile time, and can verify that it fits in an <code>int</code>.</p> <p>By contrast, you would not be able to pass <code>c.as&lt;int&gt;()</code> (which is a <code>Quantity</code>).  Even though it would work for this specific value (which is <code>1</code>), this quantity-to-quantity conversion is too dangerous for <code>int</code> in general.</p>"},{"location":"reference/constant/#operations","title":"Operations","text":"<p>Each operation with a <code>Constant</code> consists in multiplying or dividing with some other family of types.</p>"},{"location":"reference/constant/#raw-numeric-type-t","title":"Raw numeric type <code>T</code>","text":"<p>Multiplying or dividing <code>Constant&lt;Unit&gt;</code> with a raw numeric type <code>T</code> produces a <code>Quantity</code> whose rep is <code>T</code>, and whose unit is derived from <code>Unit</code>.</p> <p>In the following table, we will use <code>x</code> to represent the value that was stored in the input of type <code>T</code>.</p> Operation Resulting Type Underlying Value Notes <code>Constant&lt;Unit&gt; * T</code> <code>Quantity&lt;Unit, T&gt;</code> <code>x</code> <code>Constant&lt;Unit&gt; / T</code> <code>Quantity&lt;Unit, T&gt;</code> <code>T{1} / x</code> Disallowed for integral <code>T</code> <code>T * Constant&lt;Unit&gt;</code> <code>Quantity&lt;Unit, T&gt;</code> <code>x</code> <code>T / Constant&lt;Unit&gt;</code> <code>Quantity&lt;UnitInverseT&lt;Unit&gt;, T&gt;</code> <code>x</code>"},{"location":"reference/constant/#quantityu-r","title":"<code>Quantity&lt;U, R&gt;</code>","text":"<p>Multiplying or dividing <code>Constant&lt;Unit&gt;</code> with a <code>Quantity&lt;U, R&gt;</code> produces a <code>Quantity</code> whose rep is <code>R</code>, and whose unit is derived from <code>Unit</code> and <code>U</code>.</p> <p>In the following table, we will use <code>x</code> to represent the underlying value in the input quantity \u2014 that is, if the input quantity was <code>q</code>, then <code>x</code> is <code>q.in(U{})</code>.</p> Operation Resulting Type Underlying Value Notes <code>Constant&lt;Unit&gt; * Quantity&lt;U, R&gt;</code> <code>Quantity&lt;UnitProductT&lt;Unit, U&gt;, R&gt;</code> <code>x</code> <code>Constant&lt;Unit&gt; / Quantity&lt;U, R&gt;</code> <code>Quantity&lt;UnitQuotientT&lt;Unit, U&gt;, R&gt;</code> <code>R{1} / x</code> Disallowed for integral <code>R</code> <code>Quantity&lt;U, R&gt; * Constant&lt;Unit&gt;</code> <code>Quantity&lt;UnitProductT&lt;U, Unit&gt;, R&gt;</code> <code>x</code> <code>Quantity&lt;U, R&gt; / Constant&lt;Unit&gt;</code> <code>Quantity&lt;UnitQuotientT&lt;U, Unit&gt;, R&gt;</code> <code>x</code>"},{"location":"reference/constant/#constantu","title":"<code>Constant&lt;U&gt;</code>","text":"<p>Constants compose: the product or quotient of two <code>Constant</code> instances is a new <code>Constant</code> instance.</p> Operation Resulting Type <code>Constant&lt;Unit&gt; * Constant&lt;U&gt;</code> <code>Constant&lt;UnitProductT&lt;Unit, U&gt;&gt;</code> <code>Constant&lt;Unit&gt; / Constant&lt;U&gt;</code> <code>Constant&lt;UnitQuotientT&lt;Unit, U&gt;&gt;</code>"},{"location":"reference/constant/#quantitymakeru","title":"<code>QuantityMaker&lt;U&gt;</code>","text":"<p>Multiplying or dividing <code>Constant&lt;Unit&gt;</code> with a <code>QuantityMaker&lt;U&gt;</code> produces a new <code>QuantityMaker</code> whose unit is derived from <code>Unit</code> and <code>U</code>.</p> Operation Resulting Type <code>Constant&lt;Unit&gt; * QuantityMaker&lt;U&gt;</code> <code>QuantityMaker&lt;UnitProductT&lt;Unit, U&gt;&gt;</code> <code>Constant&lt;Unit&gt; / QuantityMaker&lt;U&gt;</code> <code>QuantityMaker&lt;UnitQuotientT&lt;Unit, U&gt;&gt;</code> <code>QuantityMaker&lt;U&gt; * Constant&lt;Unit&gt;</code> <code>QuantityMaker&lt;UnitProductT&lt;U, Unit&gt;&gt;</code> <code>QuantityMaker&lt;U&gt; / Constant&lt;Unit&gt;</code> <code>QuantityMaker&lt;UnitQuotientT&lt;U, Unit&gt;&gt;</code>"},{"location":"reference/constant/#singularnameforu","title":"<code>SingularNameFor&lt;U&gt;</code>","text":"<p>Multiplying or dividing <code>Constant&lt;Unit&gt;</code> with a <code>SingularNameFor&lt;U&gt;</code> produces a new <code>SingularNameFor</code> whose unit is derived from <code>Unit</code> and <code>U</code>.</p> Operation Resulting Type <code>Constant&lt;Unit&gt; * SingularNameFor&lt;U&gt;</code> <code>SingularNameFor&lt;UnitProductT&lt;Unit, U&gt;&gt;</code> <code>Constant&lt;Unit&gt; / SingularNameFor&lt;U&gt;</code> <code>SingularNameFor&lt;UnitQuotientT&lt;Unit, U&gt;&gt;</code> <code>SingularNameFor&lt;U&gt; * Constant&lt;Unit&gt;</code> <code>SingularNameFor&lt;UnitProductT&lt;U, Unit&gt;&gt;</code> <code>SingularNameFor&lt;U&gt; / Constant&lt;Unit&gt;</code> <code>SingularNameFor&lt;UnitQuotientT&lt;U, Unit&gt;&gt;</code>"},{"location":"reference/constant/#magnitudebps","title":"<code>Magnitude&lt;BPs...&gt;</code>","text":"<p>Multiplying or dividing <code>Constant&lt;Unit&gt;</code> with a <code>Magnitude</code> produces a new <code>Constant</code> which is scaled by that magnitude.</p> <p>In the following table, let <code>m</code> be an instance of <code>Magnitude&lt;BPs...&gt;</code>.</p> Operation Resulting Type <code>Constant&lt;Unit&gt; * Magnitude&lt;BPs...&gt;</code> <code>Constant&lt;decltype(Unit{} * m)&gt;</code> <code>Constant&lt;Unit&gt; / Magnitude&lt;BPs...&gt;</code> <code>Constant&lt;decltype(Unit{} / m)&gt;</code> <code>Magnitude&lt;BPs...&gt; * Constant&lt;Unit&gt;</code> <code>Constant&lt;decltype(Unit{} * m)&gt;</code> <code>Magnitude&lt;BPs...&gt; / Constant&lt;Unit&gt;</code> <code>Constant&lt;decltype(UnitInverseT&lt;Unit&gt;{} * m)&gt;</code>"},{"location":"reference/constant/#quantitypointmakeru-deleted","title":"<code>QuantityPointMaker&lt;U&gt;</code> (deleted)","text":"<p>Multiplying or dividing <code>Constant&lt;Unit&gt;</code> with a <code>QuantityPointMaker&lt;U&gt;</code> is explicitly deleted, because quantity points do not support multiplication.</p>"},{"location":"reference/constant/#quantitypointu-r-deleted","title":"<code>QuantityPoint&lt;U, R&gt;</code> (deleted)","text":"<p>Multiplying or dividing <code>Constant&lt;Unit&gt;</code> with a <code>QuantityPoint&lt;U, R&gt;</code> is explicitly deleted, because quantity points do not support multiplication.</p>"},{"location":"reference/corresponding_quantity/","title":"Corresponding Quantity","text":"<p>Sometimes, a type <code>T</code> may be exactly \u201cmorally equivalent\u201d to a specific <code>Quantity</code> specialization. If <code>T</code> stores a value in an underlying type, <code>Rep</code>, and that value represents a quantity whose units are quantity-equivalent to <code>Unit</code>, then there\u2019s no danger in converting between <code>T</code> and <code>Quantity&lt;Unit, Rep&gt;</code>, and it would be convenient to make this as easy as possible.</p> <p>The <code>CorrespondingQuantity&lt;T&gt;</code> type trait makes this possible.  When this trait is specialized for a type <code>T</code>, users can add conversions in either or both directions.  These conversions will allow <code>T</code> to participate in the usual <code>Quantity</code>-to-<code>Quantity</code> implicit conversions as if it were its corresponding quantity type.</p>"},{"location":"reference/corresponding_quantity/#how-to-specialize","title":"How to specialize","text":"<p>A valid specialization of <code>CorrespondingQuantity</code> must have two type traits:</p> <ul> <li><code>Unit</code> is the unit type for the units of <code>T</code>.</li> <li><code>Rep</code> is the underlying storage type in <code>T</code>.</li> </ul> <p>To be useful, it should also have at least one of the conversions defined in the next section.</p>"},{"location":"reference/corresponding_quantity/#conversions","title":"Conversions","text":"<p>When this relationship exists, it means that <code>T</code> is \u201cmorally equivalent\u201d to its corresponding quantity type.  We trust <code>T</code> to hold its information as carefully as our <code>Quantity</code> type does. Therefore, we enable implicit conversions.</p>"},{"location":"reference/corresponding_quantity/#t-to-quantity","title":"From <code>T</code> to <code>Quantity</code>","text":"<p>To enable implicit conversions from <code>T</code> to its corresponding quantity <code>Quantity&lt;Unit, Rep&gt;</code>, define a static member function with signature <code>Rep extract_value(T)</code>, as in the following example.</p> Example of setting up implicit conversion from <code>T</code> to <code>Quantity</code> <p>Suppose we have a type <code>MyMeters</code>, whose member <code>int value</code> represents a length in meters.  We could set up implicit conversions from <code>MyMeters</code> to <code>Quantity&lt;Meters, int&gt;</code> like so:</p> <pre><code>template&lt;&gt;\nstruct CorrespondingQuantity&lt;MyMeters&gt; {\n    using Unit = Meters;\n    using Rep = int;\n\n    static Rep extract_value(MyMeters x) { return x.value; }\n};\n</code></pre> <p>Recall that the custom type <code>T</code> is considered to be fully equivalent to its corresponding quantity <code>Q</code>.  This means that it will also automatically convert to any <code>Quantity</code> which <code>Q</code> converts to. See the following example.</p> Example of \u2018two-hop\u2019 conversion, continued from above <pre><code>QuantityD&lt;Milli&lt;Meters&gt;&gt; x = MyMeters{3};\n</code></pre> <p>Here we have a \u201ctwo-hop\u201d conversion.  <code>MyMeters{3}</code> is treated as equivalent to a <code>Quantity&lt;Meters, int&gt;</code> holding a <code>3</code>.  This, in turn, would safely and implicitly convert to a <code>QuantityD&lt;Milli&lt;Meters&gt;&gt;</code>.  Therefore, we permit the implicit conversion in a single step, directly from <code>MyMeters{3}</code>.</p> <p>The final result would be <code>milli(meters)(3000.0)</code>.</p>"},{"location":"reference/corresponding_quantity/#from-quantity-to-t","title":"From <code>Quantity</code> to <code>T</code>","text":"<p>To enable implicit conversions from the corresponding quantity <code>Quantity&lt;Unit, Rep&gt;</code> of a type <code>T</code>, to <code>T</code> itself, define a static member function with signature <code>T construct_from_value(Rep)</code>, as in the following example.</p> Example of setting up implicit conversion from <code>Quantity</code> to <code>T</code> <p>Suppose we have a type <code>MyDegrees</code>, whose member <code>float value</code> represents an angle in degrees. We could set up implicit conversions from <code>MyDegrees</code> to <code>Quantity&lt;Degrees, float&gt;</code> like so:</p> <pre><code>template&lt;&gt;\nstruct CorrespondingQuantity&lt;MyDegrees&gt; {\n    using Unit = Degrees;\n    using Rep = float;\n\n    static MyDegrees construct_from_value(float x) { return MyDegrees{x}; }\n};\n</code></pre> <p>Recall that the custom type <code>T</code> is considered to be fully equivalent to its corresponding quantity <code>Q</code>.  This means that any <code>Quantity</code> which converts to <code>Q</code> will also convert to <code>T</code>.  See the following example.</p> Example of \u2018two-hop\u2019 conversion, continued from above <pre><code>MyDegrees angle = radians(get_value&lt;double&gt;(Magnitude&lt;Pi&gt;{} / mag&lt;2&gt;()));\n</code></pre> <p>Here we have a \u201ctwo-hop\u201d conversion.  The corresponding quantity for <code>MyDegrees</code> is <code>Quantity&lt;Degrees, float&gt;</code>.  This, in turn, would be safely and implicitly constructible from a <code>Quantity&lt;Radians, double&gt;</code>.  Therefore, we also permit <code>MyDegrees</code> to be constructed from this <code>Quantity&lt;Radians, double&gt;</code>.</p> <p>The final result would be <code>MyDegrees{90.0f}</code>, within floating point rounding error.</p>"},{"location":"reference/corresponding_quantity/#as-quantity","title":"<code>as_quantity()</code>","text":"<p>The <code>as_quantity()</code> function converts any type to an instance of its corresponding <code>Quantity</code>, as long as this direction of conversion has been set up.  This concise, readable utility handles any cases where the implicit conversion is not triggered automatically \u2014 for example, multiplication.</p> Multiplying an Au speed by a <code>chrono</code> duration <p>Imagine we have a third-party API which measures durations, and returns its results using the venerable <code>std::chrono</code> library.</p> <pre><code>namespace third_party {\nstd::chrono::nanoseconds measure_duration();\n}\n</code></pre> <p>We\u2019d like to combine that with an Au speed that we have, so we can measure the distance travelled.  Let\u2019s compare the naive approach (which won\u2019t work) with the <code>as_quantity</code> approach that fixes it.  (Once you click on a tab below, you can use the arrow keys to \u201cflip\u201d back and forth.)</p> Naive approach (broken)<code>as_quantity()</code> (fixed) <pre><code>const auto speed = (miles / hour)(65.0);\nconst QuantityD&lt;Meters&gt; dist = speed * measure_duration();\n// Compiler error! ------------------^\n</code></pre> <p>This is broken: there\u2019s no overload for <code>operator*(Quantity, std::chrono::duration)</code>.</p> <pre><code>const auto speed = (miles / hour)(65.0);\nconst QuantityD&lt;Meters&gt; dist = speed * as_quantity(measure_duration());\n// Fixed: -----------------------------^^^^^^^^^^^\n</code></pre> <p><code>as_quantity(measure_duration())</code> means \u201ctake the result of <code>measure_duration()</code>, and re-express it as whatever <code>Quantity</code> is most appropriate\u201d.  At this point, Au\u2019s machinery takes over.  We get a result in (\\text{mi} \\cdot \\text{ns} / \\text{hr}), and this gets automatically converted to \\text{m} \u2014 using a single multiplicative factor, computed at compile time, naturally.</p> <p><code>as_quantity()</code> is SFINAE-friendly.  If you have a template on a type <code>T</code>, you can use <code>delctype(as_quantity(T{}))</code> in a SFINAE context \u2014 such as <code>std::enable_if_t</code>, or a trailing return type \u2014 to constrain the template.  If you do, then it will only generate specializations for types <code>T</code> which have a corresponding quantity to which they can convert.  There are some examples in the library itself.</p>"},{"location":"reference/corresponding_quantity/#built-in-corresponding-quantities","title":"Built-in corresponding quantities","text":"<p>Au strives to minimize dependencies, but we do depend on C++14.  Therefore, for any C++14 type which has a corresponding quantity, we provide the <code>CorrespondingQuantity</code> machinery out of the box.</p> <p>Additionally, we may include files in the repository to help interoperate with other third party libraries.  Even though these files can\u2019t be part of Au proper, their availability can make it easy to set up compatibility.</p> <p>Here are the various <code>CorrespondingQuantity</code> specializations included in the repository.</p>"},{"location":"reference/corresponding_quantity/#chrono-duration","title":"<code>std::chrono::duration</code>","text":"<p><code>std::chrono::duration</code> has two template parameters: <code>Rep</code>, and <code>Period</code>.  When <code>Period</code> is <code>std::ratio&lt;1&gt;</code>, then this duration is equivalent to <code>Quantity&lt;Seconds, Rep&gt;</code>.  For any other ratio, it is equivalent to <code>Quantity&lt;X, Rep&gt;</code>, where <code>X</code> is <code>Seconds</code> scaled by that ratio.</p> <p>We include this correspondence out of the box.  This means that you can pass a <code>std::chrono::duration</code> type to an API expecting its corresponding <code>Quantity</code> type (and vice versa); add a <code>std::chrono::duration</code> type to a <code>Quantity</code> of any time unit; and so on.</p>"},{"location":"reference/corresponding_quantity/#nholthausunits-library","title":"nholthaus/units library","text":"<p>We include a file that sets up a correspondence between the quantity types in the popular nholthaus/units library, and those in Au.</p> <p>This file is not \u201cactive\u201d by default.  You will need to set it up in your project, following our detailed how-to guide.</p>"},{"location":"reference/magnitude/","title":"Magnitude","text":"<p><code>Magnitude</code> is a family of monovalue types representing positive real numbers.  These values can be multiplied, divided, and raised to (rational) powers, and this arithmetic always takes place at compile time.  Values can also be converted to more standard numeric types, such as <code>double</code> and <code>int</code>, as long as the receiving type can represent the magnitude\u2019s value faithfully.</p> <p>The core motivation is to represent ratios of different units that have the same dimension.  As a corollary, any unit can be scaled by a <code>Magnitude</code> to make a new unit of the same dimension.</p>"},{"location":"reference/magnitude/#forming-magnitudes","title":"Forming magnitudes","text":"<p>There are 3 valid ways for end users to form a <code>Magnitude</code> instance.</p> <ol> <li> Using the <code>mag&lt;N&gt;()</code> helper to form the canonical representation of the    integer <code>N</code>.</li> <li> Writing <code>Magnitude&lt;MyConstant&gt;{}</code>, where <code>MyConstant</code> is a valid irrational    magnitude base.  (See the custom bases section below for more details.)</li> <li> Forming products, quotients, powers, and roots of other valid <code>Magnitude</code>    instances.</li> </ol> <p>The following is a valid, but dis-preferred way to form a <code>Magnitude</code>.</p> <ul> <li> <code>Magnitude&lt;&gt;</code>.<ul> <li>Explanation:  This represents the number 1, but it\u2019s less readable than writing   <code>mag&lt;1&gt;()</code>.</li> </ul> </li> </ul> <p>The following are not valid ways to form a <code>Magnitude</code>.</p> <ul> <li> <code>Magnitude&lt;Pi, MyConstant&gt;</code>.<ul> <li>Explanation: Do not supply a manual sequence of template parameters.  <code>Magnitude</code> has   strict ordering requirements on its template parameters.  The approved methods listed above   are guaranteed to satisfy these requirements.</li> </ul> </li> <li> <code>Magnitude&lt;Prime&lt;3&gt;&gt;</code>.<ul> <li>Explanation: Do not supply integer bases manually.  Integers are represented by their   prime factorization, which is performed automatically.  Instead, form integers, rationals, and   their powers only by starting with valid <code>Magnitude</code> instances, and performing arithmetic   operations as in option 3 above.</li> </ul> </li> </ul> <p>Below, we give more details on several concepts mentioned above.</p>"},{"location":"reference/magnitude/#magn","title":"<code>mag&lt;N&gt;()</code>","text":"<p><code>mag&lt;N&gt;()</code> gives an instance of the unique, canonical <code>Magnitude</code> type that represents the positive integer <code>N</code>.</p> More detail on integral <code>Magnitude</code> representations <p>Integers are stored as their prime factorization.  For example, <code>18</code> would be stored as the type <code>Magnitude&lt;Prime&lt;2&gt;, Pow&lt;Prime&lt;3&gt;, 2&gt;&gt;</code>, because 18 = 2 \\cdot 3^2.</p> <p><code>mag&lt;N&gt;()</code> automatically performs the prime factorization of <code>N</code>, and constructs a well-formed <code>Magnitude</code>.</p>"},{"location":"reference/magnitude/#custom-bases","title":"Custom bases","text":"<p><code>Magnitude</code> can handle some irrational numbers.  This even includes some transcendental numbers, such as \\pi.  Because <code>Magnitude</code> is closed under products and rational powers, this means that we also automatically support related values such as \\pi^2, \\frac{1}{\\sqrt{2\\pi}}, and so on.</p> What irrational numbers can <code>Magnitude</code> not handle? <p>A common example is any that are formed by addition.  For example, (1 + \\sqrt{2}) cannot be represented by <code>Magnitude</code>.  Recall that <code>Magnitude</code> is designed to support products and rational powers, since these are the most important operations in quantity calculus.</p> <p>It is tempting to want a better representation \u2014 one which supports full symbolic algebra. Perhaps such a representation could be designed.  However, we haven\u2019t seen any real world use cases for it.  The current <code>Magnitude</code> implementation already handles the most critical use cases, such as handling \\pi, which most units libraries have traditionally struggled to support.</p> <p>Because of its importance for angular variables, \\pi is supported natively in the library, via the irrational magnitude base, <code>Pi</code>.  To define a magnitude instance for \\pi, you can write:</p> <pre><code>constexpr auto PI = Magnitude&lt;Pi&gt;{};\n</code></pre> <p>If you need to represent an irrational number which can\u2019t be formed via any product of powers of the existing <code>Magnitude</code> types \u2014 namely, integers and \\pi \u2014 then you can define a new irrational magnitude base.  This is a <code>struct</code> with the following member:</p> <ul> <li><code>static constexpr long double value()</code>: the best approximation of your constant\u2019s value in the   <code>long double</code> storage type.</li> </ul> Important information for defining your own constant <p>If you return a literal, you must add <code>L</code> on the end.  Otherwise it will be interpreted as <code>double</code>, and will lose precision.</p> <p>Here are the results of one example which was run on an arbitrary development machine.</p> No suffix <code>L</code> suffix Literal <code>3.141592653589793238</code> <code>3.141592653589793238L</code> Actual Value <code>3.141592653589793115</code> <code>3.141592653589793238</code> <p>The un-suffixed version has lost several digits of precision.  (The precise amount will depend on the computer architecture being used.)</p> <p>Each time you add a new irrational magnitude base, you must make sure that it\u2019s independent: that is, that it can\u2019t be formed as any product of rational powers of existing <code>Magnitude</code> types.</p>"},{"location":"reference/magnitude/#extracting-values","title":"Extracting values","text":"<p>As a monovalue type, <code>Magnitude</code> can only hold one value.  There are no computations we can perform at runtime; everything happens at compile time.  What we can do is to extract that represented value, and store it in a more conventional numeric type, such as <code>int</code> or <code>double</code>.</p> <p>To extract the value of a <code>Magnitude</code> instance <code>m</code> into a given numeric type <code>T</code>, call <code>get_value&lt;T&gt;(m)</code>.  Here are some important aspects of this utility.</p> <ol> <li>The computation takes place completely at compile time.</li> <li>The computation takes place in the widest type of the same kind.  (That is, when <code>T</code> is floating    point we use <code>long double</code>, and when <code>T</code> is integral we use <code>std::intmax_t</code> or <code>std::uintmax_t</code>    according to the signedness of <code>T</code>.)</li> <li>If <code>T</code> cannot hold the value represented by <code>m</code>, we produce a compile time error.</li> </ol> Example: <code>float</code> and \\pi^3 <p>Suppose you are running on an architecture which has hardware support for <code>float</code>, but uses slow software emulation for <code>double</code> and <code>long double</code>.  With <code>Magnitude</code> and <code>get_value</code>, you can get the best of both worlds:</p> <ul> <li>The computation gets performed at compile time in <code>long double</code>, giving extra precision.</li> <li>The result gets cast to <code>float</code> and stored as a program constant.</li> </ul> <p>Thus, if you have a magnitude instance <code>PI</code>, then <code>get_value&lt;float&gt;(pow&lt;3&gt;(PI))</code> will be much more accurate than storing \\pi in a <code>float</code>, and cubing it \u2014 yet, there will be no loss in runtime performance.</p>"},{"location":"reference/magnitude/#checking-for-representability","title":"Checking for representability","text":"<p>If you need to check whether your magnitude <code>m</code> can be represented in a type <code>T</code>, you can call <code>representable_in&lt;T&gt;(m)</code>.  This function is <code>constexpr</code> compatible.</p> Example: integer and non-integer values <p>Here are some example test cases which will pass.</p> <pre><code>EXPECT_TRUE(representable_in&lt;int&gt;(mag&lt;1&gt;()));\n\n// (1 / 2) is not an integer.\nEXPECT_FALSE(representable_in&lt;int&gt;(mag&lt;1&gt;() / mag&lt;2&gt;()));\n\nEXPECT_TRUE(representable_in&lt;float&gt;(mag&lt;1&gt;() / mag&lt;2&gt;()));\n</code></pre> Example: range of the type <p>Here are some example test cases which will pass.</p> <pre><code>EXPECT_TRUE(representable_in&lt;uint32_t&gt;(mag&lt;4'000'000'000&gt;()));\n\n// 4 billion is larger than the max value representable in `int32_t`.\nEXPECT_FALSE(representable_in&lt;int32_t&gt;(mag&lt;4'000'000'000&gt;()));\n</code></pre> <p>Note that this function\u2019s return value also depends on whether we can compute the value, not just whether it is representable.   For example, <code>representable_in&lt;double&gt;(sqrt(mag&lt;2&gt;()))</code> is currently <code>false</code>, because we haven\u2019t yet added support for computing rational base powers.</p>"},{"location":"reference/magnitude/#operations","title":"Operations","text":"<p>These are the operations which <code>Magnitude</code> supports.  Because it is a monovalue type, the value can take the form of either a type or an instance. In what follows, we\u2019ll use this convention:</p> <ul> <li>Capital identifiers (<code>M</code>, <code>M1</code>, <code>M2</code>, \u2026) refer to types.</li> <li>Lowercase identifiers (<code>m</code>, <code>m1</code>, <code>m2</code>, \u2026) refer to instances.</li> </ul>"},{"location":"reference/magnitude/#equality-comparison","title":"Equality comparison","text":"<p>Result: A <code>bool</code> indicating whether two <code>Magnitude</code> values represent the same number.</p> <p>Syntax:</p> <ul> <li>For types <code>M1</code> and <code>M2</code>:<ul> <li><code>std::is_same&lt;M1, M2&gt;::value</code></li> </ul> </li> <li>For instances <code>m1</code> and <code>m2</code>:<ul> <li><code>m1 == m2</code> (equality comparison)</li> <li><code>m1 != m2</code> (inequality comparison)</li> </ul> </li> </ul>"},{"location":"reference/magnitude/#multiplication","title":"Multiplication","text":"<p>Result: The product of two <code>Magnitude</code> values.</p> <p>Syntax:</p> <ul> <li>For types <code>M1</code> and <code>M2</code>:<ul> <li><code>MagProductT&lt;M1, M2&gt;</code></li> </ul> </li> <li>For instances <code>m1</code> and <code>m2</code>:<ul> <li><code>m1 * m2</code></li> </ul> </li> </ul>"},{"location":"reference/magnitude/#division","title":"Division","text":"<p>Result: The quotient of two <code>Magnitude</code> values.</p> <p>Syntax:</p> <ul> <li>For types <code>M1</code> and <code>M2</code>:<ul> <li><code>MagQuotientT&lt;M1, M2&gt;</code></li> </ul> </li> <li>For instances <code>m1</code> and <code>m2</code>:<ul> <li><code>m1 / m2</code></li> </ul> </li> </ul>"},{"location":"reference/magnitude/#powers","title":"Powers","text":"<p>Result: A <code>Magnitude</code> raised to an integral power.</p> <p>Syntax:</p> <ul> <li>For a type <code>M</code>, and an integral power <code>N</code>:<ul> <li><code>MagPowerT&lt;M, N&gt;</code></li> </ul> </li> <li>For an instance <code>m</code>, and an integral power <code>N</code>:<ul> <li><code>pow&lt;N&gt;(m)</code></li> </ul> </li> </ul>"},{"location":"reference/magnitude/#roots","title":"Roots","text":"<p>Result: An integral root of a <code>Magnitude</code>.</p> <p>Syntax:</p> <ul> <li>For a type <code>M</code>, and an integral root <code>N</code>:<ul> <li><code>MagPowerT&lt;M, 1, N&gt;</code> (because the N^\\text{th} root is equivalent to the   \\left(\\frac{1}{N}\\right)^\\text{th} power)</li> </ul> </li> <li>For an instance <code>m</code>, and an integral root <code>N</code>:<ul> <li><code>root&lt;N&gt;(m)</code></li> </ul> </li> </ul>"},{"location":"reference/magnitude/#helpers-for-powers-and-roots","title":"Helpers for powers and roots","text":"<p>Magnitudes support all of the power helpers.  So, for example, for a magnitude instance <code>m</code>, you can write <code>sqrt(m)</code> as a more readable alternative to <code>root&lt;2&gt;(m)</code>.</p>"},{"location":"reference/magnitude/#traits","title":"Traits","text":"<p>These traits provide information, at compile time, about the number represented by a <code>Magnitude</code>.</p>"},{"location":"reference/magnitude/#integer-test","title":"Integer test","text":"<p>Result: A <code>bool</code> indicating whether a <code>Magnitude</code> represents an integer (<code>true</code> if it does; <code>false</code> otherwise).</p> <p>Syntax:</p> <ul> <li>For a type <code>M</code>:<ul> <li><code>IsInteger&lt;M&gt;::value</code></li> </ul> </li> <li>For an instance <code>m</code>:<ul> <li><code>is_integer(m)</code></li> </ul> </li> </ul>"},{"location":"reference/magnitude/#rational-test","title":"Rational test","text":"<p>Result: A <code>bool</code> indicating whether a <code>Magnitude</code> represents a rational number (<code>true</code> if it does; <code>false</code> otherwise).</p> <p>Syntax:</p> <ul> <li>For a type <code>M</code>:<ul> <li><code>IsRational&lt;M&gt;::value</code></li> </ul> </li> <li>For an instance <code>m</code>:<ul> <li><code>is_rational(m)</code></li> </ul> </li> </ul>"},{"location":"reference/magnitude/#integer-part","title":"Integer part","text":"<p>Result: The integer part of a <code>Magnitude</code>, which is another <code>Magnitude</code>.</p> <p>For example, the \u201cinteger part\u201d of \\frac{\\sqrt{18}}{5\\pi} would be 3, because \\sqrt{27} = 3\\sqrt{2}, and 3 is the integer part of 3\\sqrt{2}.</p> <p>If the input magnitude is an integer, then this operation is the identity.</p> <p>If the input magnitude is not an integer, then this operation produces the largest integer factor that can be extracted from the numerator (that is, the base powers with positive exponent).<sup>1</sup></p> <p>Syntax:</p> <ul> <li>For a type <code>M</code>:<ul> <li><code>IntegerPartT&lt;M&gt;</code></li> </ul> </li> <li>For an instance <code>m</code>:<ul> <li><code>integer_part(m)</code></li> </ul> </li> </ul>"},{"location":"reference/magnitude/#numerator-integer-part","title":"Numerator (integer part)","text":"<p>Result: The numerator we would have if a <code>Magnitude</code> were written as a fraction.  This result is another <code>Magnitude</code>.</p> <p>For example, the \u201cnumerator\u201d of \\frac{3\\sqrt{3}}{5\\pi} would be 3\\sqrt{3}.</p> <p>Syntax:</p> <ul> <li>For a type <code>M</code>:<ul> <li><code>NumeratorT&lt;M&gt;</code></li> </ul> </li> <li>For an instance <code>m</code>:<ul> <li><code>numerator(m)</code></li> </ul> </li> </ul>"},{"location":"reference/magnitude/#denominator-integer-part","title":"Denominator (integer part)","text":"<p>Result: The denominator we would have if a <code>Magnitude</code> were written as a fraction.  This result is another <code>Magnitude</code>.</p> <p>For example, the \u201cdenominator\u201d of \\frac{3\\sqrt{3}}{5\\pi} would be 5\\pi.</p> <p>Syntax:</p> <ul> <li>For a type <code>M</code>:<ul> <li><code>DenominatorT&lt;M&gt;</code></li> </ul> </li> <li>For an instance <code>m</code>:<ul> <li><code>denominator(m)</code></li> </ul> </li> </ul> <ol> <li> <p>The concept <code>integer_part()</code> is conceptually ambiguous when applied to non-integers.  So, too, for <code>numerator()</code> and <code>denominator()</code> applied to irrational numbers.  These utilities serve two purposes.  First, they provide a means for checking whether a given magnitude is a member of the unambiguous set \u2014 that is, we can check whether a magnitude is an integer by checking whether it\u2019s equal to its \u201cinteger part\u201d.  Second, they enable us to automatically construct labels for magnitudes, by breaking them into the same kinds of pieces that a human reader would expect.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/math/","title":"Math functions","text":"<p>We provide many common mathematical functions out of the box.  If you think we\u2019re missing a particular math function, and you\u2019d like to see it added, reach out to us and ask!</p>"},{"location":"reference/math/#general-usage-advice","title":"General usage advice","text":"<p>Prefer to make unqualified calls to these functions.  So for example: if you\u2019re using unit types and you want the \u201cmax\u201d, just write plain <code>max(...)</code>.</p> <ul> <li>Don\u2019t write <code>std::max(...)</code>, because that would give the wrong function.</li> <li>Don\u2019t write <code>au::max(...)</code>, because that\u2019s neither necessary nor idiomatic.</li> </ul>"},{"location":"reference/math/#function-categories","title":"Function categories","text":"<p>Here are the functions we provide, grouped roughly into related categories.</p>"},{"location":"reference/math/#sign-based-functions","title":"Sign-based functions:","text":""},{"location":"reference/math/#checking-signs-comparing-to-0","title":"Checking signs, comparing to 0","text":"<p><code>Quantity</code> cannot be compared to <code>0</code> or <code>0.0</code>, since these are raw numeric types.  However, any <code>Quantity</code> can be compared to <code>ZERO</code>, which is a built-in constant of the library.  See our <code>Zero</code> discussion for more background.</p>"},{"location":"reference/math/#abs","title":"<code>abs</code>","text":"<p>Adapts <code>std::abs</code> to <code>Quantity</code> types.  Covers both integral and floating point overloads of <code>std::abs</code>.</p> <p>Signature:</p> <pre><code>template &lt;typename U, typename R&gt;\nauto abs(Quantity&lt;U, R&gt; q);\n</code></pre> <p>Returns: The input quantity, but with <code>std::abs</code> applied to its underlying value.</p>"},{"location":"reference/math/#copysign","title":"<code>copysign</code>","text":"<p>Adapts <code>std::copysign</code> to <code>Quantity</code> types.</p> <p>Signatures:</p> <pre><code>// 1: First argument Quantity, second argument raw numeric\ntemplate &lt;typename U, typename R, typename T&gt;\nconstexpr auto copysign(Quantity&lt;U, R&gt; mag, T sgn);\n\n// 2: First argument raw numeric, second argument Quantity\ntemplate &lt;typename T, typename U, typename R&gt;\nconstexpr auto copysign(T mag, Quantity&lt;U, R&gt; sgn);\n\n// 3: Both arguments Quantity\ntemplate &lt;typename U1, typename R1, typename U2, typename R2&gt;\nconstexpr auto copysign(Quantity&lt;U1, R1&gt; mag, Quantity&lt;U2, R2&gt; sgn);\n</code></pre> <p>Returns: The first argument, with the sign from the second argument applied to it.</p>"},{"location":"reference/math/#comparison-based-functions","title":"Comparison-based functions","text":""},{"location":"reference/math/#min-max","title":"<code>min</code>, <code>max</code>","text":"<p>Select the smaller (<code>min</code>) or larger (<code>max</code>) of the two inputs.  This operation is unit-aware, and supports mixing different input units, as long as they have the same dimension.  These functions support both <code>Quantity</code> and <code>QuantityPoint</code> inputs.</p> <p>Signatures:<sup>1</sup></p> <pre><code>//\n// min()\n//\n\n// 1. `Quantity` inputs\ntemplate &lt;typename U1, typename U2, typename R1, typename R2&gt;\nauto min(Quantity&lt;U1, R1&gt; q1, Quantity&lt;U2, R2&gt; q2);\n\n// 2. `QuantityPoint` inputs\ntemplate &lt;typename U1, typename U2, typename R1, typename R2&gt;\nauto min(QuantityPoint&lt;U1, R1&gt; p1, QuantityPoint&lt;U2, R2&gt; p2);\n\n//\n// max()\n//\n\n// 1. `Quantity` inputs\ntemplate &lt;typename U1, typename U2, typename R1, typename R2&gt;\nauto max(Quantity&lt;U1, R1&gt; q1, Quantity&lt;U2, R2&gt; q2);\n\n// 2. `QuantityPoint` inputs\ntemplate &lt;typename U1, typename U2, typename R1, typename R2&gt;\nauto max(QuantityPoint&lt;U1, R1&gt; p1, QuantityPoint&lt;U2, R2&gt; p2);\n</code></pre> <p>Returns: The value of the smallest (<code>min</code>) or largest (<code>max</code>) of the inputs, expressed in their common type.</p> <p>Note</p> <p>unlike <code>std::min</code> and <code>std::max</code>, we return by value, not by reference.  This is because we support combining different units.  This means the return type will generally be different from the types of the inputs.</p>"},{"location":"reference/math/#clamp","title":"<code>clamp</code>","text":"<p>\u201cClamp\u201d the first parameter to the range defined by the second and third.  This is a unit-aware analogue to <code>std::clamp</code>, which was introduced in C++17.  However, this version differs in several respects from <code>std::clamp</code>, in order to handle quantities more effectively.  We\u2019ll explain these differences at the end of the <code>clamp</code> section.</p> <p>Signatures:</p> <pre><code>// 1. `Quantity` inputs\ntemplate &lt;typename UV , typename RV ,\n          typename ULo, typename RLo,\n          typename UHi, typename RHi&gt;\nconstexpr auto clamp(\n    Quantity&lt;UV , RV &gt; v,\n    Quantity&lt;ULo, RLo&gt; lo,\n    Quantity&lt;UHi, RHi&gt; hi);\n\n// 2. `QuantityPoint` inputs\ntemplate &lt;typename UV , typename RV ,\n          typename ULo, typename RLo,\n          typename UHi, typename RHi&gt;\nconstexpr auto clamp(\n    QuantityPoint&lt;UV , RV &gt; v,\n    QuantityPoint&lt;ULo, RLo&gt; lo,\n    QuantityPoint&lt;UHi, RHi&gt; hi);\n</code></pre> A note on custom comparators <p><code>std::clamp</code> includes a four-parameter version, where the fourth parameter is a custom comparator.  <code>std::clamp</code> provides this because it must support an unknowably wide range of custom types.  However, <code>au::clamp</code> only supports <code>Quantity</code> and <code>QuantityPoint</code> types, whose notions of comparison is unambiguous.  Therefore, we opt to keep the library simple, and omit this four-parameter version.</p> <p>Returns: The closest quantity (or quantity point) to <code>v</code> which is between <code>lo</code> and <code>hi</code>, inclusive \u2014 that is, greater than or equal to <code>lo</code>, and less than or equal to <code>hi</code>.  If <code>lo &gt; hi</code>, the behaviour is undefined.  The return type will be expressed in the appropriate unit and rep; expand the note below for further details.</p> Details on the unit and rep for the return type <p>Comparison is a common-unit operation.  We must convert all inputs to their common unit before we compare, and therefore the output must also be expressed in this same common unit.</p> <p>The rep of the return type will be the common type of the input reps.  Specifically, given the above signatures, it will be <code>std::common_type_t&lt;RV, RLo, RHi&gt;</code>.</p> <p>The unit of the return type depends on whether we are working with <code>Quantity</code> inputs, or <code>QuantityPoint</code>.</p> <ul> <li>For <code>Quantity</code>, the return type\u2019s unit is <code>CommonUnitT&lt;UV, ULo, UHi&gt;</code>.</li> <li>For <code>QuantityPoint</code>, the return type\u2019s unit is <code>CommonPointUnitT&lt;UV, ULo, UHi&gt;</code>: this is the   common point unit, which takes   relative origin offsets into account.</li> </ul> Differences from <code>std::clamp</code> <p>Here are the main changes which stem from handling quantities instead of simple numbers.</p> <ul> <li> <p>unlike <code>std::clamp</code>, we return by value, not by reference.  This is because we support   combining different units.  This means the return type will generally be different from the   types of the inputs.</p> </li> <li> <p>The return type can be different from the type of <code>v</code>, because we must express it in the   common unit and rep of the input parameter types.</p> </li> <li> <p>We do not currently plan to provide the four-parameter overload, unless we get a compelling   use case.</p> </li> </ul>"},{"location":"reference/math/#exponentiation","title":"Exponentiation","text":""},{"location":"reference/math/#int_pow","title":"<code>int_pow</code>","text":"<p>Raise a <code>Quantity</code> to an integer power.  Since this is an arbitrary-unit operation, the power applies independently to the unit and to the value.</p> <p>If the input has an integral rep (storage type), then the exponent cannot be negative.</p> <p>Signature:</p> <pre><code>template &lt;int Exp, typename U, typename R&gt;\nconstexpr auto int_pow(Quantity&lt;U, R&gt; q);\n</code></pre> <p>Returns:  A <code>Quantity</code> whose unit is the input unit raised to the given power, and whose value is the input value raised to the given power.</p>"},{"location":"reference/math/#sqrt","title":"<code>sqrt</code>","text":"<p>A unit-aware adaptation of <code>std::sqrt</code>.  Both the input and output are <code>Quantity</code> types.  Since <code>sqrt</code> is an arbitrary-unit operation, the square root applies independently to the unit and to the value.</p> <p>We mirror <code>std::sqrt</code> in selecting our output rep.  That is to say: the output rep will be the return type of <code>std::sqrt</code> when called with a value of our input rep.</p> <p>Signature:</p> <pre><code>template &lt;typename U, typename R&gt;\nauto sqrt(Quantity&lt;U, R&gt; q);\n</code></pre> <p>Returns: A <code>Quantity</code> whose unit is the square root of the input quantity\u2019s unit, and whose value is the square root of the input quantity\u2019s value.</p> Warning: not all unit conversions are currently supported <p>There is one edge case to be aware of with <code>sqrt</code>: we don\u2019t yet support any conversion which picks up a radical factor.  This is because all conversion factors get computed at compile time, and we don\u2019t have a way to compute rational powers at compile time.  To fix this, we would need a <code>constexpr</code>-compatible implementation of <code>std::powl</code>.</p> <p>Let\u2019s clarify what you can and can\u2019t do in today\u2019s library, with an example.</p> <pre><code>// Taking the square root of \"weird\" units: this works.\nconst auto geo_mean_length = sqrt(inches(1) * meters(1));\n\n// Now let's look at retrieving the value in different units.\n\n// Using a Quantity-equivalent Unit just retrieves the stored value.\n// This _always_ works.  (In this case, it gives `1.0`.)\nconst auto retrieved_value = geo_mean_length.in(sqrt(inch * meters));\n\n// This conversion is non-trivial, but it's also OK.\n// The reason is that the conversion factor doesn't have any rational powers.\n// (In this case, it gives `10.0`.)\nconst auto rationally_converted_value = geo_mean_length.in(sqrt(inch * centi(meters)));\n\n// This test case doesn't currently work.\n// Later, if we can compute radical conversion factors at compile time, it will.\n// (It should give roughly 6.274558...)\n// const auto radically_converted_value = geo_mean_length.in(inches);\n</code></pre>"},{"location":"reference/math/#trigonometric-functions","title":"Trigonometric functions","text":""},{"location":"reference/math/#sin-cos-tan","title":"<code>sin</code>, <code>cos</code>, <code>tan</code>","text":"<p>The value of the named trigonometric function (\\sin, \\cos, or \\tan), evaluated at an input <code>Quantity</code> representing an angle.</p> <p>If called with any <code>Quantity</code> which is not an angle, we produce a hard compiler error.</p> <p>Signatures:</p> <pre><code>//\n// sin()\n//\ntemplate &lt;typename U, typename R&gt;\nauto sin(Quantity&lt;U, R&gt; q);\n\n//\n// cos()\n//\ntemplate &lt;typename U, typename R&gt;\nauto cos(Quantity&lt;U, R&gt; q);\n\n//\n// tan()\n//\ntemplate &lt;typename U, typename R&gt;\nauto tan(Quantity&lt;U, R&gt; q);\n</code></pre> <p>Returns: The result of converting the input to <code>Radians</code>, and then calling the corresponding STL function (that is, <code>std::sin()</code> for <code>sin()</code>, and so on).</p> <p>In converting to radians, we mirror the corresponding STL functions in how we handle the rep.  For floating point rep (<code>float</code>, <code>double</code>, and so on), the return type is the <code>rep</code>.  For integral inputs (<code>int</code>, <code>uint32_t</code>, and so on), we cast to <code>double</code> and return <code>double</code>.  See, for instance, the <code>std::sin</code> documentation.</p> Example: using angles of integer degrees <p>This example is taken from a test case in the library.</p> <pre><code>EXPECT_NEAR(sin(degrees(30)), 0.5, 1e-15);\n</code></pre>"},{"location":"reference/math/#arcsin-arccos-arctan","title":"<code>arcsin</code>, <code>arccos</code>, <code>arctan</code>","text":"<p>The standard inverse trigonometric functions, each returning a <code>Quantity</code> of <code>Radians</code>.</p> <p>Each function corresponds to an STL function, except with <code>arc</code> replaced by <code>a</code>.  For example, <code>arcsin()</code> corresponds to <code>std::asin()</code>, and so on.  This library\u2019s functions return <code>Quantity&lt;Radians, T&gt;</code> whenever the corresponding STL function would return a <code>T</code>.</p> <p>Their names are slightly different than the corresponding STL functions, because in C++ it\u2019s impermissible to have two functions whose signatures differ only in their return type.</p> <p>Note</p> <p>For more flexibility and robustness in dealing with arctangent use cases, see <code>arctan2</code> below.</p> <p>Signatures:</p> <pre><code>//\n// arcsin()\n//\ntemplate &lt;typename T&gt;\nauto arcsin(T x);\n\n//\n// arccos()\n//\ntemplate &lt;typename T&gt;\nauto arccos(T x);\n\n//\n// arctan()\n//\ntemplate &lt;typename T&gt;\nauto arctan(T x);\n</code></pre> <p>Returns: <code>radians(stl_func(x))</code>, where <code>stl_func</code> is the corresponding STL function (that is, <code>std::acos()</code> for <code>arccos()</code>, and so on).</p> Example: getting the result in degrees <p>The fact that we return a <code>Quantity</code>, not a raw number, makes these functions far more flexible than their STL counterparts.  For example, it\u2019s easy to get the result in degrees using fluent, readable code:</p> <pre><code>// It's easy to express the answer in your preferred angular units.\nconst auto angle = arcsin(0.5).as(degrees);\n\n// This test verifies that the result has the value we'd expect from basic trigonometry.\nconstexpr auto TOL = degrees(1e-12);\nEXPECT_THAT(angle, IsNear(degrees(30.0), TOL));\n</code></pre>"},{"location":"reference/math/#arctan2","title":"<code>arctan2</code>","text":"<p>The two-argument arctangent function, which determines the in-plane angle based on the y and x coordinates of a point in the plane.</p> <p><code>arctan2</code> corresponds to <code>std::atan2</code>, but returns a <code>Quantity</code> of <code>Radians</code> instead of a raw number.</p> <p>This two-argument version is more robust than the single-argument version.  <code>arctan2(y, x)</code> is equivalent to <code>arctan(y / x)</code>, but it avoids the problems faced by the latter whenever <code>x</code> is zero.</p> <p>Unlike the other inverse trigonometric functions, which only support raw numeric inputs, <code>arctan2</code> also supports <code>Quantity</code> inputs.  These inputs must have the same dimension, or else we will produce a hard compiler error.  We convert them to their common unit, if necessary, before delegating to <code>std::atan2</code>.</p> <p>Signatures:</p> <pre><code>// 1. Raw numeric inputs.\ntemplate &lt;typename T, typename U&gt;\nauto arctan2(T y, U x);\n\n// 2. Quantity inputs (must be same dimension).\ntemplate &lt;typename U1, typename R1, typename U2, typename R2&gt;\nauto arctan2(Quantity&lt;U1, R1&gt; y, Quantity&lt;U2, R2&gt; x);\n</code></pre> <p>Returns: <code>radians(std::atan2(y, x))</code>.  If the inputs are <code>Quantity</code> types, then instead of passing <code>y</code> and <code>x</code>, we first convert them to their common unit, and pass their values in that unit.</p>"},{"location":"reference/math/#rounding-functions","title":"Rounding functions","text":""},{"location":"reference/math/#round_as-round_in","title":"<code>round_as</code>, <code>round_in</code>","text":"<p>Round a <code>Quantity</code> to the nearest integer value, using units that are specified explicitly at the callsite.</p> <p>These functions are intended as unit-aware analogues to <code>std::round</code>.  However, we firmly oppose the idea of providing the same (single-argument) API as <code>std::round</code> for <code>Quantity</code>, because a quantity has no single well-defined result: it depends on the units.  (For example, <code>std::round(height)</code> is an intrinsically ill-formed concept: what is an \u201cinteger height\u201d?)</p> <p>As with everything else in the library, <code>\"as\"</code> is a word that means \u201creturn a <code>Quantity</code>\u201d, and <code>\"in\"</code> is a word that means \u201creturn a raw number\u201d.</p> <p>Signatures:</p> <pre><code>//\n// round_as(): return a Quantity or QuantityPoint (depending on the input type)\n//\n\n// 1. Unit-only version (including safety checks).  Typical callsites look like:\n//    `round_as(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto round_as(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto round_as(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n\n// 2. Explicit-rep version (overriding; ignores safety checks).  Typical callsites look like:\n//    `round_as&lt;Type&gt;(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto round_as(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto round_as(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n\n\n//\n// round_in(): return a raw number\n//\n\n// 1. Unit-only version (including safety checks).  Typical callsites look like:\n//    `round_in(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto round_in(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto round_in(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n\n// 2. Explicit-rep version (overriding; ignores safety checks).  Typical callsites look like:\n//    `round_in&lt;Type&gt;(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto round_in(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto round_in(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n</code></pre> <p>Returns: A <code>Quantity</code> or <code>QuantityPoint</code> (depending on the input type), expressed in the requested units, which has an integer value in those units. We return the nearest such quantity to the original input quantity.</p> <p>The policy for the rep is consistent with <code>std::round</code>.  The output rep is the same as the return type of applying <code>std::round</code> to the input rep.</p>"},{"location":"reference/math/#ceil_in-ceil_as","title":"<code>ceil_in</code>, <code>ceil_as</code>","text":"<p>Round a <code>Quantity</code> up to the smallest integer value which is at least as big as that quantity, using units that are specified explicitly at the callsite.</p> <p>These functions are intended as unit-aware analogues to <code>std::ceil</code>.  However, we firmly oppose the idea of providing the same (single-argument) API as <code>std::ceil</code> for <code>Quantity</code>, because a quantity has no single well-defined result: it depends on the units.  (For example, <code>std::ceil(height)</code> is an intrinsically ill-formed concept: what is an \u201cinteger height\u201d?)</p> <p>As with everything else in the library, <code>\"as\"</code> is a word that means \u201creturn a <code>Quantity</code>\u201d, and <code>\"in\"</code> is a word that means \u201creturn a raw number\u201d.</p> <p>Signatures:</p> <pre><code>//\n// ceil_as(): return a Quantity or QuantityPoint (depending on the input type)\n//\n\n// 1. Unit-only version (including safety checks).  Typical callsites look like:\n//    `ceil_as(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto ceil_as(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto ceil_as(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n\n// 2. Explicit-rep version (overriding; ignores safety checks).  Typical callsites look like:\n//    `ceil_as&lt;Type&gt;(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto ceil_as(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto ceil_as(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n\n\n//\n// ceil_in(): return a raw number\n//\n\n// 1. Unit-only version (including safety checks).  Typical callsites look like:\n//    `ceil_in(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto ceil_in(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto ceil_in(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n\n// 2. Explicit-rep version (overriding; ignores safety checks).  Typical callsites look like:\n//    `ceil_in&lt;Type&gt;(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto ceil_in(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto ceil_in(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n</code></pre> <p>Returns: A <code>Quantity</code>, expressed in the requested units, which has an integer value in those units.  We return the smallest such quantity which is no smaller than the original input quantity.</p> <p>The policy for the rep is consistent with <code>std::ceil</code>.  The output rep is the same as the return type of applying <code>std::ceil</code> to the input rep.</p>"},{"location":"reference/math/#floor_in-floor_as","title":"<code>floor_in</code>, <code>floor_as</code>","text":"<p>Round a <code>Quantity</code> down to the largest integer value which is no bigger than that quantity, using the units that are specified explicitly at the callsite.</p> <p>These functions are intended as unit-aware analogues to <code>std::floor</code>.  However, we firmly oppose the idea of providing the same (single-argument) API as <code>std::floor</code> for <code>Quantity</code>, because a quantity has no single well-defined result: it depends on the units.  (For example, <code>std::floor(height)</code> is an intrinsically ill-formed concept: what is an \u201cinteger height\u201d?)</p> <p>As with everything else in the library, <code>\"as\"</code> is a word that means \u201creturn a <code>Quantity</code>\u201d, and <code>\"in\"</code> is a word that means \u201creturn a raw number\u201d.</p> <p>Signatures:</p> <pre><code>//\n// floor_as(): return a Quantity or QuantityPoint (depending on the input type)\n//\n\n// 1. Unit-only version (including safety checks).  Typical callsites look like:\n//    `floor_as(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto floor_as(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto floor_as(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n\n// 2. Explicit-rep version (overriding; ignores safety checks).  Typical callsites look like:\n//    `floor_as&lt;Type&gt;(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto floor_as(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto floor_as(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n\n\n//\n// floor_in(): return a raw number\n//\n\n// 1. Unit-only version (including safety checks).  Typical callsites look like:\n//    `floor_in(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto floor_in(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename RoundingUnits, typename U, typename R&gt;\nauto floor_in(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n\n// 2. Explicit-rep version (overriding; ignores safety checks).  Typical callsites look like:\n//    `floor_in&lt;Type&gt;(units, quantity)`\n\n// a) For `Quantity` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto floor_in(RoundingUnits rounding_units, Quantity&lt;U, R&gt; q);\n\n// b) For `QuantityPoint` inputs\ntemplate &lt;typename OutputRep, typename RoundingUnits, typename U, typename R&gt;\nauto floor_in(RoundingUnits rounding_units, QuantityPoint&lt;U, R&gt; q);\n</code></pre> <p>Returns: A <code>Quantity</code>, expressed in the requested units, which has an integer value in those units.  We return the largest such quantity which is no larger than the original input quantity.</p> <p>The policy for the rep is consistent with <code>std::floor</code>.  The output rep is the same as the return type of applying <code>std::floor</code> to the input rep.</p>"},{"location":"reference/math/#inverse-functions","title":"Inverse functions","text":""},{"location":"reference/math/#inverse_as-inverse_in","title":"<code>inverse_as</code>, <code>inverse_in</code>","text":"<p>A unit-aware computation of 1 / x.</p> <p>\u201cUnit-aware\u201d means that you specify the desired target unit, and the library will figure out the appropriate units for representing the 1 in 1 / x.  This intelligent choice enables it to automatically handle many conversions with integer types, without the computation ever needing to leave the integer domain.</p> Example: inverse of 250 \\,\\text{Hz} <p>The inverse of 250 \\,\\text{Hz} is 0.004 \\,\\text{s}.  If we are using integer types, of course this would truncate down to 0. However, we could choose an alternate unit \u2014 say, \\text{\u00b5s} \u2014 and we would get a \u201cnicer\u201d answer of 4000 \\,\\text{\u00b5s}.</p> <p>Now for Au.  If you request the inverse of <code>hertz(250)</code> in <code>micro(seconds)</code>, the library will indeed return <code>micro(seconds)(4000)</code> \u2014 and it can perform this computation without ever leaving the integer domain!  What happens under the hood is that the value of <code>250</code> is divided into a value of <code>1'000'000</code>, not <code>1</code>.</p> <p>To see how we came up with this value, let\u2019s re-express the fundamental equation.  Let x be the original quantity, and y its inverse.  We have:</p>  \\begin{align} y &amp;= 1 / x \\\\ 1 &amp;= xy \\end{align}  <p>This is a quantity equation.  And since multiplication is an arbitrary-unit operation, we can reason independently about the unit and the value.  The units on the right hand side are <code>hertz * micro(seconds)</code>. This is a dimensionless unit with a magnitude of 10^{-6}.  The units on the left hand side must match; therefore, we must express 1 in these units.  When we do, we find its value in these units is 10^6 \u2014 or, in C++ code, <code>1'000'000</code>.</p> <p>That is how the library knows to divide <code>250</code> into <code>1'000'000</code> to get an answer of <code>4'000</code> \u2014 all without ever leaving the integer domain.</p> <p>These functions include safety checks.</p> <ul> <li><code>Quantity</code> inputs with floating point rep are always allowed.</li> <li><code>Quantity</code> inputs with integral rep are allowed only when the product of the input and target   units \u2014 which is necessarily dimensionless \u2014 has a magnitude not greater than 10^{-6}.  We   chose this threshold because it means that the round-trip double inversion will be lossless for   any <code>Quantity</code> whose underlying value is not greater than <code>1'000</code>.</li> </ul> <p>As with all other library functions, you can circumvent the safety checks by using one of the \u201cexplicit-rep\u201d versions, which are forcing in the same way as <code>static_cast</code>.</p> <p>Signatures:</p> <pre><code>//\n// inverse_as(): return a Quantity\n//\n\n// 1. Unit-only version (including safety checks).  Typical callsites look like:\n//    `inverse_as(units, quantity)`\ntemplate &lt;typename TargetUnits, typename U, typename R&gt;\nconstexpr auto inverse_as(TargetUnits target_units, Quantity&lt;U, R&gt; q);\n\n// 2. Explicit-rep version (overriding; ignores safety checks).  Typical callsites look like:\n//    `inverse_as&lt;Type&gt;(units, quantity)`\ntemplate &lt;typename TargetRep, typename TargetUnits, typename U, typename R&gt;\nconstexpr auto inverse_as(TargetUnits target_units, Quantity&lt;U, R&gt; q);\n\n\n//\n// inverse_in(): return a raw number\n//\n\n// 1. Unit-only version (including safety checks).  Typical callsites look like:\n//    `inverse_in(units, quantity)`\ntemplate &lt;typename TargetUnits, typename U, typename R&gt;\nconstexpr auto inverse_in(TargetUnits target_units, Quantity&lt;U, R&gt; q);\n\n// 2. Explicit-rep version (overriding; ignores safety checks).  Typical callsites look like:\n//    `inverse_in&lt;Type&gt;(units, quantity)`\ntemplate &lt;typename TargetRep, typename TargetUnits, typename U, typename R&gt;\nconstexpr auto inverse_in(TargetUnits target_units, Quantity&lt;U, R&gt; q);\n</code></pre> <p>Returns: The inverse of the input <code>Quantity</code>, expressed in the requested units.</p>"},{"location":"reference/math/#special-values-and-language-features","title":"Special values and language features","text":""},{"location":"reference/math/#isnan","title":"<code>isnan</code>","text":"<p>Indicates whether the underlying value of a <code>Quantity</code> is a NaN (\u201cnot-a-number\u201d) value.</p> <p>Signature:</p> <pre><code>// 1. `Quantity` inputs\ntemplate &lt;typename U, typename R&gt;\nconstexpr bool isnan(Quantity&lt;U, R&gt; q);\n\n// 2. `QuantityPoint` inputs\ntemplate &lt;typename U, typename R&gt;\nconstexpr bool isnan(QuantityPoint&lt;U, R&gt; q);\n</code></pre> <p>Returns: <code>true</code> if <code>q</code> is NaN; <code>false</code> otherwise.</p>"},{"location":"reference/math/#stdnumeric_limits-specializations","title":"<code>std::numeric_limits</code> specializations","text":"<p>Specializations for <code>std::numeric_limits&lt;Quantity&lt;...&gt;&gt;</code>.</p> <p>For any <code>Quantity&lt;UnitT, Rep&gt;</code>, we simply delegate to <code>std::numeric_limits&lt;Rep&gt;</code> in the appropriate way, being careful to follow the rules for specializing, and adapt the result we get.  For example, <code>std::numeric_limits&lt;Quantity&lt;Hours, int&gt;&gt;::max()</code> is exactly equal to <code>hours(std::numeric_limits&lt;int&gt;::max())</code>.</p> <p>Warning</p> <p>Be careful about using these limits in the presence of different Units of the same Dimension.  Comparison operations will compile, but may not do what you expect.  Consider this example:</p> <pre><code>seconds(0) &lt; std::numeric_limits&lt;Quantity&lt;Hours, int&gt;&gt;::max()\n</code></pre> <p>Clearly, we\u2019d want this to be <code>true</code>\u2026 but, in converting both sides to their common type, we\u2019d end up multiplying the max-int on the right by 3600.  What answer would we get for the comparison?  It\u2019s far from clear.</p> <p>If you use these for a single <code>Quantity</code> type (i.e., same Unit and Rep), they should be just fine.  (Then again\u2014perhaps this is a good opportunity to ask yourself what you\u2019re really trying to accomplish, and whether using the largest finite value of a particular type is the best way to achieve it!)</p>"},{"location":"reference/math/#miscellaneous","title":"Miscellaneous","text":""},{"location":"reference/math/#fmod","title":"<code>fmod</code>","text":"<p>A unit-aware adaptation of <code>std::fmod</code>, giving the positive remainder of the division of the two inputs.</p> <p>As with the integer modulus, we first express the inputs in their common unit.</p> <p>Signature:</p> <pre><code>template &lt;typename U1, typename R1, typename U2, typename R2&gt;\nauto fmod(Quantity&lt;U1, R1&gt; q1, Quantity&lt;U2, R2&gt; q2);\n</code></pre> <p>Returns: The remainder of <code>q1 / q2</code>, in the type <code>Quantity&lt;U, R&gt;</code>, where <code>U</code> is the common unit of <code>U1</code> and <code>U2</code>, and <code>R</code> is the common type of <code>R1</code> and <code>R2</code>.</p>"},{"location":"reference/math/#remainder","title":"<code>remainder</code>","text":"<p>A unit-aware adaptation of <code>std::remainder</code>, giving the zero-centered remainder of the division of the two inputs.</p> <p>As with the integer modulus, we first express the inputs in their common unit.</p> <p>Signature:</p> <pre><code>template &lt;typename U1, typename R1, typename U2, typename R2&gt;\nauto remainder(Quantity&lt;U1, R1&gt; q1, Quantity&lt;U2, R2&gt; q2);\n</code></pre> <p>Returns: The remainder of <code>q1 / q2</code>, in the type <code>Quantity&lt;U, R&gt;</code>, where <code>U</code> is the common unit of <code>U1</code> and <code>U2</code>, and <code>R</code> is the common type of <code>R1</code> and <code>R2</code>.</p> <ol> <li> <p>These signatures are for purposes of illustration, not completeness.  In the real code, there are additional signatures covering the case of identical inputs.  We need these in order to disambiguate our <code>min</code> or <code>max</code> implementations with respect to <code>std::min</code> and <code>std::max</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/powers/","title":"Powers","text":"<p>Several of our monovalue types (such as units and magnitudes) can be raised to powers. This includes negative exponents (such as the inverse), and fractional exponents (such as roots).</p> <p>When expressed as values (as opposed to types), we provide the same APIs for each of them.</p>"},{"location":"reference/powers/#general-apis","title":"General APIs","text":"<p>In what follows, <code>x</code> stands for an instance of the appropriate monovalue type.  For example, it might be <code>Meters{}</code> (a unit), <code>mag&lt;18&gt;()</code> (a magnitude), or some other type.</p>"},{"location":"reference/powers/#pownx","title":"<code>pow&lt;N&gt;(x)</code>","text":"<p>Raise the input <code>x</code> to the <code>N</code>th power.</p> <p>Example signature:</p> <pre><code>// T is an appropriate monovalue type (a unit, a magnitude, ...).\ntemplate&lt;std::intmax_t N, typename T&gt;\nconstexpr auto pow(T);\n</code></pre> <p>Result: An instance of the Nth power of the type of <code>x</code>.</p> <p>Example</p> <p><code>pow&lt;3&gt;(mag&lt;4&gt;())</code> yields <code>mag&lt;64&gt;()</code>.</p>"},{"location":"reference/powers/#rootnx","title":"<code>root&lt;N&gt;(x)</code>","text":"<p>Take the Nth root of the input.</p> <p>Example signature:</p> <pre><code>// T is an appropriate monovalue type (a unit, a magnitude, ...).\ntemplate&lt;std::intmax_t N, typename T&gt;\nconstexpr auto root(T);\n</code></pre> <p>Result: An instance of the Nth root of the type of <code>x</code>.</p> <p>Example</p> <p><code>root&lt;2&gt;(mag&lt;49&gt;())</code> yields <code>mag&lt;7&gt;()</code>.</p>"},{"location":"reference/powers/#helpers","title":"Helpers (<code>inverse</code>, <code>squared</code>, <code>cubed</code>, <code>sqrt</code>, <code>cbrt</code>)","text":"<p>Some powers and roots are very common.  It\u2019s useful to have shortcuts for these to make the code more readable.  The following helpers are available to operate on an instance, <code>x</code>, of any compatible monovalue type (a unit, a magnitude, \u2026):</p> Helper Result <code>inverse(x)</code> <code>pow&lt;-1&gt;(x)</code> <code>squared(x)</code> <code>pow&lt;2&gt;(x)</code> <code>cubed(x)</code> <code>pow&lt;3&gt;(x)</code> <code>sqrt(x)</code> <code>root&lt;2&gt;(x)</code> <code>cbrt(x)</code> <code>root&lt;3&gt;(x)</code>"},{"location":"reference/prefix/","title":"Prefix","text":"<p>A \u201cprefix\u201d scales a unit by some magnitude, and prepends a prefix symbol to the unit\u2019s label.</p>"},{"location":"reference/prefix/#applying-to-unit-types","title":"Applying to unit types","text":"<p>To apply a prefix to a unit type, pass that unit as a template parameter to the prefix.  This results in a new unit with the following properties:</p> <ol> <li> <p>The label for the new unit is the label for the input unit, with the prefix symbol    prepended.</p> </li> <li> <p>The magnitude of the new unit is the magnitude of the input unit, scaled by the scaling    factor.</p> </li> </ol> <p>Example: <code>Centi</code> and <code>Meters</code></p> <p><code>Centi</code> is a prefix whose prefix symbol is <code>c</code>, and whose scaling factor is 1/100.</p> <p><code>Meters</code> is a unit whose symbol is <code>m</code>.</p> <p>Therefore, <code>Centi&lt;Meters&gt;</code> is a unit whose symbol is <code>cm</code>, and whose magnitude is 1/100\\,\\text{m}.</p>"},{"location":"reference/prefix/#prefix-applier","title":"Applying to instances: the \u201cprefix applier\u201d","text":"<p>Au uses many kinds of instances, not just types.  These include QuantityMaker, QuantityPointMaker, <code>SingularNameFor</code>, and even instances of unit types.</p> <p>Instances are naturally used as function parameters, not template parameters.  Therefore, for each prefix, we provide a \u201cprefix applier\u201d which can be called as a function.  For any of the above kinds of inputs, the prefix applier returns the same kind, but in the prefixed unit.</p> <p>Let\u2019s return to the example of <code>Centi</code> and <code>Meters</code>.  The prefix applier for <code>Centi</code> is spelled <code>centi</code>: note that we use snake_case, rather than CamelCase.  Here are the various ways a prefix applier can be used.</p> Kind of input Example (meters) Application Example use Unit instance <code>Meters{}</code> <code>centi(Meters{})</code> <code>length.as(Centi&lt;Meters&gt;{})</code> <code>QuantityMaker</code> <code>meters</code> <code>centi(meters)</code> <code>centi(meters)(170)</code> <code>QuantityPointMaker</code> <code>meters_pt</code> <code>centi(meters_pt)</code> <code>centi(meters_pt)(1.5)</code> <code>SingularNameFor</code> <code>meter</code> <code>centi(meter)</code> <code>curvature.in(radians / centi(meter))</code> <code>SymbolFor</code> <code>m</code> <code>centi(m)</code> <code>constexpr auto cm = centi(m); 170 * cm</code> <p>Note again that every output here is the same kind of thing as the input.  So, <code>centi(meters_pt)</code> is a <code>QuantityPointMaker</code>, and <code>centi(meters_pt)(1.5)</code> creates a <code>QuantityPoint</code> of 1.5\\,\\text{cm}.</p>"},{"location":"reference/prefix/#list-of-supported-prefixes","title":"List of supported prefixes","text":"<p>We support every SI prefix and binary prefix.</p>"},{"location":"reference/prefix/#si-prefixes","title":"SI prefixes","text":"Prefix Prefix applier Prefix symbol Scaling factor <code>Quetta</code> <code>quetta</code> <code>Q</code> 10^{30} <code>Ronna</code> <code>ronna</code> <code>R</code> 10^{27} <code>Yotta</code> <code>yotta</code> <code>Y</code> 10^{24} <code>Zetta</code> <code>zetta</code> <code>Z</code> 10^{21} <code>Exa</code> <code>exa</code> <code>E</code> 10^{18} <code>Peta</code> <code>peta</code> <code>P</code> 10^{15} <code>Tera</code> <code>tera</code> <code>T</code> 10^{12} <code>Giga</code> <code>giga</code> <code>G</code> 10^{9} <code>Mega</code> <code>mega</code> <code>M</code> 10^{6} <code>Kilo</code> <code>kilo</code> <code>k</code> 10^{3} <code>Hecto</code> <code>hecto</code> <code>h</code> 10^{2} <code>Deka</code> <code>deka</code> <code>da</code> 10^{1} <code>Deci</code> <code>deci</code> <code>d</code> 10^{-1} <code>Centi</code> <code>centi</code> <code>c</code> 10^{-2} <code>Milli</code> <code>milli</code> <code>m</code> 10^{-3} <code>Micro</code> <code>micro</code> <code>u</code> 10^{-6} <code>Nano</code> <code>nano</code> <code>n</code> 10^{-9} <code>Pico</code> <code>pico</code> <code>p</code> 10^{-12} <code>Femto</code> <code>femto</code> <code>f</code> 10^{-15} <code>Atto</code> <code>atto</code> <code>a</code> 10^{-18} <code>Zepto</code> <code>zepto</code> <code>z</code> 10^{-21} <code>Yocto</code> <code>yocto</code> <code>y</code> 10^{-24} <code>Ronto</code> <code>ronto</code> <code>r</code> 10^{-27} <code>Quecto</code> <code>quecto</code> <code>q</code> 10^{-30}"},{"location":"reference/prefix/#binary-prefixes","title":"Binary prefixes","text":"Prefix Prefix applier Prefix symbol Scaling factor <code>Yobi</code> <code>yobi</code> <code>Yi</code> 2^{80} (\\approx 10^{24}) <code>Zebi</code> <code>zebi</code> <code>Zi</code> 2^{70} (\\approx 10^{21}) <code>Exbi</code> <code>exbi</code> <code>Ei</code> 2^{60} (\\approx 10^{18}) <code>Pebi</code> <code>pebi</code> <code>Pi</code> 2^{50} (\\approx 10^{15}) <code>Tebi</code> <code>tebi</code> <code>Ti</code> 2^{40} (\\approx 10^{12}) <code>Gibi</code> <code>gibi</code> <code>Gi</code> 2^{30} (\\approx 10^{9}) <code>Mebi</code> <code>mebi</code> <code>Mi</code> 2^{20} (\\approx 10^{6}) <code>Kibi</code> <code>kibi</code> <code>Ki</code> 2^{10} (\\approx 10^{3})"},{"location":"reference/quantity/","title":"Quantity","text":"<p><code>Quantity</code> is our workhorse type.  It combines a runtime numeric value with compile-time information about the units of measure in which that quantity is expressed.</p> <p><code>Quantity</code> comes with \u201cbatteries included\u201d.  We try to support as many operations as possible natively, to avoid incentivizing users to leave the safety of the units library.</p> <p><code>Quantity</code> is a template, <code>Quantity&lt;U, R&gt;</code>, with two parameters.  Both are typenames.</p> <ul> <li><code>U</code> is the unit: a type representing the unit of measure.</li> <li><code>R</code> is the \u201crep\u201d, a term we borrow from the <code>std::chrono</code>   library.  It\u2019s the underlying raw numeric type   which holds the wrapped value.</li> </ul> Handling temperatures <p>If you are working with temperatures \u2014 in the sense of \u201cwhat temperature is it?\u201d, rather than \u201chow much did the temperature change?\u201d \u2014 you will want to use <code>QuantityPoint</code> instead of <code>Quantity</code>.  For further useful background reading, see our quantity point discussion.</p>"},{"location":"reference/quantity/#naming-quantity-in-code","title":"Naming <code>Quantity</code> in code","text":"<p>You can use both template parameters directly (for example, <code>Quantity&lt;Meters, int&gt;</code>).  However, multiple template parameters can be awkward to read.  It can also give the parser some trouble when you\u2019re forced to use macros, as in googletest.  For that reason, we also provide \u201cRep-named aliases\u201d, so you can express the rep more precisely, and put the visual focus on the unit:</p> Rep-named alias Equivalent to: <code>QuantityD&lt;U&gt;</code> <code>Quantity&lt;U, double&gt;</code> <code>QuantityF&lt;U&gt;</code> <code>Quantity&lt;U, float&gt;</code> <code>QuantityI&lt;U&gt;</code> <code>Quantity&lt;U, int&gt;</code> <code>QuantityU&lt;U&gt;</code> <code>Quantity&lt;U, unsigned int&gt;</code> <code>QuantityI32&lt;U&gt;</code> <code>Quantity&lt;U, int32_t&gt;</code> <code>QuantityU32&lt;U&gt;</code> <code>Quantity&lt;U, uint32_t&gt;</code> <code>QuantityI64&lt;U&gt;</code> <code>Quantity&lt;U, int64_t&gt;</code> <code>QuantityU64&lt;U&gt;</code> <code>Quantity&lt;U, uint64_t&gt;</code> <p>For more practice with this, see Tutorial 102: API Types.</p>"},{"location":"reference/quantity/#constructing","title":"Constructing <code>Quantity</code>","text":"<p>There are several ways to construct a <code>Quantity</code> object.</p> <ul> <li>The preferred way, which we\u2019ll explain below, is to use a quantity maker.</li> <li>The other ways are all normal C++ constructors.</li> </ul> <p>One way you cannot construct a <code>Quantity</code> is via a constructor that takes a single raw number. Many users find this surprising at first, but it\u2019s important for safety and usability.  To learn more about this policy, expand the box below.</p> The \"missing\" raw number constructor <p>New users often expect <code>Quantity&lt;U, R&gt;</code> to be constructible from a raw value of type <code>R</code>.  For example, they expect to be able to write something like:</p> <pre><code>Quantity&lt;Meters, double&gt; height{3.0};  // Does NOT work in Au\n</code></pre> <p>This example looks innocuous, but enabling it would have other ill effects, and would be a net negative overall.</p> <p>First, we want to support a wide variety of reasonable usage patterns, safely.  One approach people sometimes take is to use dimension-named aliases throughout the codebase, making the actual underlying unit an encapsulated implementation detail.  Here\u2019s an example of what this looks like, which shows why we must forbid the default constructor:</p> <pre><code>// Store all lengths in meters using `double`, but as an implementation detail.\n// End users will simply call their type `Length`.\nusing Length = QuantityD&lt;Meters&gt;;\n\n// In some other file...\nLength l1{3.0};          // Does NOT work in Au --- good!\nLength l2 = meters(3.0); // Works; unambiguous.\n</code></pre> <p>We hope the danger is clear: there\u2019s no such concept as a \u201clength of 3\u201d.  For safety and clarity, the user must always name the unit at the callsite.</p> <p>The second reason is elaborated in the section, \u201c<code>explicit</code> is not explicit enough\u201d, from the standard units library proposal paper P3045R0.  Even if you don\u2019t use aliases for your quantities, you might sometimes have a vector of them.  If you do, the <code>.emplace_back()</code> function accepts a raw number.  Not only is this unclear at the callsite, but it can cause long-range (and silent!) errors if you later refactor the vector to hold a different type. By contrast, omitting this constructor forces the user to name the unit explicitly at the callsite, every time.  This keeps callsites unambiguous, minimizes cognitive load for the reader, and enables safe refactoring.</p> <p>Overall, despite the initial surprise of the \u201cmissing\u201d raw number constructor, experience shows that it\u2019s a net benefit.  Not only does its absence enhance safety, but thanks to the other construction methods, it also doesn\u2019t sacrifice usability!</p>"},{"location":"reference/quantity/#quantity-maker-preferred","title":"Quantity Maker (preferred)","text":"<p>The preferred way to construct a <code>Quantity</code> of a given unit is to use the quantity maker for that unit.  This is a callable whose name is the plural form of that unit, expressed in \u201csnake_case\u201d: for example, <code>nautical_miles</code>.  When you pass a raw numeric variable of type <code>T</code> to the quantity maker, it returns a <code>Quantity</code> of the unit it represents, whose rep type is <code>T</code>.</p> <p>Example</p> <p><code>nautical_miles(15)</code> returns a <code>Quantity&lt;NauticalMiles, int&gt;</code>.</p> <p>For more practice with quantity makers, see Tutorial 101: Quantity Makers.</p>"},{"location":"reference/quantity/#implicit-from-quantity","title":"Implicit constructor from another <code>Quantity</code>","text":"<p>This constructor performs a unit conversion.  The result will represent the same quantity as the input, but expressed in the units of the newly constructed object\u2019s type.  It will also convert the stored value to the rep of the constructed object, if necessary.</p> <p>Here is the signature.  We\u2019ve simplified it slightly for illustration purposes, and enclosed it inside the class definition for context.</p> <pre><code>template &lt;typename Unit, typename Rep&gt;\nclass Quantity {\n    template &lt;typename OtherUnit, typename OtherRep&gt;\n    Quantity(Quantity&lt;OtherUnit, OtherRep&gt; other);\n};\n</code></pre> <p>This constructor only exists when this unit-and-rep conversion is both meaningful and safe.  It can fail to exist in several ways.</p> <ol> <li> <p>If the input quantity has a different dimension, then the operation is intrinsically    meaningless and we forbid it.</p> </li> <li> <p>If the constructed quantity\u2019s rep (that is, <code>Rep</code> in the code snippet above) is not floating    point, then we forbid any conversion that might produce a non-integer value.  Examples include:</p> <p>a. When <code>OtherRep</code> is floating point, we forbid this conversion.</p> <p>b. When <code>UnitRatioT&lt;OtherUnit, Unit&gt;</code> is not an integer, we forbid this conversion.</p> </li> <li> <p>If we\u2019re performing an integer-to-integer conversion, and the conversion factor carries    a significant risk of overflowing the rep, we forbid the conversion.  This is the adaptive    \u201coverflow safety surface\u201d which we featured in our Au announcement blog    post.</p> </li> </ol> <p>These last two are examples of conversions that are physically meaningful, but forbidden due to the risk of larger-than-usual errors.  The library can still perform these conversions, but not via this constructor, and it must be \u201cforced\u201d to do so.  See <code>.coerce_as(unit)</code> for more details.</p>"},{"location":"reference/quantity/#constructing-from-zero","title":"Constructing from <code>Zero</code>","text":"<p>This constructs a <code>Quantity</code> with a value of 0.</p> <p>Here is the signature, enclosed in the class definition for context.</p> <pre><code>template &lt;typename Unit, typename Rep&gt;\nclass Quantity {\n    Quantity(Zero);\n};\n</code></pre> <p>Note</p> <p><code>Zero</code> is the name of the type.  At the callsite, you would pass an instance of that type, such as the constant <code>ZERO</code>.  For example:</p> <pre><code>QuantityD&lt;Meters&gt; height{ZERO};\n</code></pre> <p>For more information on the motivation and use of this type, read our <code>Zero</code> discussion.</p>"},{"location":"reference/quantity/#default-constructor","title":"Default constructor","text":"<p>Here is the signature of the constructor, enclosed in the class template definition for context.</p> <pre><code>template &lt;typename Unit, typename Rep&gt;\nclass Quantity {\n    Quantity();\n};\n</code></pre> <p>A default-constructed <code>Quantity</code> is always initialized (which helps avoid certain kinds of memory safety bugs).  It will contain a default-constructed instance of the rep type.</p> <p>Warning</p> <p>Avoid relying on the specific value of a default-constructed <code>Quantity</code>, because it poorly communicates intent.  The only logically valid operation on a default-constructed <code>Quantity</code> is to assign to it later on.</p> <p>The default value for many rep types, including all fundamental arithmetic types, is <code>0</code>. Instead of relying on this behaviour, initialize your <code>Quantity</code> with <code>au::ZERO</code> to better communicate your intent.</p>"},{"location":"reference/quantity/#constructing-from-corresponding-quantity","title":"Constructing from corresponding quantity","text":"<p>Here is the signature.  We\u2019ve simplified it slightly for illustration purposes, and enclosed it inside the class definition for context.</p> <pre><code>template &lt;typename Unit, typename Rep&gt;\nclass Quantity {\n    template &lt;typename T&gt;\n    Quantity(T &amp;&amp;x);\n    // NOTE: only exists when `T` is an \"exactly-equivalent\" type.  One example:\n    // `std::chrono::nanoseconds` can construct an `au::QuantityI64&lt;Nano&lt;Seconds&gt;&gt;`.\n};\n</code></pre> <p>This constructor will only exist when <code>T</code> has a \u201ccorresponding quantity\u201d, and this <code>Quantity</code> type is implicitly constructible from that \u201ccorresponding quantity\u201d type by the above mechanism.</p>"},{"location":"reference/quantity/#extracting-the-stored-value","title":"Extracting the stored value","text":"<p>In order to access the raw numeric value stored inside of <code>Quantity</code>, you must explicitly name the unit at the callsite.  There are two functions which can do this, depending on whether you want to access by value or by reference.</p>"},{"location":"reference/quantity/#extracting-with-in","title":"By value: <code>.in(unit)</code>","text":"<p>This function returns the underlying stored value, by value.  See the unit slots discussion for valid choices for <code>unit</code>.</p> Example: extracting <code>4.56</code> from <code>seconds(4.56)</code> <p>Consider this <code>Quantity&lt;Seconds, double&gt;</code>:</p> <pre><code>auto t = seconds(4.56);\n</code></pre> <p>You can retrieve the underlying value by writing either <code>t.in(seconds)</code> (passing the <code>QuantityMaker</code>), or <code>t.in(Seconds{})</code> (passing an instance of the unit).</p>"},{"location":"reference/quantity/#by-reference-data_inunit","title":"By reference: <code>.data_in(unit)</code>","text":"<p>This function returns a reference to the underlying stored value.  See the unit slots discussion for valid choices for <code>unit</code>.</p> Example: incrementing the underlying stored value <pre><code>auto length = inches(60);\nlength.data_in(inches)++;\n</code></pre> <p>Since <code>length</code> is not <code>const</code>, the reference returned by <code>.data_in()</code> will be mutable, and we can treat it like any other <code>int</code> lvalue.  The above would result in <code>inches(61)</code>.</p>"},{"location":"reference/quantity/#performing-unit-conversions","title":"Performing unit conversions","text":"<p>We have two methods for performing unit conversions.  They have identical APIs, but their names are different.  <code>as</code> returns another <code>Quantity</code>, but <code>in</code> exits the library and returns a raw number.</p>"},{"location":"reference/quantity/#as","title":"<code>.as(unit)</code>, <code>.as&lt;T&gt;(unit)</code>","text":"<p>This function produces a new representation of the input <code>Quantity</code>, converted to the new unit. See the unit slots discussion for valid choices for <code>unit</code>.</p> Example: converting <code>feet(3)</code> to <code>inches</code> <p>Consider this <code>Quantity&lt;Feet, int&gt;</code>:</p> <pre><code>auto length = feet(3);\n</code></pre> <p>Then <code>length.as(inches)</code> re-expresses this quantity in units of inches.  Specifically, it returns a <code>Quantity&lt;Inches, int&gt;</code>, which is equal to <code>inches(36)</code>.</p> <p>The above example used the quantity maker, <code>inches</code>.  One could also use an instance of the unit type <code>Inches</code>, writing <code>length.as(Inches{})</code>.  The former is generally preferable; the latter is mainly useful in generic code where the unit type may be all you have.</p> <p>Without a template argument, <code>.as(unit)</code> obeys the same safety checks as for the implicit constructors: conversions at high risk for integer overflow or truncation are forbidden.  Additionally, the <code>Rep</code> of the output is identical to the <code>Rep</code> of the input.</p> <p>With a template argument, <code>.as&lt;T&gt;(unit)</code> has two differences.</p> <ol> <li>The output <code>Rep</code> will be <code>T</code>.</li> <li>The conversion is considered \u201cforcing\u201d, and will be permitted in spite of any overflow or    truncation risk.  The semantics are similar to <code>static_cast&lt;T&gt;</code>.</li> </ol> <p>However, note that we may change this second property in the future.  The version with the template arguments may be changed later so that it does prevent lossy conversions.  If you want this \u201cforcing\u201d semantic, prefer to use <code>.coerce_as(unit)</code>, and add the explicit template parameter only if you want to change the rep.  See #122 for more details.</p> Example: forcing a conversion from inches to feet <p><code>inches(24).as(feet)</code> is not allowed.  This conversion will divide the underlying value, <code>24</code>, by <code>12</code>.  Now, it so happens that this particular value would produce an integer result. However, the compiler must decide whether to permit this operation at compile time, which means we don\u2019t yet know the value.  Since most <code>int</code> values would not produce integer results, we forbid this.</p> <p><code>inches(24).as&lt;int&gt;(feet)</code> is allowed.  The \u201cexplicit rep\u201d template parameter has \u201cforcing\u201d semantics.  This would produce <code>feet(2)</code>.  However, note that this operation uses integer division, which truncates: so, for example, <code>inches(23).as&lt;int&gt;(feet)</code> would produce <code>feet(1)</code>.</p> <p>Tip</p> <p>Prefer to omit the template argument if possible, because you will get more safety checks. The risks which the no-template-argument version warns about are real.</p>"},{"location":"reference/quantity/#inunit-intunit","title":"<code>.in(unit)</code>, <code>.in&lt;T&gt;(unit)</code>","text":"<p>This function produces the value of the <code>Quantity</code>, re-expressed in the new unit.  <code>unit</code> can be either a <code>QuantityMaker</code> for the quantity\u2019s unit, or an instance of the unit itself. See the unit slots discussion for valid choices for <code>unit</code>.</p> Example: getting the value of <code>feet(3)</code> in <code>inches</code> <p>Consider this <code>Quantity&lt;Feet, int&gt;</code>:</p> <pre><code>auto length = feet(3);\n</code></pre> <p>Then <code>length.in(inches)</code> converts this quantity to inches, and returns the value, <code>36</code>, as an <code>int</code>.</p> <p>The above example used the quantity maker, <code>inches</code>.  One could also use an instance of the unit type <code>Inches</code>, writing <code>length.in(Inches{})</code>.  The former is generally preferable; the latter is mainly useful in generic code where the unit type may be all you have.</p> <p>Without a template argument, <code>.in(unit)</code> obeys the same safety checks as for the implicit constructors: conversions at high risk for integer overflow or truncation are forbidden.  Additionally, the <code>Rep</code> of the output is identical to the <code>Rep</code> of the input.</p> <p>With a template argument, <code>.in&lt;T&gt;(unit)</code> has two differences.</p> <ol> <li>The output type will be <code>T</code>.</li> <li>The conversion is considered \u201cforcing\u201d, and will be permitted in spite of any overflow or    truncation risk.  The semantics are similar to <code>static_cast&lt;T&gt;</code>.</li> </ol> <p>However, note that we may change this second property in the future.  The version with the template arguments may be changed later so that it does prevent lossy conversions.  If you want this \u201cforcing\u201d semantic, prefer to use <code>.coerce_in(unit)</code>, and add the explicit template parameter only if you want to change the rep.  See #122 for more details.</p> Example: forcing a conversion from inches to feet <p><code>inches(24).in(feet)</code> is not allowed.  This conversion will divide the underlying value, <code>24</code>, by <code>12</code>.  Now, it so happens that this particular value would produce an integer result. However, the compiler must decide whether to permit this operation at compile time, which means we don\u2019t yet know the value.  Since most <code>int</code> values would not produce integer results, we forbid this.</p> <p><code>inches(24).in&lt;int&gt;(feet)</code> is allowed.  The \u201cexplicit rep\u201d template parameter has \u201cforcing\u201d semantics (at least for now; see #122). This would produce <code>2</code>.  However, note that this operation uses integer division, which truncates: so, for example, <code>inches(23).in&lt;int&gt;(feet)</code> would produce <code>1</code>.</p> <p>Tip</p> <p>Prefer to omit the template argument if possible, because you will get more safety checks. The risks which the no-template-argument version warns about are real.</p>"},{"location":"reference/quantity/#coerce","title":"Forcing lossy conversions: <code>.coerce_as(unit)</code>, <code>.coerce_in(unit)</code>","text":"<p>This function performs the exact same kind of unit conversion as if the string <code>coerce_</code> were removed.  However, it will ignore any safety checks for overflow or truncation.</p> Example: forcing a conversion from inches to feet <p><code>inches(24).as(feet)</code> is not allowed.  This conversion will divide the underlying value, <code>24</code>, by <code>12</code>.  While this particular value would produce an integer result, most other <code>int</code> values would not.  Because our result uses <code>int</code> for storage \u2014 same as the input \u2014 we forbid this.</p> <p><code>inches(24).coerce_as(feet)</code> is allowed.  The <code>coerce_</code> prefix has \u201cforcing\u201d semantics.  This would produce <code>feet(2)</code>.  However, note that this operation uses integer division, which truncates: so, for example, <code>inches(23).coerce_as(feet)</code> would produce <code>feet(1)</code>.</p> <p>These functions also support an explicit template parameter: so, <code>.coerce_as&lt;T&gt;(unit)</code> and <code>.coerce_in&lt;T&gt;(unit)</code>.  If you supply this parameter, it will be the rep of the result.</p> Example: simultaneous unit and type conversion <p><code>inches(27.8).coerce_as&lt;int&gt;(feet)</code> will return <code>feet(2)</code>.</p> <p>Tip</p> <p>Prefer not to use the \u201ccoercing versions\u201d if possible, because you will get more safety checks.  The risks which the \u201cbase\u201d versions warn about are real.</p>"},{"location":"reference/quantity/#nttp","title":"Non-Type Template Parameters (NTTPs)","text":"<p>A non-type template parameter (NTTP) is a template parameter that is not a type, but rather some kind of value.  Common examples include <code>template&lt;int N&gt;</code>, or <code>template&lt;bool B&gt;</code>.  Before C++20, only a small number of types could be used as NTTPs: very roughly, these were integral types, pointer types, and enumerations.</p> <p>Au provides a workaround for pre-C++20 users that lets you effectively encode any <code>Quantity&lt;U, R&gt;</code> as an NTTP, as long as its rep <code>R</code> is an integral type.  To do this, use the <code>Quantity&lt;U, R&gt;::NTTP</code> type as the template parameter.  You will be able to assign between <code>Quantity&lt;U, R&gt;</code> and <code>Quantity&lt;U, R&gt;::NTTP</code>, in either direction, but only in the case of exact match of both <code>U</code> and <code>R</code>.  For all other cases, you\u2019ll need to perform a conversion (using the usual mechanisms for <code>Quantity</code> described elsewhere on this page).</p> <p>Warning</p> <p>It is undefined behavior to invoke <code>Quantity&lt;U, R&gt;::NTTP</code> whenever <code>std::is_integral&lt;R&gt;::value</code> is <code>false</code>.</p> <p>We cannot strictly prevent users from doing this.  However, in practice, it is very unlikely for this to happen by accident.  Both conversion operators between <code>Quantity&lt;U, R&gt;</code> and <code>Quantity&lt;U, R&gt;::NTTP</code> would fail with a hard compiler error, based on a <code>static_assert</code> that explains this situation.  So users can name this type, but they cannot assign to it or from it without prohibitive difficulty.</p> Example: defining and using a template with a <code>Quantity</code> NTTP <pre><code>template &lt;QuantityI&lt;Hertz&gt;::NTTP Frequency&gt;\nstruct TemplatedOnFrequency {\n    QuantityI&lt;Hertz&gt; value = Frequency;      // Assigning `Quantity` from NTTP\n};\n\nusing T = TemplatedOnFrequency&lt;hertz(440)&gt;;  // Setting template parameter from `Quantity`\n</code></pre>"},{"location":"reference/quantity/#from_nttpquantityu-rnttp","title":"<code>from_nttp(Quantity&lt;U, R&gt;::NTTP)</code>","text":"<p>Calling <code>from_nttp</code> on a <code>Quantity&lt;U, R&gt;::NTTP</code> will convert it back into the corresponding <code>Quantity&lt;U, R&gt;</code> that was encoded in the template parameter.  This lets it automatically participate in all of the usual <code>Quantity</code> operations and conversions.</p> <p>Note</p> <p>If you are simply assigning a <code>Quantity&lt;U, R&gt;::NTTP</code> to a <code>Quantity&lt;U, R&gt;</code>, where <code>U</code> and <code>R</code> are identical, you do not need to call <code>from_nttp</code>.  We support implcit conversion in that case.</p>"},{"location":"reference/quantity/#operations","title":"Operations","text":"<p>Au includes as many common operations as possible.  Our goal is to avoid incentivizing users to leave the safety of the library.</p> <p>Recall that there are two main categories of operation: \u201carbitrary unit\u201d operations, and \u201ccommon unit\u201d operations.</p>"},{"location":"reference/quantity/#comparison","title":"Comparison","text":"<p>Comparison is a common unit operation.  If the input <code>Quantity</code> types are not identical \u2014 same <code>Unit</code> and <code>Rep</code> \u2014 then we first convert them to their common type. Then, we perform the comparison by delegating to the comparison operator on the underlying values.</p> <p>If either input is a non-<code>Quantity</code> type <code>T</code>, but it has a <code>CorrespondingQuantity</code>, then that input can participate as if it were its corresponding quantity.</p> Example of corresponding quantity comparison <p>We provide built-in equivalence with <code>std::chrono::duration</code> types.  Therefore, this comparison will work:</p> <pre><code>const bool greater = std::chrono::duration&lt;double&gt;{1.0} &gt; milli(seconds)(999.9f);\n</code></pre> <p>Here, the <code>std::chrono::duration</code> variable will be treated identically to <code>seconds(1.0)</code>. The comparison will take place in units of <code>milli(seconds)</code> (since that is the common unit), and using a Rep of <code>double</code> (since that is <code>std::common_type_t&lt;double, float&gt;</code>).  The variable <code>greater</code> will hold the value <code>true</code>.</p> <p>We support the following binary comparison operators:</p> <ul> <li><code>==</code></li> <li><code>!=</code></li> <li><code>&gt;</code></li> <li><code>&gt;=</code></li> <li><code>&lt;</code></li> <li><code>&lt;=</code></li> </ul>"},{"location":"reference/quantity/#addition","title":"Addition","text":"<p>Addition is a common unit operation.  If the input <code>Quantity</code> types are not identical \u2014 same <code>Unit</code> and <code>Rep</code> \u2014 then we first convert them to their common type.  The result is a <code>Quantity</code> of this common type, whose value is the sum of the input values (after any common type conversions).</p> <p>If either input is a non-<code>Quantity</code> type <code>T</code>, but it has a <code>CorrespondingQuantity</code>, then that input can participate as if it were its corresponding quantity.</p>"},{"location":"reference/quantity/#subtraction","title":"Subtraction","text":"<p>Subtraction is a common unit operation.  If the input <code>Quantity</code> types are not identical \u2014 same <code>Unit</code> and <code>Rep</code> \u2014 then we first convert them to their common type.  The result is a <code>Quantity</code> of this common type, whose value is the difference of the input values (after any common type conversions).</p> <p>If either input is a non-<code>Quantity</code> type <code>T</code>, but it has a <code>CorrespondingQuantity</code>, then that input can participate as if it were its corresponding quantity.</p>"},{"location":"reference/quantity/#multiplication","title":"Multiplication","text":"<p>Multiplication is an arbitrary unit operation.  This means you can reason independently about the units and the values.</p> <ul> <li>The output unit is the product of the input units.</li> <li>The output value is the product of the input values.<ul> <li>The output rep (storage type) is the same as the type of the product of the input reps.</li> </ul> </li> </ul> <p>The output is always a <code>Quantity</code> with this unit and rep, unless the units completely cancel out (returning a unitless unit).  If they do, then we return a raw number.</p> <p>If either input is a raw number, then it only affects the value, not the unit.  It\u2019s equivalent to a <code>Quantity</code> whose unit is a unitless unit.</p>"},{"location":"reference/quantity/#division","title":"Division","text":"<p>Division is an arbitrary unit operation. This means you can reason independently about the units and the values.</p> <ul> <li>The output unit is the quotient of the input units.</li> <li>The output value is the quotient of the input values.<ul> <li>The output rep (storage type) is the same as the type of the quotient of the input reps.</li> </ul> </li> </ul> <p>The output is always a <code>Quantity</code> with this unit and rep, unless the units completely cancel out (returning a unitless unit).  If they do, then we return a raw number.</p> <p>If either input is a raw number, then it only affects the value, not the unit.  It\u2019s equivalent to a <code>Quantity</code> whose unit is a unitless unit.</p>"},{"location":"reference/quantity/#unblock_int_div","title":"<code>unblock_int_div()</code>","text":"<p>Experience has shown that raw integer division can be dangerous in a units library context.  It conflicts with intuitions, and can produce code that is silently and grossly incorrect: see the integer division section of the troubleshooting guide for an example.</p> <p>To use integer division, you must ask for it explicitly by name, by calling <code>unblock_int_div()</code> on the denominator.</p> Using <code>unblock_int_div()</code> to explicitly opt in to integer division <p>This will not work:</p> <pre><code>miles(125) / hours(2);\n//         ^--- Forbidden!  Compiler error.\n</code></pre> <p>However, this will work just fine:</p> <pre><code>miles(125) / unblock_int_div(hours(2));\n</code></pre> <p>It produces <code>(miles / hour)(62)</code>.</p>"},{"location":"reference/quantity/#unary-and-","title":"Unary <code>+</code> and <code>-</code>","text":"<p>For a <code>Quantity</code> instance <code>q</code>, you can apply a \u201cunary plus\u201d (<code>+q</code>) or \u201cunary minus\u201d (<code>-q</code>).  These produce a <code>Quantity</code> of the same type, with the unary plus or minus operator applied to the underlying value.</p>"},{"location":"reference/quantity/#shorthand-addition-and-subtraction-","title":"Shorthand addition and subtraction (<code>+=</code>, <code>-=</code>)","text":"<p>The input must be a <code>Quantity</code> which is implicitly convertible to the target <code>Quantity</code> type.  These operations first perform that conversion, and then replace the target <code>Quantity</code> with the result of that addition (for <code>+=</code>) or subtraction (for <code>-=</code>).</p>"},{"location":"reference/quantity/#shorthand-multiplication-and-division","title":"Shorthand multiplication and division (<code>*=</code>, <code>/=</code>)","text":"<p>The input must be a raw number which is implicitly convertible to the target <code>Quantity</code>\u2019s rep. These operations first perform that conversion, and then replace the target <code>Quantity</code> with the result of that multiplication (for <code>*=</code>) or division (for <code>/=</code>).</p>"},{"location":"reference/quantity/#automatic-conversion-to-rep","title":"Automatic conversion to <code>Rep</code>","text":"<p>For any <code>Quantity&lt;U, Rep&gt;</code>, if <code>U</code> is a unitless unit, we provide implicit conversion to <code>Rep</code>, which simply returns the underlying value.  This enables users to pass such a <code>Quantity</code> to an API expecting <code>Rep</code>.</p> <p>We do not provide this functionality for quantities of any other unit.  In particular \u2014 and unlike many other units libraries \u2014 we do not automatically convert other dimensionless units (such as <code>Percent</code>) to a raw number.  While this operation is intuitively appealing, experience shows that it does more harm than good.</p>"},{"location":"reference/quantity/#mod","title":"Mod (<code>%</code>)","text":"<p>The modulo operator, <code>%</code>, is the remainder of an integer division.  Au only defines this operator between two <code>Quantity</code> types, not between a <code>Quantity</code> and a raw number.</p> <p>More precisely, suppose we have instances of two <code>Quantity</code> types: <code>Quantity&lt;U1, R1&gt; q1</code> and <code>Quantity&lt;U2, R2&gt; q2</code>.  Then <code>q1 % q2</code> is defined only when:</p> <ol> <li><code>(R1{} % R2{})</code> is defined (that is, both <code>R1</code> and <code>R2</code> are integral types).</li> <li><code>CommonUnitT&lt;U1, U2&gt;</code> is defined (that is, <code>U1</code> and <code>U2</code> have the same dimension).</li> </ol> <p>When these conditions hold, the result is equivalent to first converting <code>q1</code> and <code>q2</code> to their common unit, and then computing the remainder from performing integer division on their values.</p> Why this policy? <p>We restrict to same-dimension quantities because this not only gives a meaningful answer, but the meaning of that answer is independent of the choice of units.  Take length as an example: we could imagine repeatedly subtracting <code>q2</code> from <code>q1</code> until we get a result that is smaller than <code>q2</code>.  This final result is the answer we seek.  It does not depend on the units for either quantity.</p> <p>The reason we express that answer in the common unit of <code>q1</code> and <code>q2</code> is because it\u2019s the simplest unit in which we can express it.  (Note that this is the same unit we would get from the operation of repeated subtraction as well, so this choice is consistent.)</p>"},{"location":"reference/quantity/#rep_cast","title":"<code>rep_cast</code>","text":"<p><code>rep_cast</code> performs a <code>static_cast</code> on the underlying value of a <code>Quantity</code>.  It is used to change the rep.</p> <p>Given any <code>Quantity&lt;U, R&gt; q</code> whose rep is <code>R</code>, then <code>rep_cast&lt;T&gt;(q)</code> gives a <code>Quantity&lt;U, T&gt;</code>, whose underlying value is <code>static_cast&lt;T&gt;(q.in(U{}))</code>.</p>"},{"location":"reference/quantity/#templates-and-traits","title":"Templates and Traits","text":""},{"location":"reference/quantity/#matching-typename-u-typename-r","title":"Matching: <code>typename U, typename R</code>","text":"<p>To specialize a template to match any <code>Quantity</code>, declare two template parameters: one for the unit, one for the rep.</p> Example: function template <pre><code>template &lt;typename U, typename R&gt;\nQuantity&lt;U, R&gt; negate(Quantity&lt;U, R&gt; q) {\n    return -q;\n}\n</code></pre> <p>This function template will match any <code>Quantity</code> specialization, and nothing else.</p> Example: type template <pre><code>// First, we need to declare the generic type template.  It matches a single type, `T`.\ntemplate &lt;typename T&gt;\nstruct Size;\n\n// Now we can declare a specialization that matches any `Quantity`, by templating on its unit\n// and rep.\ntemplate &lt;typename U, typename R&gt;\nstruct Size&lt;Quantity&lt;U, R&gt;&gt; {\n\n    // Note: this example uses inline variables, a C++17 feature.  It's just for illustration.\n    static constexpr inline std::size_t value = sizeof(R);\n};\n</code></pre> <p>In this way, <code>Size&lt;T&gt;::value</code> will exist only when <code>T</code> is some <code>Quantity</code> type (unless, of course, other specializations get defined elsewhere).</p>"},{"location":"reference/quantity/#rep","title":"<code>::Rep</code>","text":"<p>Every <code>Quantity</code> type has a public static alias, <code>::Rep</code>, which indicates its underlying storage type (or, its \u201crep\u201d).</p> Example <p><code>decltype(meters(5))::Rep</code> is <code>int</code>.</p>"},{"location":"reference/quantity/#unit","title":"<code>::Unit</code>","text":"<p>Every <code>Quantity</code> type has a public static alias, <code>::Unit</code>, which indicates its unit type.</p> Example <p><code>decltype(meters(5))::Unit</code> is <code>Meters</code>.</p>"},{"location":"reference/quantity/#unit_1","title":"<code>::unit</code>","text":"<p>Every <code>Quantity</code> type has a public static member variable, <code>::unit</code>, which is an instance of its unit type.</p> Example <p><code>decltype(meters(5))::unit</code> is <code>Meters{}</code>.</p>"},{"location":"reference/quantity/#common-type","title":"<code>std::common_type</code> specialization","text":"<p>For two <code>Quantity</code> types, one with unit <code>U1</code> and rep <code>R1</code>, and the other with unit <code>U2</code> and rep <code>R2</code>, then <code>std::common_type_t&lt;Quantity&lt;U1, R1&gt;, Quantity&lt;U2, R2&gt;&gt;</code> has the following properties.</p> <ol> <li> <p>It exists if and only if <code>U1</code> and <code>U2</code> have the same dimension.</p> </li> <li> <p>When it exists, it is <code>Quantity&lt;U, R&gt;</code>, where <code>U</code> is the common    unit of <code>U1</code> and <code>U2</code>, and <code>R</code> is <code>std::common_type_t&lt;R1,    R2&gt;</code>.</p> </li> </ol> <p>As required by the standard, our <code>std::common_type</code> specializations are SFINAE-friendly: improper combinations will simply not be present, rather than producing a hard error.</p>"},{"location":"reference/quantity/#are-quantity-types-equivalent","title":"AreQuantityTypesEquivalent","text":"<p>Result: Indicates whether two <code>Quantity</code> types are equivalent.  Equivalent types may be freely converted to each other, and no arithmetic operations will be performed in doing so.</p> <p>More precisely, <code>Quantity&lt;U1, R1&gt;</code> and <code>Quantity&lt;U2, R2&gt;</code> are equivalent if and only if both of the following conditions hold.</p> <ol> <li> <p>The units <code>U1</code> and <code>U2</code> are quantity-equivalent.</p> </li> <li> <p>The reps <code>R1</code> and <code>R2</code> are the same type.</p> </li> </ol> <p>Syntax:</p> <ul> <li>For types <code>U1</code> and <code>U2</code>:<ul> <li><code>AreQuantityTypesEquivalent&lt;U1, U2&gt;::value</code></li> </ul> </li> </ul>"},{"location":"reference/quantity_point/","title":"QuantityPoint","text":"<p><code>QuantityPoint</code> is our affine space type.  Common example use cases include temperatures and mile markers.  See our <code>QuantityPoint</code> discussion for a more detailed understanding.</p> <p><code>QuantityPoint</code> is a template, <code>QuantityPoint&lt;U, R&gt;</code>, with two parameters.  Both are typenames.</p> <ul> <li><code>U</code> is the unit: a type representing the unit of measure.</li> <li><code>R</code> is the \u201crep\u201d, a term we borrow from the <code>std::chrono</code>   library.  It\u2019s the underlying raw numeric type   which holds the wrapped value.</li> </ul>"},{"location":"reference/quantity_point/#naming-quantitypoint-in-code","title":"Naming <code>QuantityPoint</code> in code","text":"<p>You can use both template parameters directly (for example, <code>QuantityPoint&lt;Meters, int&gt;</code>).  However, multiple template parameters can be awkward to read.  It can also give the parser some trouble when you\u2019re forced to use macros, as in googletest.  For that reason, we also provide \u201cRep-named aliases\u201d, so you can express the rep more precisely, and put the visual focus on the unit:</p> Rep-named alias Equivalent to: <code>QuantityPointD&lt;U&gt;</code> <code>QuantityPoint&lt;U, double&gt;</code> <code>QuantityPointF&lt;U&gt;</code> <code>QuantityPoint&lt;U, float&gt;</code> <code>QuantityPointI&lt;U&gt;</code> <code>QuantityPoint&lt;U, int&gt;</code> <code>QuantityPointU&lt;U&gt;</code> <code>QuantityPoint&lt;U, unsigned int&gt;</code> <code>QuantityPointI32&lt;U&gt;</code> <code>QuantityPoint&lt;U, int32_t&gt;</code> <code>QuantityPointU32&lt;U&gt;</code> <code>QuantityPoint&lt;U, uint32_t&gt;</code> <code>QuantityPointI64&lt;U&gt;</code> <code>QuantityPoint&lt;U, int64_t&gt;</code> <code>QuantityPointU64&lt;U&gt;</code> <code>QuantityPoint&lt;U, uint64_t&gt;</code>"},{"location":"reference/quantity_point/#constructing","title":"Constructing <code>QuantityPoint</code>","text":"<p>There are three ways to construct a <code>QuantityPoint</code> object.</p> <ul> <li>The preferred way, which we\u2019ll explain below, is to use a quantity point maker.</li> <li>The other two ways are both normal C++ constructors.</li> </ul>"},{"location":"reference/quantity_point/#quantity-point-maker","title":"Quantity point maker (preferred)","text":"<p>The preferred way to construct a <code>QuantityPoint</code> of a given unit is to use the quantity point maker for that unit.  This is a callable whose name is the plural form of that unit, expressed in \u201csnake_case\u201d, and suffixed with <code>_pt</code> for \u201cpoint\u201d: for example, <code>fahrenheit_pt</code>.  When you pass a raw numeric variable of type <code>T</code> to the quantity point maker, it returns a <code>QuantityPoint</code> of the unit it represents, whose rep type is <code>T</code>.</p> <p>Example</p> <p><code>fahrenheit_pt(75)</code> returns a <code>QuantityPoint&lt;Fahrenheit, int&gt;</code>.</p>"},{"location":"reference/quantity_point/#implicit-from-quantity","title":"Implicit constructor from another <code>QuantityPoint</code>","text":"<p>This constructor performs a unit conversion.  The result will represent the same point as the input, but expressed in the units of the newly constructed object\u2019s type.  It will also convert the stored value to the rep of the constructed object, if necessary.</p> <p>Here is the signature of the constructor, slightly simplified for illustration purposes.  (We\u2019ve enclosed it in the class template definition to be clear about <code>Unit</code> and <code>Rep</code> in the discussion that follows.)</p> <pre><code>template &lt;typename Unit, typename Rep&gt;\nclass QuantityPoint {\n\n    // Implicit constructor signature (for illustration purposes):\n    template &lt;typename OtherUnit, typename OtherRep&gt;\n    QuantityPoint(QuantityPoint&lt;OtherUnit, OtherRep&gt; other);\n};\n</code></pre> <p>This constructor only exists when this unit-and-rep conversion is both meaningful and safe.  It can fail to exist in several ways.</p> <ol> <li> <p>If the input quantity has a different dimension, then the operation is intrinsically    meaningless and we forbid it.</p> </li> <li> <p>If the constructed quantity\u2019s rep (that is, <code>Rep</code> in the code snippet above) is not floating    point, then we forbid any conversion that might produce a non-integer value.  Examples include:</p> <p>a. When <code>OtherRep</code> is floating point, we forbid this conversion.</p> <p>b. When <code>UnitRatioT&lt;OtherUnit, Unit&gt;</code> is not an integer, we forbid this conversion.</p> <p>c. When the origin of <code>OtherUnit</code> is additively offset from the origin of <code>Unit</code> by an amount    that can\u2019t be represented as an integer in the target units, <code>Unit</code>, we forbid this    conversion.</p> </li> </ol> <p>Note that case <code>c</code> doesn\u2019t occur for <code>Quantity</code>; it is unique to <code>QuantityPoint</code>.</p> <p>We also inherit the \u201coverflow safety surface\u201d from the <code>Quantity</code> member inside of <code>QuantityPoint</code> (discussed as point 3 of the <code>Quantity</code> constructor docs). This can prevent certain quantity point conversions which have excessive overflow risk.</p> <p>Here are several examples to illustrate the conditions under which implicit conversions are allowed.</p> <p>Examples of <code>QuantityPoint</code> to <code>QuantityPoint</code> conversions</p> Source type Target type Implicit construction outcome <code>QuantityPoint&lt;Meters, double&gt;</code> <code>QuantityPoint&lt;Meters, int&gt;</code> Forbidden: <code>double</code> source not guaranteed to hold an integer value <code>QuantityPoint&lt;Milli&lt;Meters&gt;, int&gt;</code> Forbidden: point measured in \\text{mm} not generally an integer in \\text{m} \u2060 <code>QuantityPoint&lt;Kilo&lt;Meters&gt;, int&gt;</code> Permitted: point measured in \\text{km} guaranteed to be integer in \\text{m} \u2060 <code>QuantityPoint&lt;Celsius, int&gt;</code> <code>QuantityPoint&lt;Kelvins, int&gt;</code> Forbidden: Zero point offset from Kelvins to Celsius is 273.15\\,\\, \\text{K}, a non-integer number of Kelvins <code>QuantityPoint&lt;Kelvins, double&gt;</code> Permitted: target Rep is floating point, and can represent offset of 273.15\\,\\, \\text{K} <code>QuantityPoint&lt;Milli&lt;Kelvins&gt;, int&gt;</code> Permitted: offset in target units is 273,\\!150\\,\\, \\text{mK}, which is an integer <p>Note that every case in the above table is physically meaningful (because the source and target have the same dimension), but some conversions are forbidden due to the risk of larger-than-usual errors.  The library can still perform these conversions, but not via this constructor, and it must be \u201cforced\u201d to do so. See <code>.coerce_as(unit)</code> for more details.</p>"},{"location":"reference/quantity_point/#default-constructor","title":"Default constructor","text":"<p>Here is the signature of the constructor, enclosed in the class template definition for context.</p> <pre><code>template &lt;typename Unit, typename Rep&gt;\nclass QuantityPoint {\n    QuantityPoint();\n};\n</code></pre> <p>A default-constructed <code>QuantityPoint</code> is initialized to some value, which helps avoid certain kinds of memory safety bugs.  However, the value is contractually unspecified.  You can of course look up that value by reading the source code, but we may change it in the future, and we would not consider this to be a breaking change.  The only valid operation on a default-constructed <code>QuantityPoint</code> is to assign to it later on.</p>"},{"location":"reference/quantity_point/#extracting-the-stored-value","title":"Extracting the stored value","text":"<p>In order to access the raw numeric value stored inside of <code>QuantityPoint</code>, you must explicitly name the unit at the callsite.  There are two functions which can do this, depending on whether you want to access by value or by reference.</p>"},{"location":"reference/quantity_point/#extracting-with-in","title":"By value: <code>.in(unit)</code>","text":"<p>This function returns the underlying stored value, by value.  See the unit slots discussion for valid choices for <code>unit</code>.</p> Example: extracting <code>4.56</code> from <code>meters_pt(4.56)</code> <p>Consider this <code>QuantityPoint&lt;Meters, double&gt;</code>:</p> <pre><code>auto p = meters_pt(4.56);\n</code></pre> <p>You can retrieve the underlying value by writing either <code>p.in(meters_pt)</code> (passing the <code>QuantityPointMaker</code>), or <code>p.in(Meters{})</code> (passing an instance of the unit).</p>"},{"location":"reference/quantity_point/#by-reference-data_inunit","title":"By reference: <code>.data_in(unit)</code>","text":"<p>This function returns a reference to the underlying stored value.  See the unit slots discussion for valid choices for <code>unit</code>.</p> Example: incrementing the underlying stored value <pre><code>auto temperature = celsius_pt(20);\ntemperature.data_in(celsius_pt)++;\n</code></pre> <p>Since <code>temperature</code> is not <code>const</code>, the reference returned by <code>.data_in()</code> will be mutable, and we can treat it like any other <code>int</code> lvalue.  The above would result in <code>celsius_pt(21)</code>.</p>"},{"location":"reference/quantity_point/#performing-unit-conversions","title":"Performing unit conversions","text":"<p>We have two methods for performing unit conversions.  They have identical APIs, but their names are different.  <code>as</code> returns another <code>QuantityPoint</code>, but <code>in</code> exits the library and returns a raw number.</p>"},{"location":"reference/quantity_point/#as","title":"<code>.as(unit)</code>, <code>.as&lt;T&gt;(unit)</code>","text":"<p>This function produces a new representation of the input <code>QuantityPoint</code>, converted to the new unit. See the unit slots discussion for valid choices for <code>unit</code>.</p> Example: converting <code>meters_pt(3)</code> to <code>centi(meters_pt)</code> <p>Consider this <code>QuantityPoint&lt;Meters, int&gt;</code>:</p> <pre><code>auto point = meters_pt(3);\n</code></pre> <p>Then <code>point.as(centi(meters_pt))</code> re-expresses this quantity in units of centimeters. Specifically, it returns a <code>QuantityPoint&lt;Centi&lt;Meters&gt;, int&gt;</code>, which is equal to <code>centi(meters_pt)(300)</code>.</p> <p>The above example used the quantity maker, <code>centi(meters_pt)</code>.  One could also use an instance of the unit type <code>Centi&lt;Meters&gt;</code>, writing <code>point.as(Centi&lt;Meters&gt;{})</code>.  The former is generally preferable; the latter is mainly useful in generic code where the unit type may be all you have.</p> <p>Without a template argument, <code>.as(unit)</code> obeys the same safety checks as for the implicit constructors: conversions at high risk for integer overflow or truncation are forbidden.  Additionally, the <code>Rep</code> of the output is identical to the <code>Rep</code> of the input.</p> <p>With a template argument, <code>.as&lt;T&gt;(unit)</code> has two differences.</p> <ol> <li>The output <code>Rep</code> will be <code>T</code>.</li> <li>The conversion is considered \u201cforcing\u201d, and will be permitted in spite of any overflow or    truncation risk.  The semantics are similar to <code>static_cast&lt;T&gt;</code>.</li> </ol> <p>However, note that we may change this second property in the future.  The version with the template arguments may be changed later so that it does prevent lossy conversions.  If you want this \u201cforcing\u201d semantic, prefer to use <code>.coerce_as(unit)</code>, and add the explicit template parameter only if you want to change the rep.  See #122 for more details.</p> Example: forcing a conversion from centimeters to meters <p><code>centi(meters_pt)(200).as(meters_pt)</code> is not allowed.  This conversion will divide the underlying value, <code>200</code>, by <code>100</code>.  Now, it so happens that this particular value would produce an integer result. However, the compiler must decide whether to permit this operation at compile time, which means we don\u2019t yet know the value.  Since most <code>int</code> values would not produce integer results, we forbid this.</p> <p><code>centi(meters_pt)(200).as&lt;int&gt;(meters_pt)</code> is allowed.  The \u201cexplicit rep\u201d template parameter has \u201cforcing\u201d semantics.  This would produce <code>meters_pt(2)</code>. However, note that this operation uses integer division, which truncates: so, for example, <code>centi(meters_pt)(199).as&lt;int&gt;(meters_pt)</code> would produce <code>meters_pt(1)</code>.</p> <p>Tip</p> <p>Prefer to omit the template argument if possible, because you will get more safety checks. The risks which the no-template-argument version warns about are real.</p>"},{"location":"reference/quantity_point/#inunit-intunit","title":"<code>.in(unit)</code>, <code>.in&lt;T&gt;(unit)</code>","text":"<p>This function produces the value of the <code>QuantityPoint</code>, re-expressed in the new unit.  <code>unit</code> can be either a <code>QuantityPointMaker</code> for the quantity\u2019s unit, or an instance of the unit itself. See the unit slots discussion for valid choices for <code>unit</code>.</p> Example: getting the value of <code>meters_pt(3)</code> in <code>centi(meters_pt)</code> <p>Consider this <code>QuantityPoint&lt;Meters, int&gt;</code>:</p> <pre><code>auto point = meters_pt(3);\n</code></pre> <p>Then <code>point.in(centi(meters_pt))</code> converts this quantity to centimeters, and returns the value, <code>300</code>, as an <code>int</code>.</p> <p>The above example used the quantity maker, <code>centi(meters_pt)</code>.  One could also use an instance of the unit type <code>Centi&lt;Meters&gt;</code>, writing <code>point.in(Centi&lt;Meters&gt;{})</code>.  The former is generally preferable; the latter is mainly useful in generic code where the unit type may be all you have.</p> <p>Without a template argument, <code>.in(unit)</code> obeys the same safety checks as for the implicit constructors: conversions at high risk for integer overflow or truncation are forbidden.  Additionally, the <code>Rep</code> of the output is identical to the <code>Rep</code> of the input.</p> <p>With a template argument, <code>.in&lt;T&gt;(unit)</code> has two differences.</p> <ol> <li>The output type will be <code>T</code>.</li> <li>The conversion is considered \u201cforcing\u201d, and will be permitted in spite of any overflow or    truncation risk.  The semantics are similar to <code>static_cast&lt;T&gt;</code>.</li> </ol> <p>However, note that we may change this second property in the future.  The version with the template arguments may be changed later so that it does prevent lossy conversions.  If you want this \u201cforcing\u201d semantic, prefer to use <code>.coerce_in(unit)</code>, and add the explicit template parameter only if you want to change the rep.  See #122 for more details.</p> Example: forcing a conversion from centimeters to meters <p><code>centi(meters_pt)(200).in(meters_pt)</code> is not allowed.  This conversion will divide the underlying value, <code>200</code>, by <code>100</code>.  Now, it so happens that this particular value would produce an integer result. However, the compiler must decide whether to permit this operation at compile time, which means we don\u2019t yet know the value.  Since most <code>int</code> values would not produce integer results, we forbid this.</p> <p><code>centi(meters_pt)(200).in&lt;int&gt;(meters_pt)</code> is allowed.  The \u201cexplicit rep\u201d template parameter has \u201cforcing\u201d semantics (at least for now; see #122).  This would produce <code>2</code>. However, note that this operation uses integer division, which truncates: so, for example, <code>centi(meters_pt)(199).in&lt;int&gt;(meters_pt)</code> would produce <code>1</code>.</p> <p>Tip</p> <p>Prefer to omit the template argument if possible, because you will get more safety checks. The risks which the no-template-argument version warns about are real.</p>"},{"location":"reference/quantity_point/#coerce","title":"Forcing lossy conversions: <code>.coerce_as(unit)</code>, <code>.coerce_in(unit)</code>","text":"<p>This function performs the exact same kind of unit conversion as if the string <code>coerce_</code> were removed.  However, it will ignore any safety checks for overflow or truncation.</p> Example: forcing a conversion from centimeters to meters <p><code>centi(meters_pt)(200).in(meters_pt)</code> is not allowed.  This conversion will divide the underlying value, <code>200</code>, by <code>100</code>.  Now, it so happens that this particular value would produce an integer result. However, the compiler must decide whether to permit this operation at compile time, which means we don\u2019t yet know the value.  Since most <code>int</code> values would not produce integer results, we forbid this.</p> <p><code>centi(meters_pt)(200).coerce_in(meters_pt)</code> is allowed.  The <code>coerce_</code> prefix has \u201cforcing\u201d semantics.  This would produce <code>2</code>. However, note that this operation uses integer division, which truncates: so, for example, <code>centi(meters_pt)(199).coerce_in(meters_pt)</code> would produce <code>1</code>.</p> <p>These functions also support an explicit template parameter: so, <code>.coerce_as&lt;T&gt;(unit)</code> and <code>.coerce_in&lt;T&gt;(unit)</code>.  If you supply this parameter, it will be the rep of the result.</p> Example: simultaneous unit and type conversion <p><code>centi(meters_pt)(271.8).coerce_as&lt;int&gt;(meters_pt)</code> will return <code>meters_pt(2)</code>.</p> <p>Tip</p> <p>Prefer not to use the \u201ccoercing versions\u201d if possible, because you will get more safety checks.  The risks which the \u201cbase\u201d versions warn about are real.</p>"},{"location":"reference/quantity_point/#operations","title":"Operations","text":"<p>Au includes as many common operations as possible.  Our goal is to avoid incentivizing users to leave the safety of the library.</p> <p>Recall that for <code>Quantity</code>, there are two main categories of operation: \u201carbitrary unit\u201d operations, and \u201ccommon unit\u201d operations.  However, <code>QuantityPoint</code> is different.  Since multiplication, division, and powers are generally meaningless, we don\u2019t have any \u201carbitrary unit\u201d operations: every operation is a \u201ccommon unit\u201d operation.</p>"},{"location":"reference/quantity_point/#comparison","title":"Comparison","text":"<p>Comparison is a common unit operation.  If the input <code>QuantityPoint</code> types are not identical \u2014 same <code>Unit</code> and <code>Rep</code> \u2014 then we first convert them to their common type. Then, we perform the comparison by delegating to the comparison operator on the underlying values.</p> <p>We support the following binary comparison operators:</p> <ul> <li><code>==</code></li> <li><code>!=</code></li> <li><code>&gt;</code></li> <li><code>&gt;=</code></li> <li><code>&lt;</code></li> <li><code>&lt;=</code></li> </ul>"},{"location":"reference/quantity_point/#addition","title":"Addition","text":"<p>Addition between any two <code>QuantityPoint</code> instances is not defined, because it is not meaningful \u2014 this is intrinsic to the core design of quantity point types.  Addition is only defined between a <code>QuantityPoint</code> and a <code>Quantity</code> of the same dimension.</p> <p>Addition is a common unit operation. If the input <code>Quantity</code> and <code>QuantityPoint</code> types don\u2019t have the same <code>Unit</code> and <code>Rep</code>, then we first convert them to their common types \u2014 that is, we use the common unit and common rep for each.  The result is a <code>QuantityPoint</code> of this common unit and rep, whose value is the sum of the input values (after conversions).</p>"},{"location":"reference/quantity_point/#subtraction","title":"Subtraction","text":"<p>Subtraction is a common unit operation.  If the input <code>QuantityPoint</code> types are not identical \u2014 same <code>Unit</code> and <code>Rep</code> \u2014 then we first convert them to their common type.  The result is a <code>Quantity</code> \u2014 note: not a <code>QuantityPoint</code> \u2014 of this common unit and Rep, whose value is the difference of the input values (after any common type conversions).</p>"},{"location":"reference/quantity_point/#shorthand-addition-and-subtraction-","title":"Shorthand addition and subtraction (<code>+=</code>, <code>-=</code>)","text":"<p>The input must be a <code>Quantity</code> which is implicitly convertible to the <code>Unit</code> and <code>Rep</code> of the target <code>QuantityPoint</code> type.  These operations first perform that conversion, and then replace the target <code>QuantityPoint</code> with the result of that addition (for <code>+=</code>) or subtraction (for <code>-=</code>).</p>"},{"location":"reference/quantity_point/#rep_cast","title":"<code>rep_cast</code>","text":"<p><code>rep_cast</code> performs a <code>static_cast</code> on the underlying value of a <code>QuantityPoint</code>.  It is used to change the rep.</p> <p>Given any <code>QuantityPoint&lt;U, R&gt; p</code> whose rep is <code>R</code>, then <code>rep_cast&lt;T&gt;(p)</code> gives a <code>QuantityPoint&lt;U, T&gt;</code>, whose underlying value is <code>static_cast&lt;T&gt;(p.in(U{}))</code>.</p>"},{"location":"reference/quantity_point/#templates-and-traits","title":"Templates and traits","text":""},{"location":"reference/quantity_point/#matching-typename-u-typename-r","title":"Matching: <code>typename U, typename R</code>","text":"<p>To specialize a template to match any <code>QuantityPoint</code>, declare two template parameters: one for the unit, one for the rep.</p> Example: function template <pre><code>template &lt;typename U, typename R&gt;\nconstexpr auto refine_scale(QuantityPoint&lt;U, R&gt; p) {\n    return p.as(U{} / mag&lt;10&gt;());\n}\n</code></pre> <p>This function template will match any <code>QuantityPoint</code> specialization, and nothing else.</p> Example: type template <pre><code>// First, we need to declare the generic type template.  It matches a single type, `T`.\ntemplate &lt;typename T&gt;\nstruct Size;\n\n// Now we can declare a specialization that matches any `QuantityPoint`, by templating on its\n// unit and rep.\ntemplate &lt;typename U, typename R&gt;\nstruct Size&lt;QuantityPoint&lt;U, R&gt;&gt; {\n\n    // Note: this example uses inline variables, a C++17 feature.  It's just for illustration.\n    static constexpr inline std::size_t value = sizeof(R);\n};\n</code></pre> <p>In this way, <code>Size&lt;T&gt;::value</code> will exist only when <code>T</code> is some <code>QuantityPoint</code> type (unless, of course, other specializations get defined elsewhere).</p>"},{"location":"reference/quantity_point/#rep","title":"<code>::Rep</code>","text":"<p>Every <code>QuantityPoint</code> type has a public static alias, <code>::Rep</code>, which indicates its underlying storage type (or, its \u201crep\u201d).</p> Example <p><code>decltype(meters_pt(5))::Rep</code> is <code>int</code>.</p>"},{"location":"reference/quantity_point/#unit","title":"<code>::Unit</code>","text":"<p>Every <code>QuantityPoint</code> type has a public static alias, <code>::Unit</code>, which indicates its unit type.</p> Example <p><code>decltype(meters_pt(5))::Unit</code> is <code>Meters</code>.</p>"},{"location":"reference/quantity_point/#unit_1","title":"<code>::unit</code>","text":"<p>Every <code>QuantityPoint</code> type has a public static member variable, <code>::unit</code>, which is an instance of its unit type.</p> Example <p><code>decltype(meters_pt(5))::unit</code> is <code>Meters{}</code>.</p>"},{"location":"reference/quantity_point/#common-type","title":"<code>std::common_type</code> specialization","text":"<p>For two <code>QuantityPoint</code> types, one with unit <code>U1</code> and rep <code>R1</code>, and the other with unit <code>U2</code> and rep <code>R2</code>, then <code>std::common_type_t&lt;QuantityPoint&lt;U1, R1&gt;, QuantityPoint&lt;U2, R2&gt;&gt;</code> has the following properties.</p> <ol> <li> <p>It exists if and only if <code>U1</code> and <code>U2</code> have the same dimension.</p> </li> <li> <p>When it exists, it is <code>QuantityPoint&lt;U, R&gt;</code>, where <code>U</code> is the common    point-unit of <code>U1</code> and <code>U2</code>, and    <code>R</code> is <code>std::common_type_t&lt;R1, R2&gt;</code>.</p> </li> </ol> <p>As required by the standard, our <code>std::common_type</code> specializations are SFINAE-friendly: improper combinations will simply not be present, rather than producing a hard error.</p>"},{"location":"reference/quantity_point/#arequantitypointtypesequivalent","title":"AreQuantityPointTypesEquivalent","text":"<p>Result: Indicates whether two <code>QuantityPoint</code> types are equivalent.  Equivalent types may be freely converted to each other, and no arithmetic operations will be performed in doing so.</p> <p>More precisely, <code>QuantityPoint&lt;U1, R1&gt;</code> and <code>QuantityPoint&lt;U2, R2&gt;</code> are equivalent if and only if both of the following conditions hold.</p> <ol> <li> <p>The units <code>U1</code> and <code>U2</code> are point-equivalent.</p> </li> <li> <p>The reps <code>R1</code> and <code>R2</code> are the same type.</p> </li> </ol> <p>Syntax:</p> <ul> <li>For types <code>U1</code> and <code>U2</code>:<ul> <li><code>AreQuantityPointTypesEquivalent&lt;U1, U2&gt;::value</code></li> </ul> </li> </ul>"},{"location":"reference/unit/","title":"Unit","text":"<p>A unit is a type which represents a unit of measure.  Examples include <code>Meters</code>, <code>Radians</code>, <code>Hours</code>, and so on.</p> <p>Users can work with units as either types or instances, and can freely convert between these representations.  That is to say: units are monovalue types.</p>"},{"location":"reference/unit/#identifying-unit-types","title":"Identifying unit types","text":"<p>A unit is not forced to be a specialization of some central type template, such as a hypothetical <code>Unit&lt;...&gt;</code>. Rather, it\u2019s more open ended: a unit can be any type which fulfills certain defining properties.</p> <p>To be a unit, a type <code>U</code>:</p> <ol> <li> <p>Must contain a public type alias, <code>U::Dim</code>, which refers to a valid dimension    type.</p> </li> <li> <p>Must contain a public type alias, <code>U::Mag</code>, which refers to a valid magnitude    type.</p> </li> <li> <p>Must be a monovalue type.</p> </li> <li> <p>May contain a <code>static constexpr</code> member named <code>label</code>, which is a C-style <code>const char[]</code>    (not a <code>const char*</code>).<sup>1</sup></p> </li> <li> <p>May contain a <code>static constexpr</code> member function <code>origin()</code>, which returns a quantity whose    dimension type is <code>U::Dim</code>.</p> </li> </ol> <p>A custom <code>origin()</code> is very rarely needed.  Both labels and origins will be discussed further below.</p>"},{"location":"reference/unit/#making-unit-types","title":"Making unit types","text":"<p>Although every unit type needs <code>Dim</code> and <code>Mag</code> members, users won\u2019t need to add them directly. Rather, the best way to make a unit type is by combining existing unit types via supported operations.  This approach has two key advantages relative to defining your unit as a fully manual <code>struct</code>.</p> <ol> <li> <p>If your input types are all valid units, your output type will be too.</p> </li> <li> <p>It makes the definition more readable and physically meaningful.</p> </li> </ol> <p>To give your unit type the best ergonomics, follow our how-to guide for defining new units.</p>"},{"location":"reference/unit/#labels","title":"Unit labels","text":"<p>Every unit has a label.  Its label is a <code>constexpr const char[]</code> of the appropriate size.</p> <p>For a unit type <code>U</code>, or instance <code>u</code>, we can access the label as follows:</p> <ul> <li><code>unit_label&lt;U&gt;()</code></li> <li><code>unit_label(u)</code></li> </ul> <p>Note that the <code>u</code> in <code>unit_label(u)</code> is a unit slot, so you can pass anything that \u201cacts like a unit\u201d to it.  For instance, you can say <code>unit_label(meters)</code>; you don\u2019t need to write <code>unit_label(Meters{})</code>.</p> <p>This function returns a reference to the array, which again is a compile time constant.</p> <p>Note especially that the type is an array (<code>[]</code>).  A pointer (<code>*</code>) is not acceptable.  This is so that we can support <code>sizeof(unit_label(u))</code>.</p> <p>Using C-style <code>char</code> arrays for our labels makes Au more friendly for embedded users, because it gives them full access to the labels without forcing them to depend on <code>&lt;string&gt;</code> or <code>&lt;iostream&gt;</code>.</p>"},{"location":"reference/unit/#unlabeled_unit","title":"<code>[UNLABELED_UNIT]</code>","text":"<p>If a unit does not have an explicit label, we will try to generate one automatically.  If we\u2019re unable to do so, we fall back to the \u201cdefault label\u201d, which is <code>\"[UNLABELED_UNIT]\"</code>.</p> <p>This is a label just like any other: we do not attempt to \u201cpropagate the un-labeled-ness\u201d.  As a concrete example, if <code>Foos</code> is an unlabeled unit, then the label for <code>Nano&lt;Foos&gt;{} / Seconds{}</code> would be <code>\"n[UNLABELED_UNIT] / s\"</code>.  This is to preserve as much structure as possible for end users, so they have the best chance of recognizing the offending unit, and perhaps upgrading it.</p> <p>Note</p> <p>A key design goal is for every combination of meaningfully labeled units, by every supported operation, to produce a meaningfully labeled unit.  Right now, the only missing operation is scaling a unit by a magnitude.  We are tracking this in #85.</p>"},{"location":"reference/unit/#symbols","title":"Unit symbols","text":"<p>Unit symbols provide a way to create <code>Quantity</code> instances concisely: by simply multiplying or dividing a raw number by the symbol.</p> <p>For example, suppose we create symbols for <code>Meters</code> and <code>Seconds</code>:</p> <pre><code>constexpr auto m = symbol_for(meters);\nconstexpr auto s = symbol_for(seconds);\n</code></pre> <p>Then we can write <code>3.5f * m / s</code> instead of <code>(meters / second)(3.5f)</code>.</p>"},{"location":"reference/unit/#creation","title":"Creation","text":"<p>There are two ways to create an instance of a unit symbol.</p> <ol> <li> <p>Call <code>symbol_for(your_units)</code>.</p> <ul> <li>PRO: The argument acts as a unit slot, giving maximum   flexibility and composability.</li> <li>CON: Instantiating the <code>symbol_for</code> overload adds to compilation time (although only very   slightly).</li> </ul> </li> <li> <p>Make an instance of <code>SymbolFor&lt;YourUnits&gt;</code>.</p> <ul> <li>PRO: This directly uses the type itself without instantiating anything else, so it should be   the fastest to compile.</li> <li>CON: Since the argument is a type, it\u2019s less flexible and more awkward to compose.</li> </ul> </li> </ol> Examples of both methods Using <code>symbol_for</code>Using <code>SymbolFor</code> <pre><code>constexpr auto m = symbol_for(meters);\nconstexpr auto mps = symbol_for(meters / second);\n</code></pre> <p>These are easier to compose, although at the cost of instantiating an extra function.</p> <pre><code>constexpr auto m = SymbolFor&lt;Meters&gt;{};\nconstexpr auto mps = SymbolFor&lt;UnitQuotientT&lt;Meters, Seconds&gt;&gt;{};\n</code></pre> <p>These are the fastest to compile, although they\u2019re a little more verbose, and composition uses awkward type traits such as <code>UnitQuotientT</code>.</p>"},{"location":"reference/unit/#prefixed-symbols","title":"Prefixed symbols","text":"<p>To create a symbol for a prefixed unit, both of the ways mentioned above (namely, calling <code>symbol_for()</code>, and creating a <code>SymbolFor&lt;&gt;</code> instance) will still work.  However, there is also a third way: you can use the appropriate prefix applier with an existing symbol for the unit to be prefixed.  This can be concise and readable.</p> Example: creating a symbol for <code>Nano&lt;Meters&gt;</code> <p>Assume we have a unit <code>Meters</code>, which has a quantity maker <code>meters</code> and a symbol <code>m</code>.  Here are your three options for creating a symbol for the prefixed unit <code>Nano&lt;Meters&gt;</code>.</p> Using <code>symbol_for</code>Using <code>SymbolFor</code>Using a prefix applier <pre><code>constexpr auto nm = symbol_for(nano(meters));\n</code></pre> <pre><code>constexpr auto nm = SymbolFor&lt;Nano&lt;Meters&gt;&gt;{};\n</code></pre> <pre><code>constexpr auto nm = nano(m);\n</code></pre>"},{"location":"reference/unit/#operations_1","title":"Operations","text":"<p>Each operation with a <code>SymbolFor</code> consists in multiplying or dividing with some other family of types.</p>"},{"location":"reference/unit/#raw-numeric-type-t","title":"Raw numeric type <code>T</code>","text":"<p>Multiplying or dividing <code>SymbolFor&lt;Unit&gt;</code> with a raw numeric type <code>T</code> produces a <code>Quantity</code> whose rep is <code>T</code>, and whose unit is derived from <code>Unit</code>.</p> <p>In the following table, we will use <code>x</code> to represent the value that was stored in the input of type <code>T</code>.</p> Operation Resulting Type Underlying Value Notes <code>SymbolFor&lt;Unit&gt; * T</code> <code>Quantity&lt;Unit, T&gt;</code> <code>x</code> <code>SymbolFor&lt;Unit&gt; / T</code> <code>Quantity&lt;Unit, T&gt;</code> <code>T{1} / x</code> Disallowed for integral <code>T</code> <code>T * SymbolFor&lt;Unit&gt;</code> <code>Quantity&lt;Unit, T&gt;</code> <code>x</code> <code>T / SymbolFor&lt;Unit&gt;</code> <code>Quantity&lt;UnitInverseT&lt;Unit&gt;, T&gt;</code> <code>x</code>"},{"location":"reference/unit/#quantityu-r","title":"<code>Quantity&lt;U, R&gt;</code>","text":"<p>Multiplying or dividing <code>SymbolFor&lt;Unit&gt;</code> with a <code>Quantity&lt;U, R&gt;</code> produces a new <code>Quantity</code>.  It has the same underlying value and same rep <code>R</code>, but its units <code>U</code> are scaled appropriately by <code>Unit</code>.</p> <p>In the following table, we will use <code>x</code> to represent the underlying value of the input quantity \u2014 that is, if the input quantity was <code>q</code>, then <code>x</code> is <code>q.in(U{})</code>.</p> Operation Resulting Type Underlying Value Notes <code>SymbolFor&lt;Unit&gt; * Quantity&lt;U, R&gt;</code> <code>Quantity&lt;UnitProductT&lt;Unit, U&gt;, R&gt;</code> <code>x</code> <code>SymbolFor&lt;Unit&gt; / Quantity&lt;U, R&gt;</code> <code>Quantity&lt;UnitQuotientT&lt;Unit, U&gt;, R&gt;</code> <code>R{1} / x</code> Disallowed for integral <code>R</code> <code>Quantity&lt;U, R&gt; * SymbolFor&lt;Unit&gt;</code> <code>Quantity&lt;UnitProductT&lt;U, Unit&gt;, R&gt;</code> <code>x</code> <code>Quantity&lt;U, R&gt; / SymbolFor&lt;Unit&gt;</code> <code>Quantity&lt;UnitQuotientT&lt;U, Unit&gt;, R&gt;</code> <code>x</code>"},{"location":"reference/unit/#symbolforotherunit","title":"<code>SymbolFor&lt;OtherUnit&gt;</code>","text":"<p>Symbols compose: the product or quotient of two <code>SymbolFor</code> instances is a new <code>SymbolFor</code> instance.</p> Operation Resulting Type <code>SymbolFor&lt;Unit&gt; * SymbolFor&lt;OtherUnit&gt;</code> <code>SymbolFor&lt;UnitProductT&lt;Unit, OtherUnit&gt;&gt;</code> <code>SymbolFor&lt;Unit&gt; / SymbolFor&lt;OtherUnit&gt;</code> <code>SymbolFor&lt;UnitQuotientT&lt;Unit, OtherUnit&gt;&gt;</code>"},{"location":"reference/unit/#origins","title":"Unit origins","text":"<p>The \u201corigin\u201d of a unit is only useful for <code>QuantityPoint</code>, our affine space type.  Even then, the origin by itself is not meaningful.  Only the difference between the origins of two units is meaningful.</p> <p>You would use this to implement an \u201coffset\u201d unit, such as <code>Celsius</code> or <code>Fahrenheit</code>.  However, note that both of these are already implemented in the library.</p> <p>The origin defaults to <code>ZERO</code> if not supplied.</p>"},{"location":"reference/unit/#types-for-combined-units","title":"Types for combined units","text":"<p>A core tenet of Au\u2019s design philosophy is to avoid giving any units special status.  Every named unit enters into a unit computation on equal footing.  We will keep track of the accumulated powers of each named unit, cancelling as appropriate.  The final form will follow these rules.</p> <ol> <li> <p>Every power of a named unit will be represented according to the representation    table.  That is, it will be omitted if its power is zero, and will    otherwise appear as one of <code>Pow</code>, <code>RatioPow</code>, or the bare unit itself.</p> </li> <li> <p>If only one named unit remains with nonzero power, then that named unit power (as represented in    the previous rule) is the complete type.</p> </li> <li> <p>If multiple named units remain with nonzero power, then their representations (according to rule    1) are combined as the elements of a variadic <code>UnitProduct&lt;...&gt;</code> pack.</p> </li> </ol> <p>Warning</p> <p>The ordering of the bases is deterministic, but is implementation defined, and can change at any time.  It is a programming error to write code that assumes any specific ordering of the units in a pack.</p> A few examples <p>We have omitted the <code>au::</code> namespace in the following examples for greater clarity.</p> Unit expression Resulting unit type <code>squared(Meters{})</code> <code>Pow&lt;Meters, 2&gt;</code> <code>Meters{} / Seconds{}</code> <code>UnitProduct&lt;Meters, Pow&lt;Seconds, -1&gt;&gt;</code> <code>Seconds{} * Meters{} / Seconds{}</code> <code>Meters</code>"},{"location":"reference/unit/#operations","title":"Operations","text":"<p>These are the operations which each unit type supports.  Because a unit must be a monovalue type, it can take the form of either a type or an instance. In what follows, we\u2019ll use this convention:</p> <ul> <li>Capital identifiers (<code>U</code>, <code>U1</code>, <code>U2</code>, \u2026) refer to types.</li> <li>Lowercase identifiers (<code>u</code>, <code>u1</code>, <code>u2</code>, \u2026) refer to instances.</li> </ul>"},{"location":"reference/unit/#multiplication","title":"Multiplication","text":"<p>Result: The product of two units.</p> <p>Syntax:</p> <ul> <li>For types <code>U1</code> and <code>U2</code>:<ul> <li><code>UnitProductT&lt;U1, U2&gt;</code></li> </ul> </li> <li>For instances <code>u1</code> and <code>u2</code>:<ul> <li><code>u1 * u2</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#division","title":"Division","text":"<p>Result: The quotient of two units.</p> <p>Syntax:</p> <ul> <li>For types <code>U1</code> and <code>U2</code>:<ul> <li><code>UnitQuotientT&lt;U1, U2&gt;</code></li> </ul> </li> <li>For instances <code>u1</code> and <code>u2</code>:<ul> <li><code>u1 / u2</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#powers","title":"Powers","text":"<p>Result: A unit raised to an integral power.</p> <p>Syntax:</p> <ul> <li>For a type <code>U</code>, and an integral power <code>N</code>:<ul> <li><code>UnitPowerT&lt;U, N&gt;</code></li> </ul> </li> <li>For an instance <code>u</code>, and an integral power <code>N</code>:<ul> <li><code>pow&lt;N&gt;(u)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#roots","title":"Roots","text":"<p>Result: An integral root of a unit.</p> <p>Syntax:</p> <ul> <li>For a type <code>U</code>, and an integral root <code>N</code>:<ul> <li><code>UnitPowerT&lt;U, 1, N&gt;</code> (because the N^\\text{th} root is equivalent to the   \\left(\\frac{1}{N}\\right)^\\text{th} power)</li> </ul> </li> <li>For an instance <code>u</code>, and an integral root <code>N</code>:<ul> <li><code>root&lt;N&gt;(u)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#helpers-for-powers-and-roots","title":"Helpers for powers and roots","text":"<p>Units support all of the power helpers.  So, for example, for a unit instance <code>u</code>, you can write <code>sqrt(u)</code> as a more readable alternative to <code>root&lt;2&gt;(u)</code>.</p>"},{"location":"reference/unit/#scaling-by-magnitude","title":"Scaling by <code>Magnitude</code>","text":"<p>Result: A new unit which has been scaled by the given magnitude.  More specifically, for a unit instance <code>u</code> and magnitude instance <code>m</code>, this operation:</p> <ul> <li>Preserves the dimension of <code>u</code>.</li> <li>Scales the magnitude of <code>u</code> by a factor of <code>m</code>.</li> <li>Deletes the label of <code>u</code>.</li> <li>Preserves the origin of <code>u</code>.</li> </ul> <p>Syntax:</p> <ul> <li><code>u * m</code></li> </ul>"},{"location":"reference/unit/#traits","title":"Traits","text":"<p>Because units are monovalue types, each trait has two forms: one for types, and another for instances.</p> <p>Additionally, the parameters in the instance forms will usually act as unit slots.  This means you can, for example, write <code>unit_ratio(feet, meters)</code>, which can be convenient.</p> <p>Warning</p> <p>The only unit trait whose parameters are not unit slots is <code>is_unit(u)</code>.  This is because of its name.  It will return <code>true</code> only if you pass a unit type: passing the unit instance <code>Meters{}</code> returns <code>true</code>, but passing the quantity maker <code>meters</code> returns <code>false</code>.</p> <p>If you want to check whether your instance is compatible with a unit slot, use <code>fits_in_unit_slot(u)</code>.</p> <p>Sections describing <code>bool</code> traits will be indicated with a trailing question mark, <code>\"?\"</code>.</p>"},{"location":"reference/unit/#is-unit","title":"Is unit?","text":"<p>Result: Indicates whether the argument is a valid unit.</p> <p>Warning</p> <p>We don\u2019t currently have a trait that can detect whether or not a type is a monovalue type.  Thus, the current implementation only checks whether the dimension and magnitude are valid.  Until we get such a trait, authors of unit types are responsible for satisfying the monovalue type requirement.</p> <p>Syntax:</p> <ul> <li>For type <code>U</code>:<ul> <li><code>IsUnit&lt;U&gt;::value</code></li> </ul> </li> <li>For instance <code>u</code>:<ul> <li><code>is_unit(u)</code></li> </ul> </li> </ul> <p>Warning</p> <p>This will only return true if <code>u</code> is an instance of a unit type, such as <code>Meters{}</code>. It will return <code>false</code> for a quantity maker such as <code>meters</code>.</p> <p>This is what you want if you are trying to figure out whether the type of your instance would be suitable as the first template parameter for <code>Quantity</code> or <code>QuantityPoint</code>.</p> <p>If you are trying to figure out whether your instance <code>u</code> is suitable for a unit slot, call <code>fits_in_unit_slot(u)</code> instead.</p>"},{"location":"reference/unit/#fits-in-unit-slot","title":"Fits in unit slot?","text":"<p>Result: Indicates whether the argument can be validly passed to a unit slot in an API.</p> <p>This trait is instance-only: there is no reason to apply this to types, so we do not provide a type-based API.</p> <p>Syntax:</p> <ul> <li>For instance <code>u</code>:<ul> <li><code>fits_in_unit_slot(u)</code></li> </ul> </li> </ul> <p>Warning</p> <p>This can return true even if <code>u</code> is not an instance of a unit type.  For example, <code>fits_in_unit_slot(meters)</code> returns true, even though the type of <code>meters</code> is <code>QuantityMaker&lt;Meters&gt;</code>, and thus, not a unit.</p> <p>If you want to stringently check whether <code>u</code> is a unit \u2014 say, to determine whether its type is suitable as the first template parameter of <code>Quantity</code> \u2014 then call <code>is_unit(u)</code> instead.</p>"},{"location":"reference/unit/#has-same-dimension","title":"Has same dimension?","text":"<p>Result: Indicates whether two units have the same dimension.</p> <p>Syntax:</p> <ul> <li>For types <code>U1</code> and <code>U2</code>:<ul> <li><code>HasSameDimension&lt;U1, U2&gt;::value</code></li> </ul> </li> <li>For instances <code>u1</code> and <code>u2</code>:<ul> <li><code>has_same_dimension(u1, u2)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#quantity-equivalent","title":"Are units quantity-equivalent?","text":"<p>Result: Indicates whether two units are quantity-equivalent.  This means that they have the same dimension and same magnitude.  Quantities of quantity-equivalent units may be trivially converted to each other with no conversion factor.</p> <p>For example, <code>Meters{} * Hertz{}</code> is not the same unit as <code>Meters{} / Seconds{}</code>, but they are quantity-equivalent.</p> <p>Syntax:</p> <ul> <li>For types <code>U1</code> and <code>U2</code>:<ul> <li><code>AreUnitsQuantityEquivalent&lt;U1, U2&gt;::value</code></li> </ul> </li> <li>For instances <code>u1</code> and <code>u2</code>:<ul> <li><code>are_units_quantity_equivalent(u1, u2)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#point-equivalent","title":"Are units point-equivalent?","text":"<p>Result: Indicates whether two units are point-equivalent.  This means that they have the same dimension, same magnitude, and same origin.  <code>QuantityPoint</code> instances of point-equivalent units may be trivially converted to each other with no conversion factor and no additive offset.</p> <p>For example, while <code>Celsius</code> and <code>Kelvins</code> are quantity-equivalent, they are not point-equivalent.</p> <p>Syntax:</p> <ul> <li>For types <code>U1</code> and <code>U2</code>:<ul> <li><code>AreUnitsPointEquivalent&lt;U1, U2&gt;::value</code></li> </ul> </li> <li>For instances <code>u1</code> and <code>u2</code>:<ul> <li><code>are_units_point_equivalent(u1, u2)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#is-dimensionless","title":"Is dimensionless?","text":"<p>Result: Indicates whether the argument is a dimensionless unit.</p> <p>Syntax:</p> <ul> <li>For type <code>U</code>:<ul> <li><code>IsDimensionless&lt;U&gt;::value</code></li> </ul> </li> <li>For instance <code>u</code>:<ul> <li><code>is_dimensionless(u)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#unitless-unit","title":"Is unitless unit?","text":"<p>Result: Indicates whether the argument is a \u201cunitless unit\u201d: that is, a dimensionless unit whose magnitude is 1.</p> <p>Syntax:</p> <ul> <li>For type <code>U</code>:<ul> <li><code>IsUnitlessUnit&lt;U&gt;::value</code></li> </ul> </li> <li>For instance <code>u</code>:<ul> <li><code>is_unitless_unit(u)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#unit-ratio","title":"Unit ratio","text":"<p>Result: The magnitude representing the ratio of the input units\u2019 magnitudes.</p> <p>For units with non-trivial dimension, there is no such thing as \u201cthe\u201d magnitude of a unit: it is not physically meaningful or observable.  However, the ratio of units\u2019 magnitudes is well defined, and that is what this trait produces.</p> <p>For example, the unit ratio of <code>Feet</code> and <code>Inches</code> is <code>mag&lt;12&gt;()</code>, because a foot is 12 times as big as an inch.</p> <p>Syntax:</p> <ul> <li>For types <code>U1</code> and <code>U2</code>:<ul> <li><code>UnitRatioT&lt;U1, U2&gt;::value</code></li> </ul> </li> <li>For instances <code>u1</code> and <code>u2</code>:<ul> <li><code>unit_ratio(u1, u2)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#origin-displacement","title":"Origin displacement","text":"<p>Result: The displacement from the first unit\u2019s origin to the second unit\u2019s origin.</p> <p>Recall that there is no such thing as \u201cthe\u201d origin of a unit: it is not physically meaningful or observable.  However, the displacement from one unit\u2019s origin to another is well defined, and that is what this trait produces.</p> <p>For example, the origin displacement from <code>Kelvins</code> to <code>Celsius</code> is equivalent to 273.15 \\,\\text{K}.</p> <p>Syntax:</p> <ul> <li>For types <code>U1</code> and <code>U2</code>:<ul> <li><code>OriginDisplacement&lt;U1, U2&gt;::value()</code></li> </ul> </li> <li>For instances <code>u1</code> and <code>u2</code>:<ul> <li><code>origin_displacement(u1, u2)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#associated-unit","title":"Associated unit","text":"<p>Result: The actual unit associated with a unit slot that is associated with a <code>Quantity</code> type.  Here are a few examples.</p> <pre><code>round_in(meters, feet(20));\n//       ^^^^^^\nround_in(Meters{}, feet(20));\n//       ^^^^^^^^\n\nusing symbols::m;\nround_in(m, feet(20));\n//       ^\n\nfeet(6).in(inches);\n//         ^^^^^^\nfeet(6).in(Inches{});\n//         ^^^^^^^^\n</code></pre> <p>The underlined arguments are all unit slots.  The kinds of things that can be passed here include a <code>QuantityMaker</code> for a unit, a constant, a unit symbol, or simply a unit type itself.</p> <p>The use case for this trait is to implement the unit slot argument for a function.</p> <p>Syntax:</p> <ul> <li>For a type <code>U</code>:<ul> <li><code>AssociatedUnitT&lt;U&gt;</code></li> </ul> </li> <li>For an instance <code>u</code>:<ul> <li><code>associated_unit(u)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#associated-unit-for-points","title":"Associated unit (for points)","text":"<p>Result: The actual unit associated with a unit slot that is associated with a quantity point type. Here are a few examples.</p> <pre><code>round_in(meters_pt, milli(meters_pt)(1200));\n//       ^^^^^^^^^\nround_in(Meters{}, milli(meters_pt)(1200));\n//       ^^^^^^^^\n\nmeters_pt(6).in(centi(meters_pt));\n//              ^^^^^^^^^^^^^^^^\nmeters_pt(6).in(Centi&lt;Meters&gt;{});\n//              ^^^^^^^^^^^^^^^\n</code></pre> <p>The underlined arguments are unit slots for quantity points.  In practice, this will be either a <code>QuantityPointMaker</code> for some unit, or a unit itself.</p> <p>The use case for this trait is to implement a function or API that takes a unit slot, and is associated with quantity points.</p> <p>Syntax:</p> <ul> <li>For a type <code>U</code>:<ul> <li><code>AssociatedUnitForPointsT&lt;U&gt;</code></li> </ul> </li> <li>For an instance <code>u</code>:<ul> <li><code>associated_unit_for_points(u)</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#common-unit","title":"Common unit","text":"<p>Result: The largest unit that evenly divides its input units.  (Read more about the concept of common units.)</p> <p>A specialization will only exist if all input types are units.</p> <p>If the inputs are units, but their Dimensions aren\u2019t all identical, then the request is ill-formed and we will produce a hard error.</p> <p>It may happen that the input units have the same Dimension, but there is no unit which evenly divides them (because some pair of input units has an irrational quotient).  In this case, there is no uniquely defined answer, but the program should still produce some answer.  We guarantee that the result is associative, and symmetric under any reordering of the input units.  The specific implementation choice will be driven by convenience and simplicity.</p> <p>Syntax:</p> <ul> <li>For types <code>Us...</code>:<ul> <li><code>CommonUnitT&lt;Us...&gt;</code></li> </ul> </li> </ul>"},{"location":"reference/unit/#common-point-unit","title":"Common point unit","text":"<p>Result: The largest-magnitude, highest-origin unit which is \u201ccommon\u201d to the units of a collection of <code>QuantityPoint</code> instances.  (Read more about the concept of common units for <code>QuantityPoint</code>.)</p> <p>The key goal to keep in mind is that for a <code>QuantityPoint</code> of any unit <code>U</code> in <code>Us...</code>, converting its value to the common point-unit should involve only:</p> <ul> <li>multiplication by a positive integer</li> <li>addition of a non-negative integer</li> </ul> <p>This helps us support the widest range of Rep types (in particular, unsigned integers).</p> <p>As with <code>CommonUnitT</code>, this isn\u2019t always possible: in particular, we can\u2019t do this for units with irrational relative magnitudes or origin displacements.  However, we still provide some answer, which is consistent with the above policy whenever it\u2019s achievable, and produces reasonable results in all other cases.</p> <p>A specialization will only exist if the inputs are all units, and will exist but produce a hard error if any two input units have different Dimensions.  We also strive to keep the result associative, and symmetric under interchange of any inputs.</p> <p>Syntax:</p> <ul> <li>For types <code>Us...</code>:<ul> <li><code>CommonPointUnitT&lt;Us...&gt;</code></li> </ul> </li> </ul> <ol> <li> <p>Unit types defined by the library may also use <code>au::detail::StringConstant&lt;N&gt;</code> for some integer length <code>N</code>.  Since this is in the <code>detail</code> namespace, we wanted to de-emphasize it in this document.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/zero/","title":"Zero","text":"<p><code>Zero</code> is a type that represents a quantity of \u201c0\u201d in any units.  See the <code>Zero</code> discussion doc for more background motivation and use cases.</p> <p><code>Zero</code> is a monovalue type.  Every instance of <code>Zero</code> is equivalent to every other instance.  In practice, it\u2019s easiest and most idiomatic to use the predefined instance, <code>ZERO</code>.</p>"},{"location":"reference/zero/#conversions","title":"Conversions","text":"<p>The goal is for <code>ZERO</code> to be implicitly convertible to any type for which the value of \u201c0\u201d is completely unambiguous.  For types in the language or the standard library, which cannot possibly know about <code>Zero</code>, we do this via implicit conversions.  For other types, we do this by adding a constructor which takes <code>Zero</code>.</p>"},{"location":"reference/zero/#implicit-conversions","title":"Implicit conversions","text":"<p>We provide implicit conversions to the following categories of types:</p> <ul> <li> <p>Any arithmetic type (<code>int</code>, <code>double</code>, <code>std::size_t</code>, \u2026).</p> </li> <li> <p>Any <code>std::chrono::duration</code> type.</p> </li> </ul>"},{"location":"reference/zero/#quantity-constructor","title":"<code>Quantity</code> constructor","text":"<p><code>Quantity</code> is implicitly constructible from <code>Zero</code>.</p> <p>This means you can efficiently check the sign of any <code>Quantity</code> by comparing to <code>ZERO</code>.</p>"},{"location":"reference/zero/#quantitypoint-constructor","title":"<code>QuantityPoint</code> constructor","text":"<p>This is explicitly deleted.  There is no unambiguous notion of which point is labeled as \u201c0\u201d; it depends on the choice of units.  Therefore, we delete this constructor to prevent users from relying on this dubious notion.</p>"},{"location":"reference/zero/#io","title":"I/O","text":"<p>If you include I/O support, then <code>Zero</code> will be streamed as <code>\"0\"</code>.</p>"},{"location":"reference/detail/","title":"Implementation Details","text":"<p>This section is for reference docs which most end users won\u2019t often encounter directly.  We collect these docs in this subfolder to keep the main folder less cluttered.  Here\u2019s a guide to the content:</p> <ul> <li> <p>Dimensions.  This is how we keep track of which units are mutually   compatible, in the sense that they can be compared and converted with each other.</p> </li> <li> <p>Monovalue Types.  This isn\u2019t a specific type in the library; rather,   it\u2019s a \u201cconcept\u201d (loosely defined)<sup>1</sup> which many core library types model.</p> </li> <li> <p>Parameter Packs.  The most critical foundation for the library is parameter   packs, because this is how we implement the vector   spaces which underpin   dimensions, magnitudes, and compound units.</p> </li> </ul> <ol> <li> <p>We\u2019re using \u201cconcept\u201d in a loose, conceptual sense, rather than in the sense of the language element which was added in C++20.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/detail/dimension/","title":"Dimension","text":"<p><code>Dimension</code> is a family of monovalue types representing equivalence classes of units.  Each class defines a collection of units which can be meaningfully added, subtracted, and compared with each other.  Familiar examples of <code>Dimension</code> include length, time, temperature, speed, and so on.</p> <p>Dimensions form a vector space.  We choose certain \u201cbase dimensions\u201d as the basis vectors for this space.  As with other vector spaces in our library, <code>Dimension</code> values can be multiplied, divided, and raised to (rational) powers, and this arithmetic always takes place at compile time.</p> <p><code>Dimension</code> is an implementation detail.  Most end users will never name dimensions in their code, and never see them in their compiler errors.  Instead, users will work with units, which each carry their own dimension information.  The main situation where an end user would use <code>Dimension</code> directly is to define the first unit for a novel base dimension.</p>"},{"location":"reference/detail/dimension/#operations","title":"Operations","text":""},{"location":"reference/detail/dimension/#multiplication","title":"Multiplication","text":"<p>Result: The product of two <code>Dimension</code> values.</p> <p>Syntax:</p> <ul> <li>For types <code>D1</code> and <code>D2</code>:<ul> <li><code>DimProductT&lt;D1, D2&gt;</code></li> </ul> </li> <li>For instances <code>d1</code> and <code>d2</code>:<ul> <li><code>d1 * d2</code></li> </ul> </li> </ul>"},{"location":"reference/detail/dimension/#division","title":"Division","text":"<p>Result: The quotient of two <code>Dimension</code> values.</p> <p>Syntax:</p> <ul> <li>For types <code>D1</code> and <code>D2</code>:<ul> <li><code>DimQuotientT&lt;D1, D2&gt;</code></li> </ul> </li> <li>For instances <code>d1</code> and <code>d2</code>:<ul> <li><code>d1 / d2</code></li> </ul> </li> </ul>"},{"location":"reference/detail/dimension/#powers","title":"Powers","text":"<p>Result: A <code>Dimension</code> raised to an integral power.</p> <p>Syntax:</p> <ul> <li>For a type <code>D</code>, and an integral power <code>N</code>:<ul> <li><code>DimPowerT&lt;D, N&gt;</code></li> </ul> </li> <li>For an instance <code>d</code>, and an integral power <code>N</code>:<ul> <li><code>pow&lt;N&gt;(d)</code></li> </ul> </li> </ul>"},{"location":"reference/detail/dimension/#roots","title":"Roots","text":"<p>Result: An integral root of a <code>Dimension</code>.</p> <p>Syntax:</p> <ul> <li>For a type <code>D</code>, and an integral root <code>N</code>:<ul> <li><code>DimPowerT&lt;D, 1, N&gt;</code> (because the N^\\text{th} root is equivalent to the   \\left(\\frac{1}{N}\\right)^\\text{th} power)</li> </ul> </li> <li>For an instance <code>d</code>, and an integral root <code>N</code>:<ul> <li><code>root&lt;N&gt;(d)</code></li> </ul> </li> </ul>"},{"location":"reference/detail/dimension/#helpers-for-powers-and-roots","title":"Helpers for powers and roots","text":"<p>Dimensions support all of the power helpers.  So, for example, for a dimension instance <code>d</code>, you can write <code>sqrt(d)</code> as a more readable alternative to <code>root&lt;2&gt;(d)</code>.</p>"},{"location":"reference/detail/dimension/#included-base-dimensions","title":"Included base dimensions","text":"<p>Au includes the following base dimensions:</p> <ul> <li><code>Length</code></li> <li><code>Mass</code></li> <li><code>Time</code></li> <li><code>Current</code></li> <li><code>Temperature</code></li> <li><code>Angle</code></li> <li><code>Information</code></li> <li><code>AmountOfSubstance</code></li> <li><code>LuminousIntensity</code></li> </ul> <p>These comprise each of the seven base dimensions in the SI, with the addition of <code>Angle</code> and <code>Information</code>.</p>"},{"location":"reference/detail/monovalue_types/","title":"Monovalue Types","text":"<p>A \u201cmonovalue type\u201d is a type which can only hold a single value.  This means that knowing the type is equivalent to knowing the value, and vice versa.  We can convert back and forth between representing it as a type, and as a value, depending on our needs.</p> <p>We named this concept because it occurs again and again in Au, and the name makes it easier to refer to.  The \u201cmonovalue\u201d name is based on <code>std::monostate</code>, which has these properties.  However, \u201cmonostate\u201d could have been confused with the monostate pattern, which exposes actual, changeable, global state to its users.  \u201cMonovalue\u201d also emphasizes value semantics, which is a core property of these types.</p>"},{"location":"reference/detail/monovalue_types/#identifying-monovalue-types","title":"Identifying monovalue types","text":"<p>A type <code>T</code> is a monovalue type when it fulfills these conditions.</p> <ol> <li><code>T</code> can be instantiated.</li> <li>Every instance of <code>T</code> behaves identically to every other instance, in every way, and this    behavior does not depend on any program state.</li> <li>Instances of <code>T</code> support some set of operations with other types.</li> </ol> <p>These properties mean we can freely convert a monovalue object between its \u201ctype\u201d and \u201cvalue\u201d representations.  This is a core feature of monovalue types.</p> <p>The second property also distinguishes monovalue types from the monostate pattern mentioned above.</p> <p>The third property means there has to be something you can do with the instances.</p>"},{"location":"reference/detail/monovalue_types/#examples-of-monovalue-types","title":"Examples of monovalue types","text":"<p>Here are some canonical examples in Au.</p> Type Instance Example Operations <code>Zero</code> <code>ZERO</code> Comparing to any <code>Quantity</code> <code>Magnitude&lt;&gt;</code> <code>ONE</code> <ul><li>Equality comparison with other Magnitudes</li><li><code>get_value&lt;T&gt;(ONE)</code></li></ul> <code>Radians</code> (and other units) <code>Radians{}</code> (no special pre-formed instance) Arithmetic with other units, such as <code>Radians{} / Meters{}</code>"},{"location":"reference/detail/monovalue_types/#switching","title":"Switching between types and values","text":"<p>To get the value of a monovalue type <code>T</code>, instantiate the type using <code>T{}</code>.</p> <p>To get the type of a monovalue type value <code>t</code>, pass it to <code>decltype(t)</code>.  However, if <code>t</code> is <code>const</code> (including <code>constexpr</code>), you\u2019ll need to use <code>std::decay_t&lt;decltype(t)&gt;</code>.</p> More details on when to use <code>std::decay_t</code> <p>It\u2019s common to provide <code>constexpr</code> instances of monovalue types, like the following.</p> <pre><code>static constexpr auto ZERO = Zero{};\n</code></pre> <p>In this case, <code>decltype(ZERO)</code> would be <code>const Zero</code>, not simply <code>Zero</code>.  If we tried comparing this to <code>Zero</code> in a type trait, it could fail.</p> <p>Using <code>std::decay_t</code> is a concise way to avoid this problem.  However, it only arises for <code>const</code> or <code>constexpr</code> instances \u2014 and only when comparing types for exact equality \u2014 so most users won\u2019t need to worry about this most of the time.</p> <p>This diagram summarizes how to go back and forth using <code>{}</code> and <code>decltype()</code>.</p> <pre><code>flowchart LR\n\nsubgraph \"#quot;Realm of Types#quot;\"\n  Type\nend\n\nsubgraph \"#quot;Realm of Instances#quot;\"\n  value\nend\n\nType --&gt;|\"auto value =&lt;br&gt;Type{}\"| value --&gt;|\"using Type =&lt;br&gt;decltype(value)\"| Type</code></pre>"},{"location":"reference/detail/packs/","title":"Parameter packs","text":"<p>Products of base powers are the foundation for the Au library.  We use them for:</p> <ul> <li>The Dimension of a Unit.</li> <li>The Magnitude of a Unit.</li> <li>Making compound Units (products of powers of units, e.g., \\text{m} \\cdot \\text{s}^{-2}).</li> </ul> <p>We represent them as variadic parameter packs.  Each pack element represents a \u201cbase power\u201d: this is some \u201cbase\u201d, raised to some rational exponent.  For a base power <code>BP</code>, <code>BaseT&lt;BP&gt;</code> retrieves its base, and <code>ExpT&lt;BP&gt;</code> retrieves its exponent (as a <code>std::ratio</code>).</p> <p>Note</p> <p>This approach, with products of base powers, is known as the vector space representation for Dimensions, Magnitudes, and so on. The <code>//au:packs</code> target, which this page describes, is our tool for implementing these vector spaces robustly.</p>"},{"location":"reference/detail/packs/#powers","title":"Representing powers","text":"<p>These packs show up in compiler errors, and we want those errors to be as friendly as possible. Clutter is our enemy!  Thus, we canonicalize each base power to its simplest form.  Consider an arbitrary base type, <code>B</code>; here is how it shows up in the pack:</p> This power of B\u2026 \u2026shows up in a pack as: B ^ 0 (omitted) B ^ 1 <code>B</code> B ^ N, with N any other integer <code>Pow&lt;B, N&gt;</code> B^{ N / D }, with D &gt; 1 <code>RatioPow&lt;B, N, D&gt;</code> <p>Canonicalizing in this way keeps our compiler errors more concise and readable.</p>"},{"location":"reference/detail/packs/#strict-total-ordering","title":"Strict total ordering","text":"<p>The above canonicalization tells us what items to store.  We also need to be careful about which order to store them in.  We are modeling multiplication, and in our applications, (A \\times B) is always the same as (B \\times A).  However, <code>Pack&lt;A, B&gt;</code> is not the same type as <code>Pack&lt;B, A&gt;</code>! Thus, we are going to need a way to define whether <code>A</code> or <code>B</code> should come first inside of a <code>Pack</code>.</p> <p>What we need is a strict total ordering, which applies to all types which might represent a Base in a given kind of Pack.  This is a critical foundational concept for the library, so we use explicit traits for each kind of pack.  There are two main elements to this API:</p> <ul> <li> <p><code>InOrderFor&lt;Pack, A, B&gt;</code> is for generic algorithms.  It\u2019s how we check whether <code>A</code> and <code>B</code>   are in the right order for <code>Pack</code>.</p> </li> <li> <p><code>LexicographicTotalOrdering&lt;A, B, Orderings...&gt;</code> is for implementing <code>InOrderFor</code> for a given   <code>Pack</code>.  It\u2019s how we define whether <code>A</code> and <code>B</code> are in order for <code>Pack</code>.</p> </li> </ul> <p>The point in using <code>LexicographicTotalOrdering</code> is that it guards against the most common failure mode in our application: namely, two distinct types which compare as equivalent. <code>LexicographicTotalOrdering</code> tries <code>A</code> and <code>B</code> against every comparator in <code>Orderings...</code>, in sequence.  If any comparator knows how to order <code>A</code> and <code>B</code>, we use it.  If we run out of comparators, but <code>A</code> is not the same as <code>B</code>, then we produce a hard error.  The fix is to add a new comparator to \u201cbreak the tie\u201d.</p> Example: defining the ordering for a Pack <p>Suppose we have a particular pack, <code>Pack</code>, and our bases are <code>std::ratio</code> instances.  We need to define some canonical ordering.  Let\u2019s say that we want to order first by denominator\u2014integers first, then halves, thirds, etc\u2014and then by numerator.  We can define traits for those orderings, and then combine those traits using <code>LexicographicTotalOrdering</code> to implement <code>InOrderFor&lt;Pack, ...&gt;</code>.  Specifically:</p> <pre><code>template &lt;typename A, typename B&gt;\nstruct OrderByDenom : stdx::bool_constant&lt;(A::den &lt; B::den)&gt; {};\n\ntemplate &lt;typename A, typename B&gt;\nstruct OrderByNum : stdx::bool_constant&lt;(A::num &lt; B::num)&gt; {};\n\ntemplate &lt;typename A, typename B&gt;\nstruct InOrderFor&lt;Pack, A, B&gt; :\n    LexicographicTotalOrdering&lt;A, B, OrderByDenom, OrderByNum&gt; {};\n</code></pre> <p>With this definition, something like <code>Pack&lt;std::ratio&lt;-1&gt;, std::ratio&lt;8&gt;, std::ratio&lt;1, 2&gt;&gt;</code> would be in-order.</p>"},{"location":"reference/detail/packs/#validation","title":"Validation","text":"<p>We validate packs using type traits.  <code>IsValidPack&lt;Pack, T&gt;</code> is the \u201coverall\u201d validator.  It verifies that <code>T</code> is an instance of <code>Pack&lt;...&gt;</code>, and that its parameters satisfy the necessary conditions.  Specifically, those conditions are:</p> <ul> <li> <p><code>AreBasesInOrder&lt;Pack, T&gt;</code>: assuming <code>T</code> is <code>Pack&lt;BPs...&gt;</code>, verifies that all consecutive elements   in <code>BaseT&lt;BPs&gt;...</code> are all properly ordered (according to <code>InOrderFor&lt;Pack, ...&gt;</code>, naturally).</p> </li> <li> <p><code>AreAllPowersNonzero&lt;Pack, T&gt;</code>: assuming <code>T</code> is <code>Pack&lt;BPs...&gt;</code>, verifies that   <code>Exp&lt;BPs&gt;::num</code> is nonzero for every element in <code>BPs</code>.</p> </li> </ul>"},{"location":"reference/detail/packs/#algebra-on-packs","title":"Algebra on Packs","text":"<p>The whole reason we built <code>//au:packs</code> was to support exact symbolic algebra for two operations: products, and rational powers.  This section explains how we do that.  Our strategy is:</p> <ul> <li> <p>The <code>//au:packs</code> target provides generic versions of these operations that are pre-built, but   cumbersome.</p> <ul> <li>(What makes them cumbersome?  They need an extra parameter to specify which Pack they   operate on.  This is much like <code>InOrderFor</code>, which defines the ordering for a specific type   of Pack.)</li> </ul> </li> <li> <p>Client targets provide aliases which \u201chide\u201d the extra parameter (because they know what   value it should take!).</p> </li> </ul> <p>Let\u2019s take the \u201cpack product\u201d operation as an example, using <code>Dimension</code> as our Pack:</p> <pre><code>// The `//au:packs` library provides this:\ntemplate &lt;template &lt;class...&gt; typename Pack, typename... Ts&gt;\nusing PackProductT = /* (implementation; irrelevant here) */;\n\n// A _particular_ Pack (say, `Dimension`) would expose it to their users like this:\ntemplate &lt;typename... Dims&gt;\nusing DimProductT = PackProductT&lt;Dimension, Dims...&gt;;\n\n// End users would use the _latter_, e.g.:\nusing Length = DimProductT&lt;Speed, Time&gt;;\n</code></pre>"},{"location":"reference/detail/packs/#supported-algebraic-operations","title":"Supported algebraic operations","text":"<p>Here are the operations we support:</p> <ul> <li><code>PackProductT&lt;Pack, Ps...&gt;</code>: the product of arbitrarily many (0 or more) <code>Pack&lt;...&gt;</code> instances,   <code>Ps...</code>.</li> <li><code>PackQuotientT&lt;Pack, P1, P2&gt;</code>: the quotient <code>P1 / P2</code>.</li> <li><code>PackPowerT&lt;Pack, P, N, D=1&gt;</code>: raise the Pack <code>P</code> to the rational power <code>N / D</code>.</li> <li><code>PackInverseT&lt;Pack, P&gt;</code>: the Pack that gives the null pack when multiplied with the Pack <code>P</code>.</li> </ul>"},{"location":"tutorial/","title":"Tutorials: home","text":"<p>Taking the time to understand the basic usage of the library is a wise investment.  We\u2019ve tried to make that as easy as possible with these tutorials.  We recommend starting from the beginning, and working your way through.</p> <p>Each tutorial includes an explanatory discussion, and is followed by an interactive exercise to help build your skills.</p>"},{"location":"tutorial/#100-level-courses","title":"100-level courses","text":"<p>These courses should be all you need to become proficient in day-to-day usage of the library. You\u2019ll learn how to store values safely inside a quantity; how to name types to make your interfaces safer; how to perform unit conversions; and how to work effectively with the included math functions (forthcoming).</p> <ul> <li>Au 101: Quantity Makers</li> <li>Au 102: API Types</li> <li>Au 103: Unit Conversions</li> </ul>"},{"location":"tutorial/101-quantity-makers/","title":"Au 101: Quantity Makers","text":"<p>This tutorial gives a gentle introduction to the Au library.</p> <ul> <li>Time: TBD.</li> <li>Prerequisites: Experience writing C++ code.</li> <li>You will learn:<ul> <li>The concept and importance of \u201cunit safety\u201d.</li> <li>How to store a numeric value in a quantity.</li> <li>How to retrieve the stored numeric value.</li> <li>Some basic operations you can perform with a quantity.</li> </ul> </li> </ul>"},{"location":"tutorial/101-quantity-makers/#status-quo-no-units-library","title":"Status quo: no units library","text":"<p>Suppose you have a variable that represents a physical quantity.  That variable has some value, but that value is meaningless unless you also know the unit of measurement. We usually indicate the unit with a suffix on the variable name.  Here\u2019s a concrete example:</p> <pre><code>const double track_length_m = 100.0;\n//          Unit suffix--^^   ^^^^^--Value\n\nconst double best_time_s = 10.34;\n//       Unit suffix--^^   ^^^^^--Value\n</code></pre> <p>The first value is <code>100.0</code>.  Since there\u2019s no such thing as a \u201clength of 100\u201d, we add a <code>_m</code> suffix on the end of our variable name to make it clear that the value is the length in meters.  We take a similar approach for our time in seconds.</p> <p>This strategy works, in the sense that it can prevent unit errors, but it\u2019s labor intensive and error prone.  The naming suffixes provide hints, but enforcement is basically on the honor system. Consider a function we might want to call:</p> <pre><code>double average_speed_mps(double length_m, double time_s);\n</code></pre> <p>With the above variables, our callsite might look like this:</p> <pre><code>const auto speed_mps = average_speed_mps(track_length_m, best_time_s);\n</code></pre> <p>It\u2019s time to consider a very important property:</p> <p>Definition</p> <p>Unit correctness: a program is unit-correct when every variable associated with physical units is used consistently with those units.</p> <p>So: is this unit-correct?  Yes:</p> <ul> <li><code>track_length_m</code> gets passed as the parameter <code>length_m</code>: meters to meters </li> <li><code>best_time_s</code> gets passed as the parameter <code>time_s</code>: seconds to seconds </li> </ul> <p>However, it\u2019s quite fragile.  We could just as easily have written the following.</p> <pre><code>const auto speed_mps = average_speed_mps(best_time_s, track_length_m);\n</code></pre> <p>By itself, this line looks correct: we\u2019re asking for an average speed, given a time and a length. We can even see that we\u2019re passing in values in seconds and meters to get a result in meters-per-second, increasing our confidence!</p> <p>Of course, the line is wrong, but the only way to know that it\u2019s wrong is to go read the declaration of <code>average_speed_mps</code>.  This could easily be in some other file.  In a big project, it might be hard to even figure out which file it\u2019s in.</p> <p>That\u2019s a lot of cognitive load!</p>"},{"location":"tutorial/101-quantity-makers/#our-goal-unit-safety","title":"Our goal: unit safety","text":"<p>To write code quickly and robustly, unit-correctness is not enough.  We need more: we need unit safety.</p> <p>Definition</p> <p>Unit safety: We call a program unit-safe when the unit-correctness of each line of code can be checked by inspection, in isolation.</p> <p>This is the way to reduce cognitive load for code readers, when it comes to physical units.  If you inspect a unit-safe line, and see that it\u2019s correct, then you\u2019re done with that line.  You can move on; you don\u2019t have to hold it in your head.</p> <p>Tip</p> <p>A unit-safe line doesn\u2019t guarantee that the program has no unit errors.  It does guarantee that if there are unit errors, then they\u2019re in some other line (which you can also inspect!).</p> <p>Unit-safety is not something you could ever get from the standard numeric types, but you can get it from the Au library.  Let\u2019s learn how!</p>"},{"location":"tutorial/101-quantity-makers/#storing-values-the-quantity-maker","title":"Storing values: the \u201cquantity maker\u201d","text":"<p>The way to achieve unit-safety is by turning our raw numeric values into quantities.  We do this with quantity makers.  These are callables\u2014things that act like functions\u2014which have the name of some unit, and accept any numeric type.</p> <p>For example, let\u2019s make our variable <code>track_length_m</code> unit-safe by using the quantity maker, <code>meters</code>:</p> <pre><code>const auto track_length = meters(track_length_m);\n//                        ^^^^^^             ^^\n//     Quantity maker of *meters*      Takes value in *meters*\n</code></pre> <p>This is an example of a unit-safe handoff.  We take a raw number whose name tells us it was in meters, and we pass it to the quantity maker for that same unit.  We can see this line is unit-correct simply by inspection\u2014our first example of a unit-safe line.</p> <p>In fact, we have already achieved unit safety everywhere we use the quantity <code>track_length</code> instead of the raw number <code>track_length_m</code>!  Think of the quantity as a container, which holds its value securely together with information about its unit.  We\u2019ll see that the quantity prevents us from using that value in ways that are incompatible with its unit.</p>"},{"location":"tutorial/101-quantity-makers/#retrieving-values-you-must-name-the-unit","title":"Retrieving values: you must name the unit","text":"<p>Ideally, every interface that takes physical quantities would use unit-safe quantity types.  In practice, you can\u2019t upgrade your entire codebase at once.  Even if you could, there will always be third-party libraries which don\u2019t know about these quantity types.  One way or another, it\u2019s important to be able to get the value out.</p> <p>Let\u2019s imagine we have this example third-party API, which needs a raw <code>double</code>.  How can we call it if we have a quantity?</p> <pre><code>// Example third-party API.\n\nclass Racetrack;\n\nclass RacetrackBuilder {\n public:\n\n    // Main function we'll call:\n    void set_length_m(double length_m);\n\n    Racetrack build_track();\n};\n</code></pre> <p>Most units libraries provide a function that retrieves a quantity\u2019s value \u201cin whatever units it happens to be stored\u201d.  (Think of <code>std::chrono::duration::count()</code> as a very common example.)  These kinds of functions may be convenient, but they\u2019re not unit-safe.<sup>1</sup></p> <p>Au takes a different approach.  To retrieve the value from a quantity <code>q</code>, you call <code>q.in(units)</code>, where <code>units</code> is the quantity maker you used to store the value.  Continuing with our earlier example, we could call that API like so:</p> <pre><code>RacetrackBuilder builder;\nbuilder.set_length_m(track_length.in(meters));\n//                ^^             ^^^^^^^^^^^\n// API wants length in *meters*      Get value in *meters*\n</code></pre> <p>Here, we have another unit-safe handoff.  Our first one showed how we enter the library by naming the unit.  This one shows how we exit the library by naming that same unit.</p> <p>Tip</p> <p>Think of the quantity maker\u2019s name as a kind of \u201cpassword\u201d which you set when you create the quantity.  The quantity will hold its underlying value securely.  To retrieve that value, you must speak the same \u201cpassword\u201d (that is, name the same unit).</p> <p>Of course, this API is a best-case scenario for raw numeric APIs, since it names the units at the callsite (via the <code>_m</code> suffix on <code>set_length_m()</code>).  Our other API, <code>average_speed_mps()</code>, can\u2019t do this, because we can\u2019t see the parameter names at the callsite.  In fact, although we\u2019ll see some coping strategies in later lessons, there is no unit-safe way to call <code>average_speed_mps()</code> directly.</p>"},{"location":"tutorial/101-quantity-makers/#basic-quantity-operations","title":"Basic quantity operations","text":"<p>Quantity types do much more than simply hold their values securely: they support a variety of operations.  In fact, we strive to support every meaningful operation, because operation implementations for quantity types can faithfully maintain unit safety.</p> <p>Tip</p> <p>Treat any instance of retrieving the value as \u201ccode smell\u201d.  Stop and check whether there\u2019s some way to perform the operation within the quantity type.  If there\u2019s not, stop and consider whether there should be.</p> <p>By \u201ccode smell\u201d, we don\u2019t mean that it\u2019s definitely wrong; in fact, it\u2019s often necessary.  We just mean it\u2019s worth checking to see if there\u2019s a better pattern.</p> <p>The first and most basic operations which we\u2019ll cover here are arithmetic operations.</p> <ul> <li>You can add, subtract, and compare quantities of the same units.<sup>2</sup></li> <li>You can multiply and divide quantities of any units.</li> </ul> <p>Example: same-unit operations</p> <p>Here are a couple examples of operations among quantities with the same unit.</p> <pre><code>constexpr auto distance = meters(1.0) + meters(2.0);\n// distance -&gt; meters(3.0)\n\nconstexpr auto is_duration_greater = (seconds(60) &gt; seconds(55));\n// is_duration_greater -&gt; true\n</code></pre> <p>Admittedly, these examples are very basic for now.  Future lessons will explore more interesting examples\u2014like, what happens when you compare a length in inches, to a length in centimeters?  But for now, the takeaway is simply that we neither need nor want to extract underlying values to perform basic operations.</p>"},{"location":"tutorial/101-quantity-makers/#multiplying-and-dividing-quantities","title":"Multiplying and dividing quantities","text":"<p>The product of two quantities is another quantity.</p> <p>Recall that a quantity variable has two parts: the unit, and the value. These parts compose nicely with multiplication.</p> <ul> <li>The unit of the product is the product of the units.</li> <li>The value of the product is the product of the values.</li> </ul> <p>All of these same considerations apply to division.</p> <p>So for example: <code>(meters / second)</code> is a quantity maker.  You can call it and pass any numerical type, just as with the quantity makers <code>meters</code> or <code>seconds</code>.  In particular,</p> <pre><code>meters(50.0) / seconds(10.0) == (meters / second)(5.0);\n</code></pre> <p>Tip</p> <p>To form a compound quantity maker, use the grammatically correct name of the unit.  Examples:</p> <ul> <li><code>meters / second</code>, not <code>meters / seconds</code></li> <li><code>newton * meters</code>, not <code>newtons * meters</code></li> </ul> <p>Empirically, we have found that this pattern works: <code>(s * ...) * p / (s * ...)</code>.  That is:</p> <ul> <li>pluralize only one token</li> <li>for singular tokens: put those which multiply on the left, and those which divide on the   right.</li> </ul>"},{"location":"tutorial/101-quantity-makers/#exercise-computing-with-quantities","title":"Exercise: computing with quantities","text":"<p>To get some practice with quantities, we\u2019ve included an exercise where you can make and print some quantities, and then upgrade an existing function implementation from raw numbers to quantities.</p> <p>Check out the Au 101: API Types Exercise!</p>"},{"location":"tutorial/101-quantity-makers/#takeaways","title":"Takeaways","text":"<ol> <li> <p>We strive for unit safety.  If we can check the unit-correctness of every individual line of    code, by inspection, in isolation, we can reduce cognitive load, and write code faster and more    robustly.</p> </li> <li> <p>To store a raw numeric value safely inside of a quantity object, call the quantity maker    whose name is the unit of interest.</p> <ul> <li>For example, <code>meters(3)</code> is quantity representing 3\\,\\text{m}, stored as <code>int</code>.</li> </ul> </li> <li> <p>To retrieve a stored numeric value from a quantity <code>q</code>, call <code>q.in(units)</code>, where <code>units</code> was the    quantity maker used in the first place.</p> <ul> <li>For example, <code>meters(3).in(meters)</code> is simply <code>3</code>.</li> </ul> </li> <li> <p>Quantity makers compose: you can multiply, divide, and raise them to powers to get a new quantity    maker.</p> <ul> <li>For example, <code>(meters / second)</code> is a quantity maker which you can call like any other. <code>(meters / second)(5)</code> represents the quantity 5\\,\\text{m/s}.</li> </ul> </li> </ol> <p>Tip</p> <p>Au only contains unit-safe interfaces.  That\u2019s why simply storing the value in a quantity is enough to achieve unit-safety!</p> <ol> <li> <p>To take the example from <code>std::chrono::duration</code>, note that the system clock has different resolutions on different widely used toolchains. gcc uses 1\\,\\text{ns}, MSVC uses 100\\,\\text{ns}, and clang uses 1000\\,\\text{ns}.  So if you subtracted two calls to <code>std::chrono::system_clock::now()</code> and called <code>.count()</code>, your answers would vary by 3 orders of magnitude on different compilers!  This is not to say that doing so would be a good use of the chrono library.  It\u2019s not, and that\u2019s the point: a bare call to <code>.count()</code> gives the reader no idea how to interpret its result.\u00a0\u21a9</p> </li> <li> <p>What about adding, subtracting, and comparing quantities of different units, but the same dimensions\u2014like comparing <code>seconds(100)</code> to <code>minutes(1)</code>, or adding <code>inches(1)</code> to <code>feet(6)</code>?  In most cases, we do support this as well, but it\u2019s a more advanced usage which we\u2019ll discuss further in future lessons.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/102-api-types/","title":"Au 102: API Types","text":"<p>This tutorial explains how to name your types in function parameters and member variables.</p> <ul> <li>Time: 30 minutes.</li> <li>Prerequisites: Au 101: Quantity Makers.</li> <li>You will learn:<ul> <li>The <code>Quantity&lt;Unit, Rep&gt;</code> type template.</li> <li>The convenient aliases (<code>QuantityD&lt;Unit&gt;</code>, <code>QuantityI32&lt;Unit&gt;</code>, etc.) for each storage type.</li> <li>How to form compound units.</li> <li>A strategy for upgrading the APIs of existing functions.</li> </ul> </li> </ul>"},{"location":"tutorial/102-api-types/#the-quantityunit-rep-template","title":"The <code>Quantity&lt;Unit, Rep&gt;</code> template","text":"<p>In the previous tutorial, we practiced getting values into and out of the library, and even performing a few simple operations.  However, we skipped the type name.  Let\u2019s learn it now\u2014we\u2019ll need it in order to use a quantity as a function parameter, or a member variable.</p> <p>We store our quantities in a type template with two template parameters: <code>Quantity&lt;Unit, Rep&gt;</code>. <code>Unit</code> is a type representing the unit of measure.  <code>Rep</code>, short for \u201cRepresentation\u201d, is the underlying numeric storage type. Here\u2019s how to provide each parameter.</p> <ul> <li> <p><code>Unit</code>:</p> <ul> <li> <p>This will typically be the <code>CamelCase</code> version of the quantity maker, which is itself   represented in <code>snake_case</code>.  (For example, for the quantity maker <code>meters</code>, the unit type is   <code>Meters</code>.)</p> </li> <li> <p>You can also provide a compound unit.  We\u2019ll explain how to form compound units later in   this section.</p> </li> </ul> </li> <li> <p><code>Rep</code>:</p> <ul> <li>This can be any numeric type: either floating point (<code>double</code>, <code>float</code>), or integral (<code>int</code>,   <code>uint64_t</code>, \u2026).</li> </ul> </li> </ul> <p>Note</p> <p>Someday, we also hope to support more than just built-in numeric types for the Rep!  See #52 for details.</p>"},{"location":"tutorial/102-api-types/#quantitydunit-and-other-aliases","title":"<code>QuantityD&lt;Unit&gt;</code>, and other aliases","text":"<p>Templates with multiple parameters (for example, <code>Quantity&lt;Meters, double&gt;</code>) can be cumbersome.  The whitespace in the type name can make it harder to read at a glance.  Moreover, preprocessor macros will be unable to parse it unless you surround it with extra parentheses.<sup>1</sup></p> <p>To make things easier, we provide concise aliases to handle the most common cases.  For example, <code>QuantityD&lt;Meters&gt;</code> (think: <code>D</code> for <code>double</code>) is identical to <code>Quantity&lt;Meters, double&gt;</code>.  Here\u2019s a table of the ones we support out of the box:</p> Rep Alias <code>double</code> <code>QuantityD</code> <code>float</code> <code>QuantityF</code> <code>int</code> <code>QuantityI</code> <code>unsigned int</code> <code>QuantityU</code> <code>int32_t</code> <code>QuantityI32</code> <code>uint32_t</code> <code>QuantityU32</code> <code>int64_t</code> <code>QuantityI64</code> <code>uint64_t</code> <code>QuantityU64</code>"},{"location":"tutorial/102-api-types/#building-new-units-from-old","title":"Building new units from old","text":"<p>What if your unit doesn\u2019t have its own proper name, but is instead built from other units?  For example, \u201ccentimeters\u201d is built from the named unit \u201cmeters\u201d by applying a prefix, which scales it.  Also, \u201crevolutions per minute\u201d is simply the quotient of the named units \u201crevolutions\u201d and \u201cminutes\u201d.  Here\u2019s how we handle these cases.</p>"},{"location":"tutorial/102-api-types/#prefixed-units","title":"Prefixed units","text":"<p>Every SI and binary prefix is available as a <code>CamelCase</code>-named template.  If you apply it to a unit, you\u2019ll create the prefixed unit.</p> <ul> <li>Example: <code>Centi&lt;Meters&gt;</code> is a unit of \\text{cm}.</li> <li>Example: <code>Gibi&lt;Bytes&gt;</code> is a unit of \\text{GiB}.</li> </ul>"},{"location":"tutorial/102-api-types/#compound-units","title":"Compound units","text":"<p>\u201cCompound units\u201d are units such as \u201cmeters per second squared\u201d, where we form new units by essentially doing arithmetic on existing ones.  This gets a little more complicated than prefixes, because even though we\u2019re both starting and ending with types, the arithmetic itself is more natural to perform on instances.  So here are the steps.</p> <ol> <li> <p>Convert each unit type to an instance, by instantiating it with <code>{}</code>.</p> <ul> <li>For example: <code>Meters</code> is a type; <code>Meters{}</code> is an instance.</li> </ul> </li> <li> <p>Perform your arithmetic operation(s), making compound unit instances out    of your single unit instances.</p> <ul> <li>For example: <code>Meters{} / squared(Seconds{})</code>.</li> </ul> </li> <li> <p>Pass the result to <code>decltype()</code>, to go from your instance back to the type.</p> </li> </ol> <p>Or, in diagram form, here\u2019s how we enter the \u201crealm of instances\u201d to do our arithmetic, and then return to the \u201crealm of types\u201d:</p> <pre><code>flowchart TB\n\nsubgraph \"Realm of Types\"\n  UnitT[\"Single Unit Type\"]\n  CompoundT[\"Compound Unit Type\"]\nend\n\nsubgraph \"Realm of Instances\"\n  UnitI[\"Single Unit Instance\"]\n  CompoundI[\"Compound Unit Instance\"]\nend\n\nUnitT --&gt;|\"{}\"| UnitI\nUnitI --&gt;|\"Arithmetic ops:&lt;br&gt;*, /, squared(), ...\"| CompoundI\nCompoundI --&gt;|\"decltype()\"| CompoundT</code></pre> <p>Generally the best move is to store the result in an alias.  Here\u2019s a complete example.</p> <pre><code>using MetersPerSecondSquared = decltype(Meters{} / squared(Seconds{}));\n</code></pre> <p>Now you can easily form, e.g., a <code>QuantityD&lt;MetersPerSecondSquared&gt;</code> to hold your acceleration values.</p>"},{"location":"tutorial/102-api-types/#exercise-upgrading-an-api","title":"Exercise: upgrading an API","text":"<p>To get some practice with these API types, we\u2019ve included an exercise where you can offer a unit-safe interface alongside a legacy one.</p> <p>Check out the Au 102: API Types Exercise!</p>"},{"location":"tutorial/102-api-types/#takeaways","title":"Takeaways","text":"<ol> <li> <p>The type name for a quantity is <code>Quantity&lt;Unit, Rep&gt;</code>, where <code>Unit</code> is the (<code>CamelCase</code>)    name of the unit, and <code>Rep</code> is the storage type.</p> <ul> <li>For example, the return type of <code>meters(3)</code> is <code>Quantity&lt;Meters, int&gt;</code>.</li> </ul> </li> <li> <p>Prefer using the alias for each storage type, because using multiple template parameters can    be cumbersome.</p> <ul> <li>For example, <code>QuantityU64&lt;Seconds&gt;</code> is an alias for <code>Quantity&lt;Seconds, uint64_t&gt;</code>.</li> </ul> </li> <li> <p>You can apply any prefix to a unit type.</p> <ul> <li>For example, <code>Mega&lt;Hertz&gt;</code> is the unit type for the quantity maker <code>mega(hertz)</code>.</li> </ul> </li> <li> <p>You can form compound units by simply performing arithmetic on instances of the unit    types, and defining an alias.</p> <ul> <li>For example, <code>decltype(Meters{} / squared(Seconds{}))</code> is a unit type, representing the unit \\text{m} / \\text{s}^2.</li> </ul> </li> </ol> <ol> <li> <p>While we avoid using macros in our own library, we can\u2019t avoid them in others!  Even within this repository, we use googletest for our test cases, and googletest is macro-based.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/103-unit-conversions/","title":"Au 103: Unit Conversions","text":"<p>This tutorial explains how to perform unit conversions, both implicitly and explicitly.</p> <ul> <li>Time: 30 minutes.</li> <li>Prerequisites:<ul> <li>Au 101: Quantity Makers.</li> <li>Au 102: API types</li> </ul> </li> <li>You will learn:<ul> <li>How <code>.in(...)</code>, the \u201cvalue retrieving\u201d function, actually performs unit conversions.</li> <li><code>.as(...)</code>: the safer cousin of <code>.in(...)</code>, which gives a quantity instead of a raw number.</li> <li>How to \u201cforce\u201d a physically meaningful conversion which Au thinks is dangerous.</li> <li>Which conversions work automatically, which work only when forced, and which are prevented.</li> <li>Which implicit conversions are allowed.</li> </ul> </li> </ul>"},{"location":"tutorial/103-unit-conversions/#new-units-for-in","title":"New units for <code>.in(...)</code>","text":"<p>Once we store a value in a <code>Quantity</code>, we know we need to name its unit explicitly to get the value back out \u2014 that\u2019s Au 101.</p> <pre><code>constexpr auto q = feet(6);\nq.in(feet);  // &lt;-- produces `6`\n</code></pre> <p>That API is awfully suggestive, though.  What happens if we pass some other unit?</p> <p>Answer: it does just what it looks like it does.</p> <pre><code>constexpr auto q = feet(6);\nq.in(inches); // &lt;-- produces `72`\n</code></pre> <p>We introduced <code>.in(...)</code> as, essentially, \u201cthe function that gets the value back out\u201d.  That was true, but incomplete.  Now we see its true role: it\u2019s the quantity value conversion function.  The role we saw earlier is just a special case: when we pass the same unit we used to create it, that \u201cconversion\u201d is simply the identity.</p> <p>Already, this opens up a new simple, self-contained use case for Au: it\u2019s very easy to conjure up highly readable unit conversions on the fly, even if you both start and end with raw numbers. Consider this example:</p> <pre><code>// Starting with a raw numeric type:\ndouble angle_deg = 90.0;\n\n{ // \u26a0\ufe0f Old, manual method for doing conversions:\n    constexpr auto RAD_PER_DEG = M_PI / 180.0;\n    double angle_rad = angle_deg * RAD_PER_DEG;\n}\n\n{ // \u2714\ufe0f Easy, readable ad hoc conversion with Au:\n    double angle_rad = degrees(angle_deg).in(radians);\n}\n</code></pre> <p>With the old method, we needed to manually craft a carefully named conversion constant.  And because this was an angular conversion, we also needed to worry about how to get a good value for \\pi (here, we chose the <code>M_PI</code> macro).  By contrast, the Au-based alternative gives you a readable, clearly correct one-liner out of the box \u2014 and it doesn\u2019t trouble the author or reader with the details of correctly obtaining (and using) \\pi.</p>"},{"location":"tutorial/103-unit-conversions/#as-like-in-but-makes-a-quantity","title":"<code>.as(...)</code>: like <code>.in(...)</code>, but makes a quantity","text":"<p>Using <code>.in(...)</code> works very well when you want a raw number \u2014 typically, when you\u2019re interacting with some legacy interface.  However, sometimes what you want is a quantity that\u2019s expressed in a specific unit.  For example, you might be comparing quantities in a hot loop, and you\u2019d rather avoid repeated conversions.  Or, you might want to print your quantity in some specific unit.</p> <p>We could satisfy these use cases with <code>.in(...)</code>, but it\u2019s a little clunky:</p> <pre><code>// Not recommended!  See below.\nauto angle = radians(degrees(angle_deg).in(radians));\n//           ^^^^^^^        Raw number--^^ ^^^^^^^\n//                 |                       |\n//                 \\--Repeated identifier--/\n</code></pre> <p>This approach wouldn\u2019t just be repetitive; it would also create a (small!) opportunity for error, because you temporarily leave the safety of the units library before re-entering it.</p> <p>Fortunately, there\u2019s a better choice.  <code>Quantity</code> has another member function, <code>.as(...)</code>, for exactly this use case.  You can pass it any unit you would pass to <code>.in(...)</code>, but <code>.as(...)</code> returns a quantity, not a raw number.  Building on our earlier example:</p> <pre><code>auto angle = degrees(angle_deg).as(radians);\n//      \ud83d\udc4d Don't Repeat Yourself---^^^^^^^\n</code></pre> <p>Use <code>.as(...)</code> when you want easy, inline, fine-grained control over the units in which your quantities are expressed.</p>"},{"location":"tutorial/103-unit-conversions/#conversion-categories","title":"Conversion categories","text":"<p>The examples so far have been pretty straightforward.  To convert from <code>feet</code> to <code>inches</code>, we simply multiply the underlying value by 12.  That seems pretty safe for just about any Rep<sup>1</sup>, whether floating point or integral.  However, other conversions can be more subtle.</p> <p>Let\u2019s look at a bunch of example unit conversions.  We\u2019ll show how each conversion works with both <code>int</code> and <code>double</code> Rep, because the rules can differ significantly for integral and floating point types.</p> <p>Instructions</p> <p>For each example: stop and think about what you would expect the library to produce in each case.  When you\u2019re ready, click over to the \u201cResults and Discussion\u201d tab to check your intuition.</p> <p>Example: <code>feet</code> to <code>yards</code></p> ConversionResults and Discussion <pre><code>feet(6).as(yards);\n\nfeet(6.0).as(yards);\n</code></pre> <pre><code>feet(6).as(yards);  // Compiler error!\n\nfeet(6.0).as(yards);  // yards(2.0)\n</code></pre> <p>Converting from <code>feet</code> to <code>yards</code> means dividing the underlying value by 3.</p> <p>For an integral Rep, this actually yields a compiler error, because we can\u2019t guarantee that the result will be an integer.  True, with <code>feet(6)</code>, it so happens that it would \u2014 but if we had <code>feet(5)</code>, this wouldn\u2019t be the case!</p> <p>Floating point Rep is simpler.  When we divide any value by <code>3</code>, we won\u2019t exceed typical floating point error.  Because this level of uncertainty simply goes with the territory when using floating point types, Au allows this operation with no complaint.</p> <p>Example: <code>feet</code> to <code>nano(meters)</code></p> ConversionResults and Discussion <pre><code>feet(6).as(nano(meters));\n\nfeet(6.0).as(nano(meters));\n</code></pre> <pre><code>feet(6).as(nano(meters));  // Compiler error!\n\nfeet(6.0).as(nano(meters));  // nano(meters)(1'828'800'000.0)\n</code></pre> <p>Converting from <code>feet</code> to <code>nano(meters)</code> means multiplying the underlying value by 304,800,000.</p> <p>Unlike the last example, this is guaranteed to produce an integer result.  Yet, the integral Rep again gives us a compiler error!  This time, we\u2019re guarding against a different risk: overflow.  It turns out that any underlying value larger than <code>feet(7)</code> would overflow in this conversion.  That\u2019s pretty scary, so we forbid this conversion.</p> <p>Of course, that\u2019s just because <code>int</code> is typically only 32 bits.  Au adapts to the specific level of overflow risk, based on both the conversion and the range of the type.  For example, this integral-type conversion would work:</p> <pre><code>feet(6LL).as(nano(meters));  // nano(meters)(1'828'800'000LL)\n</code></pre> <p>Since <code>long long</code> is at least 64 bits, we could handle values into the tens of billions of feet before overflowing!  (For more details on the overflow problem, and Au\u2019s strategies for mitigating it, read our overflow discussion.)</p> <p>As for the floating point value, this is again very safe, so we allow it without complaint.</p> <p>Example: <code>feet</code> to <code>kelvins</code></p> ConversionResults and Discussion <pre><code>feet(6).as(kelvins);\n\nfeet(6.0).as(kelvins);\n</code></pre> <pre><code>feet(6).as(kelvins);  // Compiler error!\n\nfeet(6.0).as(kelvins);  // Compiler error!\n</code></pre> <p>Converting from <code>feet</code> to <code>kelvins</code> is an intrinsically meaningless operation, because they have different dimensions (namely, length and temperature).  For both integral and floating point Rep, we forbid this operation.</p>"},{"location":"tutorial/103-unit-conversions/#forcing-lossy-conversions-coerce_as-and-coerce_in","title":"Forcing lossy conversions: <code>.coerce_as(...)</code> and <code>.coerce_in(...)</code>","text":"<p>Sometimes, you may want to perform a conversion even though you know it\u2019s usually lossy.  For example, maybe you know that your particular value will give an exact result (like converting 6 feet into yards).  Or perhaps the truncation is desired.</p> <p>Whatever the reason, you can simply add the word \u201ccoerce\u201d before your conversion function to make it \u201cforcing\u201d.  Consider this example.</p> <pre><code>feet(6.0).as(yards);       // yards(2.0)\n\n// Compiler error!\n// feet(6).as(yards);\n\nfeet(6).coerce_as(yards);  // yards(2)\n</code></pre> <p>These \u201ccoercing\u201d versions work similarly to <code>static_cast</code>, in that they will truncate if necessary. For example:</p> <pre><code>feet(5).coerce_as(yards);  // yards(1) --- a truncation of (5/3 = 1.6666...) yards\n</code></pre> <p>You can use this to \u201coverrule\u201d Au when we prevent a physically meaningful conversion because we think it\u2019s too risky.</p> <p>Tip</p> <p>Prefer not to use the coercing versions unless you have a good reason.  If you do, consider adding a comment to explain why your specific use case is OK.</p> <p>As a code reviewer, if you see a coercing version that doesn\u2019t seem necessary or justified, ask about it!</p> <p>At this point, we\u2019ve seen several examples of conversions which Au forbids.  We\u2019ve also seen how some of them can be forced anyway.  Here\u2019s a chance to test your understanding: what will happen if you try to force that final example \u2014 the one where the dimensions differ?</p> <p>Example: forcing different-dimension conversions?</p> <p>As before, stop and think about what you would expect the library to produce.  When you\u2019re ready, click over to the \u201cResults and Discussion\u201d tab to check your intuition.</p> ConversionResults and Discussion <pre><code>feet(6).coerce_as(kelvins);\n</code></pre> <pre><code>feet(6).coerce_as(kelvins);  // Compiler error!\n</code></pre> <p>Converting units with different dimensions isn\u2019t merely \u201cunsafe\u201d; it\u2019s completely meaningless.  We can\u2019t \u201cforce\u201d the answer because there isn\u2019t even an answer to force.</p>"},{"location":"tutorial/103-unit-conversions/#conversion-summary","title":"Conversion summary","text":"<p>This table gives a visual summary of how different kinds of risks impact conversions with different storage types.</p> Conversion Result (<code>int</code> Rep):<code>length = feet(6)</code> Result (<code>double</code> Rep):<code>length = feet(6.0)</code> <code>length.as(inches)</code> <code>inches(72)</code> <code>inches(72.0)</code> <code>length.as(yards)</code> Forbidden: not guaranteed to be integral(can be forced with coercing version)      <code>yards(2.0)</code> <code>length.as(nano(meters))</code> Forbidden: excessive overflow risk(can be forced with coercing version)      <code>nano(meters)(1'828'800'000.0)</code> <code>length.as(kelvins)</code> Forbidden: meaningless Forbidden: meaningless"},{"location":"tutorial/103-unit-conversions/#implicit-conversions","title":"Implicit conversions","text":"<p>Au emphasizes developer experience.  We strive to provide the same ergonomics which developers have come to expect from the venerable <code>std::chrono</code> library.  This means that any meaningful conversion which we consider \u201csafe enough\u201d (based on the above criteria), we permit implicitly.  This lets you fluently initialize a quantity parameter with any convertible expression.  For example:</p> <pre><code>// API accepting a quantity parameter.\nvoid rotate(QuantityD&lt;Radians&gt; angle);\n\n// This works!\n// We'll automatically convert the integral quantity of degrees to `QuantityD&lt;Radians&gt;`.\nrotate(degrees(45));\n</code></pre> <p>Our conversion policy is a refinement of the policy for <code>std::chrono::duration</code>.  Here is their policy (paraphrased and simplified):</p> <ul> <li>Implicit conversions are permitted if either:<ul> <li>The destination is floating point;</li> <li>Or, the source type is integer, and the conversion multiplies by an integer.</li> </ul> </li> </ul> <p>And here is our refinement (the overflow safety surface):</p> <ul> <li>If an integral-Rep conversion would overflow the destination type for a source value as small   as <code>2'147</code>, we forbid the conversion.</li> </ul> Deeper dive: comparing overflow strategies for Au and <code>chrono</code> <p>The <code>std::chrono</code> library doesn\u2019t consider overflow in its conversion policy, because they handle the problem in a different way.  Instead of encouraging users to use <code>duration</code> directly, they provide pre-defined helper types such as <code>std::chrono::nanoseconds</code>, <code>std::chrono::milliseconds</code>, etc.  The Rep for each of these types is chosen to guarantee covering at least 292 years in either direction.</p> <p>This is a good and practical solution, which is effective at preventing overflow for users who stick to these helper types.  The downside is that it forces users to change their underlying storage types \u2014 changing the assembly code produced \u2014 in the process of acquiring unit safety.</p> <p>A key design goal of Au is to avoid forcing users to change their underyling numeric types.  We want to empower people to get the same assembly they would have had without Au, just more safely. Because smaller numeric types bring this extra overflow risk (and in a way that\u2019s often non-obvious to developers), we designed this adaptive policy which prevents the biggest risks.</p> <p>(Lastly, of course we also forbid conversions between units of different dimensions.  This consideration wasn\u2019t part of the <code>std::chrono</code> library, because that library only has a single dimension.)</p>"},{"location":"tutorial/103-unit-conversions/#exercise-practicing-conversions","title":"Exercise: practicing conversions","text":"<p>Check out the Au 103: Unit Conversions Exercise!</p>"},{"location":"tutorial/103-unit-conversions/#takeaways","title":"Takeaways","text":"<ol> <li> <p>To convert a quantity to a particular unit, pass that unit\u2019s quantity maker to the    appropriate member function, <code>.in(...)</code> or <code>.as(...)</code>.</p> <ul> <li>For example, <code>minutes(3)</code> is a quantity, and <code>minutes(3).as(seconds)</code> produces <code>seconds(180)</code>.</li> </ul> </li> <li> <p><code>.in(...)</code> gives a raw number, while <code>.as(...)</code> gives a quantity.</p> <ul> <li> <p>These names are used consistently in this way throughout the library.  For example, we\u2019ll   learn in the next tutorial that <code>round_in(...)</code> produces a raw number, while <code>round_as(...)</code>   produces a quantity.</p> </li> <li> <p>Prefer <code>.as(...)</code> when you have a choice, because it stays within the safety of the   library.</p> </li> </ul> </li> <li> <p>Both conversion functions include safety checks.  This means you can generally just use    them, and rely on the library to guard against the biggest risks.  Here are the details to    remember about these safety checks.</p> <ul> <li> <p>We forbid conversions with mismatched dimensions (as with any units library).</p> </li> <li> <p>We forbid conversions for integer destinations unless we\u2019re sure we\u2019ll always have an   integer (as with the <code>chrono</code>   library), and we don\u2019t have   excessive overflow risk (an Au-original feature!).</p> </li> </ul> </li> <li> <p>You can force a conversion that is meaningful, but considered dangerous by preceding your    function name with <code>coerce_</code>.</p> <ul> <li> <p>For example: <code>seconds(200).as(minutes)</code> won\u2019t compile, but <code>seconds(200).coerce_as(minutes)</code>   gives <code>minutes(3)</code>, because we forced this lossy conversion by using the word \u201ccoerce\u201d.</p> </li> <li> <p>Use this sparingly, since the safety checks are there for a reason, and consider adding   a comment to explain why your usage is safe.</p> </li> <li> <p>You can never force a conversion to a different dimension, because this is not meaningful.</p> </li> </ul> </li> <li> <p>Any conversion allowed by <code>.as(...)</code> will also work as an implicit conversion.</p> <ul> <li>For example, if you have an API which takes <code>QuantityD&lt;Radians&gt;</code>, you can pass <code>degrees(45)</code>   directly to it.</li> </ul> </li> </ol> <ol> <li> <p>Recall that the \u201cRep\u201d is shorthand for the underlying storage type of the quantity.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorial/exercise/101-quantity-makers/","title":"Au 101: Quantity Makers Exercise","text":"<p>Note</p> <p>This is the exercise for the concepts in the tutorial page Au 101: Quantity Makers. We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first.</p> <p>Tip</p> <p>Before you start, make sure you\u2019ve followed the developer\u2019s guide so you\u2019re able to build and test the code!</p>"},{"location":"tutorial/exercise/101-quantity-makers/#introduction","title":"Introduction","text":"<p>The point of this exercise is to get some practice making and using quantities.  We\u2019ll get values into and out of the units library, and we\u2019ll also perform a few operations (simple arithmetic, and streaming output).</p> <p>The file we\u2019ll be working in can be found here, relative to the repository root:</p> <ul> <li><code>\"tutorial/101_quantity_makers.cc\"</code></li> </ul> <p>The following command executes the code:</p> <pre><code>bazel run //tutorial:101_quantity_makers\n</code></pre> <p>Run it now to make sure everything\u2019s working: it should run to completion, and all tests should pass.</p>"},{"location":"tutorial/exercise/101-quantity-makers/#exercise-1-printing-quantities","title":"Exercise 1: printing quantities","text":"<p>Open up the file, <code>\"tutorial/101_quantity_makers.cc\"</code>, and scroll down to the <code>EXERCISE 1(a)</code> section.  This takes you to a function, <code>print_raw_number_and_quantity()</code>, where you\u2019ll begin the exercise.</p> <p>Exercise 1(a)</p> TaskSolution and Discussion <p>Read through the function <code>print_raw_number_and_quantity()</code>, and uncomment the final two lines.  Note that in the second line, we\u2019re streaming a quantity variable to output. What do you expect to see?</p> <p>When you\u2019ve formed an expectation, run the target:</p> <pre><code>bazel run //tutorial:101_quantity_makers\n</code></pre> <p>What do you see?  Did it match your expectations?</p> <p>Here\u2019s what will be printed:</p> <pre><code>track_length_m: 100\ntrack_length: 100 m\n</code></pre> <p>Note how the unit information has effectively migrated.  With the raw <code>double</code>, it was a suffix on the variable name, which means that human readers are responsible for keeping track of it.  With the quantity, it becomes a part of the type itself, so the compiler is responsible for keeping track of it.</p> <p>The Au library has a compile-time label for every unit.  When we stream the quantity, we first stream its underlying value, and then stream the unit label.</p> <p>Now we have a more interactive example.  We\u2019ll create several quantities, and for each one, you need to write how you expect it to be printed.</p> <p>Exercise 1(b)</p> TaskSolution and Discussion <p>Scroll down to the <code>PrintsAsExpected</code> test case (just below the <code>EXERCISE 1(b)</code> comment block), and uncomment each test assertion one at a time.  Replace the empty string placeholder, <code>\"\"</code>, with the actual string you expect when streaming this quantity.</p> <p>For example, if you see this:</p> <pre><code>EXPECT_EQ(stream_to_string(squared(meters)(100)), \"\");\n</code></pre> <p>then you would replace it with this:</p> <pre><code>EXPECT_EQ(stream_to_string(squared(meters)(100)), \"100 m^2\");\n</code></pre> <p>When you\u2019re done, your assertions should look something like this:</p> <pre><code>EXPECT_EQ(stream_to_string(meters(100)), \"100 m\");\n\nEXPECT_EQ(stream_to_string(meters(100.0) / seconds(8.0)), \"12.5 m / s\");\nEXPECT_EQ(stream_to_string((meters / second)(12.5)), \"12.5 m / s\");\n\nEXPECT_EQ(stream_to_string((meters / second)(10.0) / seconds(8.0)), \"1.25 m / s^2\");\nEXPECT_EQ(stream_to_string((meters / second)(10.0) * seconds(8.0)), \"80 m\");\n</code></pre> <p>The first is a warm-up problem: a checkpoint to make sure you\u2019re doing the exercise correctly.</p> <p>The second gives an example of a general principle: when we multiply or divide quantities, we can reason independently about the units, and the underlying values.  In this case, we know that the result\u2019s underlying value will be <code>100.0 / 8.0</code>, that is, <code>12.5</code>.  And the unit will be meters (\\text{m}) divided by seconds (\\text{s}), that is, \\text{m} / \\text{s}.  (Notice how the library automatically generates a label for compound units: from the input labels <code>m</code> and <code>s</code>, the compound label <code>m / s</code> is generated at compile time.)</p> <p>The third example represents the same quantity as the second, except that it\u2019s constructed directly via the compound quantity maker, <code>(meters / second)</code>.  Again, as in the tutorial page, note the grammar: we write <code>(meters / second)</code>, not <code>(meters / seconds)</code>.</p> <p>The fourth example shows that when we accumulate powers of the same unit, the automatically generated label knows how to represent these.  \u201cMeters per second\u201d, divided by \u201cseconds\u201d, gives \u201cmeters per squared second\u201d, labeled as <code>m / s^2</code>.</p> <p>The fifth example shows that when any unit cancels out completely, it gets dropped from the label.  \u201cMeters per second\u201d, times \u201cseconds\u201d, gives simply \u201cmeters\u201d.</p>"},{"location":"tutorial/exercise/101-quantity-makers/#exercise-2-implementing-with-quantities","title":"Exercise 2: implementing with quantities","text":"<p>Exercise 2</p> TaskSolution and Discussion <p>Replace the implementation of the function <code>stopping_accel_mpss()</code> with quantities, instead of raw <code>double</code>s. You will probably want to do this in three stages.</p> <ol> <li> <p>Create a new quantity variable for each parameter.  It should have the same name,       minus the unit suffix.  For example, for a parameter <code>double duration_s</code>, you would       write:</p> <pre><code>const auto duration = seconds(duration_s);\n</code></pre> <p>(Note the unit-safe handoff, between the quantity-maker <code>seconds</code> and the unit suffix   <code>_s</code>.)</p> </li> <li> <p>Replace the raw <code>double</code>s in the core computation with their corresponding quantity       variables.  Note that you\u2019ll need to change both the type (to <code>auto</code>), and the name       (to eliminate the suffix).</p> </li> <li> <p>Use <code>.in(...)</code> to extract the raw double to return.  You\u2019ll need to form the correct       quantity maker to pass to it.</p> </li> </ol> <p>When you\u2019re done, your implementation should look something like this:</p> <pre><code>// Example updated solution:\ndouble stopping_accel_mpss(double initial_speed_mps, double stopping_distance_m) {\n    const auto initial_speed = (meters / second)(initial_speed_mps);\n    const auto stopping_distance = meters(stopping_distance_m);\n\n    const auto accel = -(initial_speed * initial_speed) / (2.0 * stopping_distance);\n\n    return accel.in(meters / squared(second));\n}\n</code></pre> <p>Let\u2019s evaluate the code change relative to the original, which we\u2019ll reproduce here for convenience.</p> <pre><code>// Original:\ndouble stopping_accel_mpss(double initial_speed_mps, double stopping_distance_m) {\n    const double accel_mpss =\n        -(initial_speed_mps * initial_speed_mps) / (2.0 * stopping_distance_m);\n\n    return accel_mpss;\n}\n</code></pre> <ul> <li>PRO:<ul> <li> The core computation is now protected from unit errors.</li> <li> The core computation is also less cluttered without the unit   suffixes.</li> <li> The runtime performance is identical, with even the slightest   optimization levels enabled.</li> </ul> </li> <li>CON:<ul> <li> We\u2019ve added extra lines to turn our <code>double</code> variables into quantities.</li> <li> We haven\u2019t improved unit safety at the callsites at all.</li> </ul> </li> </ul> <p>Admittedly, this change is pretty marginal for such a short function, but keep in mind that this example is just a baby step.  The real power of the library will come when we learn how to use quantities in our API types: our function parameters, return values, and member variables.  Then we\u2019ll gain far-reaching improvements that can make development faster and safer across an entire codebase.</p>"},{"location":"tutorial/exercise/101-quantity-makers/#summary","title":"Summary","text":"<p>This exercise showed the basics of how to work with quantities.  Here are some skills we practiced:</p> <ul> <li>Turning a raw numeric value into a quantity, by calling a quantity maker (for example,   <code>meters(5.0)</code>).</li> <li>Extracting raw numeric values from quantities, by calling <code>.in(...)</code> (for example,   <code>accel.in(meters / squared(second))</code>).</li> <li>Forming and using compound quantity makers, such as <code>(meters / second)(12.5)</code>.</li> <li>Performing basic operations with quantities, including:<ul> <li>Multiplying and dividing them.</li> <li>Streaming them to output (but see the note below).</li> </ul> </li> </ul> <p>Note</p> <p>I/O streaming support isn\u2019t included in every installation method.</p> <ul> <li>For single-file installations, it\u2019s included by default, but can be omitted by choice.</li> <li>For full library installations, one needs to include <code>\"au/io.hh\"</code> to get this   functionality.</li> </ul> <p>The gist is that it will tend to be either already included, or easily accessible, unless somebody made a conscious decision during the installation to exclude it.</p> <p>Return to the main tutorial page.</p>"},{"location":"tutorial/exercise/102-api-types/","title":"Au 102: API Types Exercise","text":"<p>Note</p> <p>This is the exercise for the concepts in the tutorial page Au 102: API Types. We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first.</p> <p>Tip</p> <p>Before you start, make sure you\u2019ve followed the developer\u2019s guide so you\u2019re able to build and test the code!</p>"},{"location":"tutorial/exercise/102-api-types/#introduction-the-legacy-function","title":"Introduction: the legacy function","text":"<p>Here\u2019s a simple example of a function that deals with physical quantities, but lacks unit safety because it\u2019s using raw numeric types.</p> <pre><code>// The distance (in meters) it would take to stop, with a given starting speed\n// and constant (negative) acceleration.\n//\n// Parameters:\n// - speed_mps:  The starting speed, in meters per second.\n// - acceleration_mpss:  The braking acceleration, in meters per second squared.\n//\n// Preconditions:\n// - speed_mps &gt;= 0.0\n// - acceleration_mpss &lt; 0.0\nconstexpr double stopping_distance_m(\n    double speed_mps, double acceleration_mpss);\n</code></pre> <p>We\u2019re going to provide a unit-safe interface for any clients that want to use it.  We\u2019ll leave the old interface in place, so we won\u2019t be forced to update our codebase all at once!</p> <p>To make sure you\u2019re set up and ready to go, run <code>bazel test //tutorial:102_api_types_test</code>.  All tests should pass.</p> <p>The three files we\u2019ll be working in can be found here, relative to the repository root:</p> <ul> <li><code>\"tutorial/102_api_types.hh\"</code></li> <li><code>\"tutorial/102_api_types.cc\"</code></li> <li><code>\"tutorial/102_api_types_test.cc\"</code></li> </ul>"},{"location":"tutorial/exercise/102-api-types/#exercise-1-new-interface-shim","title":"Exercise 1: new interface shim","text":"<p>Open up the test file, <code>\"tutorial/102_api_types_test.cc\"</code>, and scroll down to the <code>EXERCISE 1</code> section.  You\u2019ll find two test cases below, which are commented out.  Uncomment them, and rerun the tests.  As before:</p> <pre><code>bazel test //tutorial:102_api_types_test\n</code></pre> <p>They\u2019ll fail.</p> <p>Exercise 1(a)</p> TaskSolution and Discussion <p>Make these new tests compile by declaring a new function, in <code>\"tutorial/102_api_types.hh\"</code>, with this signature:</p> <pre><code>AAA stopping_distance(BBB speed, CCC acceleration);\n</code></pre> <p>The types <code>AAA</code>, <code>BBB</code>, and <code>CCC</code> are placeholders for quantity types; it\u2019s your job to figure out the actual types which should go there.  The <code>Rep</code> for each quantity should be <code>double</code>, since that\u2019s what the function we\u2019re replacing uses.  As for the <code>Unit</code>, you may find it useful to define appropriate aliases for, say, <code>MetersPerSecond</code> and <code>MetersPerSecondSquared</code>.</p> <p>Something like this inside of your <code>\"tutorial/102_api_types.hh\"</code> file should work:</p> <pre><code>using MetersPerSecond = decltype(Meters{} / Seconds{});\nusing MetersPerSecondSquared = decltype(MetersPerSecond{} / Seconds{});\n\nQuantityD&lt;Meters&gt; stopping_distance(QuantityD&lt;MetersPerSecond&gt; speed,\n                                    QuantityD&lt;MetersPerSecondSquared&gt; acceleration);\n</code></pre> <p>First, we declared the aliases for the compound units.  Then, we made a new signature with quantity types instead of raw <code>double</code>.  We used the <code>QuantityD&lt;U&gt;</code> form, rather than <code>Quantity&lt;U, double&gt;</code>, for conciseness.</p> <p>Warning</p> <p>When composing unit type instances (like <code>Meters{}</code>), we don\u2019t get the same fluency as when we compose quantity makers (like <code>meters</code>).  In particular, we can\u2019t offer the same grammatical fluency.  With quantity makers, we would write <code>meters / second</code>.  However, with unit type instances, we end up needing to write <code>Meters{} / Seconds{}</code>, rather than <code>Meters{} / Second{}</code>.</p> <p>Note that we also removed the suffixes (such as <code>_m</code>, <code>_mps</code>, and <code>_mpss</code>) from the variable and function names.  Those suffixes were there to help humans keep track of units.  Now that\u2019s the compiler\u2019s job!</p> <p>If we rerun the tests now, we\u2019ll find we get a linker error rather than a compiler error.  This makes sense: our function hasn\u2019t been implemented yet.</p> <p>Exercise 1(a)</p> TaskSolution and Discussion <p>Go to <code>102_api_types.cc</code>, and implement the function you had just declared.</p> <p>Your function implementation should amount to a thin wrapper on the existing function. First, we\u2019ll \u201cunwrap\u201d the input quantity parameters, giving us raw <code>double</code> values we can pass to the old version.  Then, we\u2019ll \u201cwrap\u201d the answer with the appropriate quantity maker.</p> <p>Something like this inside of your <code>\"tutorial/102_api_types.cc\"</code> file should work:</p> <pre><code>QuantityD&lt;Meters&gt; stopping_distance(QuantityD&lt;MetersPerSecond&gt; speed,\n                                    QuantityD&lt;MetersPerSecondSquared&gt; acceleration) {\n    return meters(stopping_distance_m(speed.in(meters / second),\n                                      acceleration.in(meters / squared(second))));\n}\n</code></pre> <p>Notice how we have a unit-safe handoff on the output.  We\u2019re passing the result of <code>stopping_distance_m(...)</code> to <code>meters(...)</code>, and we can see that the units match.</p> <p>We don\u2019t have a unit-safe handoff on the inputs.  The only way to check they\u2019re correct is by carefully inspecting the order and comparing to the signature of <code>stopping_distance_m()</code>.  Fortunately, that function lives in the same file, so it\u2019s not too onerous to verify the correctness.</p> Reminder about <code>.in(...)</code> syntax <p>The argument you pass needs to be an instance, not a type.  It may be tempting to call <code>speed.in(MetersPerSecond)</code>, but that\u2019s not valid C++ (you can\u2019t \u201cpass a type\u201d to a function).  That\u2019s why we passed the quantity maker instead: <code>speed.in(meters / second)</code>.</p>"},{"location":"tutorial/exercise/102-api-types/#exercise-2-reverse-the-roles","title":"Exercise 2: reverse the roles","text":"<p>At this point, we\u2019re in pretty decent shape.  We\u2019ve provided a unit-safe interface which anyone can take advantage of.  And we\u2019ve left the old interface in place, so we haven\u2019t broken any existing clients!</p> <p>However, we can do a lot better.</p> <p>First, if you read the commentary in the previous section\u2019s solution, you\u2019ll know that the input parameters don\u2019t have a unit-safe handoff.  That\u2019s a small problem.  A bigger problem is that we\u2019re not taking full advantage of the units library in our implementation itself!  To see why this matters, introduce a unit error by deleting the <code>* t_s</code> from the end of the implementation:</p> <pre><code>    return speed_mps * t_s + 0.5 * acceleration_mpss * t_s * t_s;\n    //                                      Delete this---^^^^^^\n</code></pre> <p>Save the file and rerun all the tests.  Even though the implementation is wrong, the tests all pass!</p> <p>Note that we\u2019re adding a distance and a speed here. If we were using quantities, the wrong code wouldn\u2019t even compile.  (That said: in a real project, this would also be a good signal to add more test cases, too.  )</p> <p>Undo the error you introduced.  Now you\u2019re ready to fix both these problems at once.</p> <p>Exercise 2</p> TaskSolution and Discussion <p>Reverse the roles of the functions.</p> <ul> <li>Use quantity types for the core logic.</li> <li>Turn the raw numeric version into the thin wrapper.</li> </ul> <p>All existing tests should pass without modification.</p> <p>Something like this inside of your <code>\"tutorial/102_api_types.cc\"</code> file should work:</p> <pre><code>double stopping_distance_m(double speed_mps, double acceleration_mpss) {\n    // Convenient ad hoc quantity makers, for readability.\n    constexpr auto mps = meters / second;\n    constexpr auto mpss = meters / squared(second);\n\n    return stopping_distance(mps(speed_mps), mpss(acceleration_mpss)).in(meters);\n}\n\nQuantityD&lt;Meters&gt; stopping_distance(QuantityD&lt;MetersPerSecond&gt; speed,\n                                    QuantityD&lt;MetersPerSecondSquared&gt; acceleration) {\n    // This first implementation uses only the most basic kinematic equations.\n    // We could refactor it later to be more efficient.\n\n    // t = (v - v0) / a\n    const auto t = -speed / acceleration;\n\n    // (x - x0) = (v0 * t) + (1/2)(a * t^2)\n    return speed * t + 0.5 * acceleration * t * t;\n}\n</code></pre> <p>Here, we chose to separate out the construction of our quantity makers, so we could make the \u201creal\u201d line more concise and readable.  This has no impact on performance either way, but in this case it makes the unit-safe handoffs easier to see at a glance.  Do whatever makes your code the most readable!</p> <p>As for the \u201ccore logic\u201d implementation, note how it turns out to be much cleaner without the unit suffixes clogging up the variable name.  It\u2019s also more robust.  If you try introducing the same unit error we did up above, you should find that it gets caught at compile time.</p>"},{"location":"tutorial/exercise/102-api-types/#summary","title":"Summary","text":"<p>This exercise showed how you can upgrade the unit safety of your codebase incrementally, without forcing huge changes across your project.  You can provide a new, unit-safe API which coexists with the old one, which becomes a thin wrapper.  You can migrate your clients independently in small batches.  And when they\u2019re all migrated, simply delete the old one!</p> <p>Tip</p> <p>As you become more proficient with the library, you may prefer to skip straight to the second step, and turn the old function into the \u201cshim\u201d right away.  This is generally a better approach.</p> <p>Return to the main tutorial page.</p>"},{"location":"tutorial/exercise/103-unit-conversions/","title":"Au 103: Unit Conversions Exercise","text":"<p>Note</p> <p>This is the exercise for the concepts in the tutorial page Au 103: Unit Conversions. We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first.</p> <p>Tip</p> <p>Before you start, make sure you\u2019ve followed the developer\u2019s guide so you\u2019re able to build and test the code!</p>"},{"location":"tutorial/exercise/103-unit-conversions/#introduction","title":"Introduction","text":"<p>This exercise is a chance to practice unit conversions.</p> <p>The file we\u2019ll be working in can be found here, relative to the repository root:</p> <ul> <li><code>\"tutorial/103_unit_conversions_test.cc\"</code></li> </ul> <p>The following command executes the tests.</p> <pre><code>bazel test --test_output=all //tutorial:103_unit_conversions_test\n</code></pre>"},{"location":"tutorial/exercise/103-unit-conversions/#exercise-1-ad-hoc-conversions","title":"Exercise 1: ad hoc conversions","text":"<p>We\u2019ll practice writing some ad hoc conversions that can replace their more labor-intensive, error-prone manual counterparts.</p> <p>Since these both start and end with raw numeric types, we\u2019ll use <code>.in</code> rather than <code>.as</code>, even though the latter is generally preferred whenever we have a choice.  (Perhaps a future refactoring could replace these raw numeric types with quantities in the rest of this hypothetical codebase. )</p> <p>Open up the file, <code>\"tutorial/103_unit_conversions_test.cc\"</code>, and scroll down to the <code>EXERCISE 1</code> section.  This takes you to two unit tests in the <code>AdHocConversions</code> group: <code>DegreesToRadians</code>, and <code>MilesPerHourToMetersPerSecond</code>.</p> <p>In each test, find the unit conversion, which is currently done with manual conversion factors. Replace it with an ad hoc inline conversion based on Au.</p> <p>Exercise 1(a)</p> TaskSolution and Discussion <p>Convert the <code>DegreesToRadians</code> test:</p> <pre><code>TEST(AdHocConversions, DegreesToRadians) {\n    constexpr double angle_deg = 135.0;\n\n    constexpr double RAD_PER_DEG = M_PI / 180.0;\n\n    // TODO: replace `angle_rad` computation with an ad hoc conversion, using Au.\n    constexpr double angle_rad = angle_deg * RAD_PER_DEG;\n\n    EXPECT_DOUBLE_EQ(angle_rad, 3.0 * M_PI / 4.0);\n}\n</code></pre> <p>A possible solution:</p> <pre><code>TEST(AdHocConversions, DegreesToRadians) {\n    constexpr double angle_deg = 135.0;\n\n\n\n\n    constexpr double angle_rad = degrees(angle_deg).in(radians);\n\n    EXPECT_DOUBLE_EQ(angle_rad, 3.0 * M_PI / 4.0);\n}\n</code></pre> <p>Tip</p> <p>Instead of deleting the obsolete lines, we replaced them with blank lines.  This lets you go back and forth, using the left and right arrow keys, to see exactly what changed.</p> <p>We start with a unit-safe handoff, <code>degrees(angle_deg)</code>, from the <code>_deg</code> suffix to the <code>degrees()</code> function.  Then we end with another unit-safe handoff: from <code>.in(radians)</code> to the <code>_rad</code> \u201csuffix\u201d in the variable name.</p> <p>Overall, we can see that this conversion is correct by just reading this single line of code.  That\u2019s unit safety!</p> <p>Exercise 1(b)</p> TaskSolution and Discussion <p>Convert the <code>MilesPerHourToMetersPerSecond</code> test:</p> <pre><code>TEST(AdHocConversions, MilesPerHourToMetersPerSecond) {\n    constexpr double speed_mph = 65.0;\n\n    // Carefully compute conversion factor manually.\n    constexpr double M_PER_CM = 0.01;\n    constexpr double CM_PER_INCH = 2.54;\n    constexpr double INCHES_PER_FEET = 12.0;\n    constexpr double FEET_PER_MILE = 5280.0;\n    constexpr double M_PER_MILE = M_PER_CM * CM_PER_INCH * INCHES_PER_FEET * FEET_PER_MILE;\n\n    constexpr double S_PER_H = 3600.0;\n\n    constexpr double MPS_PER_MPH = M_PER_MILE / S_PER_H;\n\n    // TODO: replace `speed_mps` computation with an ad hoc conversion, using Au.\n    constexpr double speed_mps = speed_mph * MPS_PER_MPH;\n\n    EXPECT_DOUBLE_EQ(speed_mps, 29.0576);\n}\n</code></pre> <p>A possible solution:</p> <pre><code>TEST(AdHocConversions, MilesPerHourToMetersPerSecond) {\n    constexpr double speed_mph = 65.0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n    constexpr double speed_mps = (miles / hour)(speed_mph).in(meters / second);\n\n    EXPECT_DOUBLE_EQ(speed_mps, 29.0576);\n}\n</code></pre> <p>Tip</p> <p>Instead of deleting the obsolete lines, we replaced them with blank lines.  This lets you go back and forth, using the left and right arrow keys, to see exactly what changed.</p> <p>As before, we start and end our conversion with unit-safe handoffs.  The units themselves are a little more complicated than before because they\u2019re compound units, but overall this Au-based conversion has similar readability to the one from the previous example.</p> <p>We can\u2019t say the same for the code it replaced, however \u2014 it\u2019s much more complicated than the previous example!  In order to write it in a form which is clearly correct, we need to chain together a string of carefully named elementary conversion factors.  Even once we do, it probably takes some squinting to convince yourself that <code>MPS_PER_MPH</code> really is \u201cmeters-per-mile\u201d divided by \u201cseconds-per-hour\u201d.</p> <p>The Au-based conversion is a huge improvement in readability and simplicity, as evidenced by all the whitespace above (which we can now remove).</p>"},{"location":"tutorial/exercise/103-unit-conversions/#exercise-2-decomposing-inches-onto-feet-and-inches","title":"Exercise 2: decomposing inches onto feet-and-inches","text":"<p>Now we want to take a height in inches, and decompose it so we can represent it as some integer number of feet, plus some integer number of inches which measures less than a foot.  Scroll down to the function <code>decompose_height()</code>, and fill in the <code>PLACEHOLDER</code> instances with correct expressions that will make the test below pass.</p> <p>You may find it useful to use the explicit-Rep overload to force a conversion that is generally risky, but in this instance is known to be OK.  You should not need to use floating point numbers at all.</p> <p>Exercise 1(b)</p> TaskSolution and Discussion <p>Replace <code>PLACEHOLDER</code> instances with correct expressions.</p> <pre><code>// Decompose a height, given in inches, into the largest whole number of feet, plus the leftover\n// inches.  For example, `inches(17)` would be decomposed into `Height{feet(1), inches(5)}`.\nHeight decompose_height(QuantityU32&lt;Inches&gt; total_height) {\n    Height h;\n    h.feet = PLACEHOLDER;\n    h.inches = PLACEHOLDER;\n    return h;\n}\n</code></pre> <p>A possible solution:</p> <pre><code>// Decompose a height, given in inches, into the largest whole number of feet, plus the leftover\n// inches.  For example, `inches(17)` would be decomposed into `Height{feet(1), inches(5)}`.\nHeight decompose_height(QuantityU32&lt;Inches&gt; total_height) {\n    Height h;\n    h.feet = total_height.coerce_as(feet);  // NOTE: truncation is intended.\n    h.inches = total_height - h.feet.as(inches);\n    return h;\n}\n</code></pre> <p>If we convert the total height from inches to feet, and force it to remain an integer, it will truncate.  In this case, that\u2019s actually the desired behaviour!  (Of course, it\u2019s nice to leave a comment to reassure the reader.)  We can then reduce the total height by this integral number of feet, and we obtain the leftover inches.</p> <p>Tip</p> <p>As it happens, the <code>.as(inches)</code> is unnecessary.  You can subtract a <code>QuantityU32&lt;Feet&gt;</code> from a <code>QuantityU32&lt;Inches&gt;</code> directly!  If you do, the quantity of feet will be automatically converted to inches, because inches is a \u201ccommon unit\u201d in which we can express both quantities.  However, common units will be the topic of a later, 200-level tutorial, so we wrote the example solution using only constructs you\u2019ve already seen.</p>"},{"location":"tutorial/exercise/103-unit-conversions/#summary","title":"Summary","text":"<p>This exercise gave a few worked examples of unit conversions.  We saw how Au can immediately replace crufty, error-prone manual conversions, making code more readable.  We also saw a practical example of quantity-to-quantity conversion using <code>.as(...)</code>, including one example where the forcing \u201cexplicit-Rep\u201d form is clearly safe and correct to use.</p> <p>Return to the main tutorial page.</p>"}]}